if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=[{"name":"66-c# 基础.md","path":"13-语言学习project/10-C#/66-c# 基础.md","content":"","timestamp":1590329650947},{"name":"73-AJAX.md","path":"13-语言学习project/11-JavaScript/0-jquery/73-AJAX.md","content":"#### AJAX\r\n\r\n阅读: 869197\r\n\r\n------\r\n\r\n用JavaScript写AJAX前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。\r\n\r\n用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。\r\n\r\n### ajax\r\n\r\njQuery在全局对象`jQuery`（也就是`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=）绑定了`ajax()`函数，可以处理AJAX请求。`ajax(url, settings)`函数需要接收一个URL和一个可选的`settings`对象，常用的选项如下：\r\n\r\n- async：是否异步执行AJAX请求，默认为`true`，千万不要指定为`false`；\r\n- method：发送的Method，缺省为`\'GET\'`，可指定为`\'POST\'`、`\'PUT\'`等；\r\n- contentType：发送POST请求的格式，默认值为`\'application/x-www-form-urlencoded; charset=UTF-8\'`，也可以指定为`text/plain`、`application/json`；\r\n- data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；\r\n- headers：发送的额外的HTTP头，必须是一个object；\r\n- dataType：接收的数据格式，可以指定为`\'html\'`、`\'xml\'`、`\'json\'`、`\'text\'`等，缺省情况下根据响应的`Content-Type`猜测。\r\n\r\n下面的例子发送一个GET请求，并返回一个JSON格式的数据：\r\n\r\n```\r\nvar jqxhr = $.ajax(\'/api/categories\', {\r\n    dataType: \'json\'\r\n});\r\n// 请求已经发送了\r\n```\r\n\r\n不过，如何用回调函数处理返回的数据和出错时的响应呢？\r\n\r\n还记得Promise对象吗？jQuery的jqXHR对象类似一个Promise对象，我们可以用链式写法来处理各种回调：\r\n\r\n`\'use strict\'; function ajaxLog(s) {    var txt = $(\'#test-response-text\');    txt.val(txt.val() + \'\\n\' + s); } $(\'#test-response-text\').val(\'\'); ` Run\r\n\r\n### get\r\n\r\n对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了`get()`方法，可以这么写：\r\n\r\n```\r\nvar jqxhr = $.get(\'/path/to/resource\', {\r\n    name: \'Bob Lee\',\r\n    check: 1\r\n});\r\n```\r\n\r\n第二个参数如果是object，jQuery自动把它变成query string然后加到URL后面，实际的URL是：\r\n\r\n```\r\n/path/to/resource?name=Bob%20Lee&check=1\r\n```\r\n\r\n这样我们就不用关心如何用URL编码并构造一个query string了。\r\n\r\n### post\r\n\r\n`post()`和`get()`类似，但是传入的第二个参数默认被序列化为`application/x-www-form-urlencoded`：\r\n\r\n```\r\nvar jqxhr = $.post(\'/path/to/resource\', {\r\n    name: \'Bob Lee\',\r\n    check: 1\r\n});\r\n```\r\n\r\n实际构造的数据`name=Bob%20Lee&check=1`作为POST的body被发送。\r\n\r\n### getJSON\r\n\r\n由于JSON用得越来越普遍，所以jQuery也提供了`getJSON()`方法来快速通过GET获取一个JSON对象：\r\n\r\n```\r\nvar jqxhr = $.getJSON(\'/path/to/resource\', {\r\n    name: \'Bob Lee\',\r\n    check: 1\r\n}).done(function (data) {\r\n    // data已经被解析为JSON对象了\r\n});\r\n```\r\n\r\n### 安全限制\r\n\r\njQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。\r\n\r\n如果需要使用JSONP，可以在`ajax()`中设置`jsonp: \'callback\'`，让jQuery实现JSONP跨域加载数据。\r\n\r\n关于跨域的设置请参考[浏览器](https://www.liaoxuefeng.com/wiki/1022910821149312/1023022129105888) - [AJAX](https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400)一节中CORS的设置。","timestamp":1590329650947},{"name":"74-jQuery.md","path":"13-语言学习project/11-JavaScript/0-jquery/74-jQuery.md","content":"#### jQuery\r\n\r\n阅读: 4525721\r\n\r\n------\r\n\r\n你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。\r\n\r\n江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。\r\n\r\njQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情：\r\n\r\n- 消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；\r\n- 简洁的操作DOM的方法：写`$(\'#test\')`肯定比`document.getElementById(\'test\')`来得简洁；\r\n- 轻松实现动画、修改CSS等各种操作。\r\n\r\njQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！\r\n\r\n### jQuery版本\r\n\r\n目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。\r\n\r\n从[jQuery官网](http://jquery.com/download/)可以下载最新版本。jQuery只是一个`jquery-xxx.js`文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。\r\n\r\n### 使用jQuery\r\n\r\n使用jQuery只需要在页面的``引入jQuery文件即可：\r\n\r\n```\r\n<html>\r\n<head>\r\n    <script src=\"//code.jquery.com/jquery-1.11.3.min.js\"></script>\r\n\t...\r\n</head>\r\n<body>\r\n    ...\r\n</body>\r\n</html>\r\n```\r\n\r\n好消息是，当你在学习这个教程时，由于网站本身已经引用了jQuery，所以你可以直接使用：\r\n\r\n```\r\n\'use strict\';\r\n```\r\n\r\n Run\r\n\r\njQuery版本：2.1.4\r\n\r\n### $符号\r\n\r\n`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量`jQuery`中，而`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=也是一个合法的变量名，它是变量`jQuery`的别名：\r\n\r\n```\r\nwindow.jQuery; // jQuery(selector, context)\r\nwindow.$; // jQuery(selector, context)\r\n$ === jQuery; // true\r\ntypeof($); // \'function\'\r\n```\r\n\r\n`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=本质上就是一个函数，但是函数也是对象，于是`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=除了可以直接调用外，也可以有很多其他属性。\r\n\r\n*注意*，你看到的`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=函数名可能不是`jQuery(selector, context)`，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=函数可能变成`a(b, c)`。\r\n\r\n绝大多数时候，我们都直接用`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=（因为写起来更简单嘛）。但是，如果`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=这个变量不幸地被占用了，而且还不能改，那我们就只能让`jQuery`把`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=变量交出来，然后就只能使用`jQuery`这个变量：\r\n\r\n```\r\n$; // jQuery(selector, context)\r\njQuery.noConflict();\r\n$; // undefined\r\njQuery; // jQuery(selector, context)\r\n```\r\n\r\n这种黑魔法的原理是jQuery在占用`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=之前，先在内部保存了原来的`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=,调用`jQuery.noConflict()`时会把原来保存的变量还原。","timestamp":1590329650947},{"name":"75-事件.md","path":"13-语言学习project/11-JavaScript/0-jquery/75-事件.md","content":"#### 事件\r\n\r\n------\r\n\r\n因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。\r\n\r\n浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。\r\n\r\n由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。\r\n\r\n举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个`click`事件：\r\n\r\n```\r\n/* HTML:\r\n *\r\n * <a id=\"test-link\" href=\"#0\">点我试试</a>\r\n *\r\n */\r\n\r\n// 获取超链接的jQuery对象:\r\nvar a = $(\'#test-link\');\r\na.on(\'click\', function () {\r\n    alert(\'Hello!\');\r\n});\r\n```\r\n\r\n实测：[点我试试](https://www.liaoxuefeng.com/wiki/1022910821149312/1025427850131520#0)\r\n\r\n`on`方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。\r\n\r\n另一种更简化的写法是直接调用`click()`方法：\r\n\r\n```\r\na.click(function () {\r\n    alert(\'Hello!\');\r\n});\r\n```\r\n\r\n两者完全等价。我们通常用后面的写法。\r\n\r\njQuery能够绑定的事件主要包括：\r\n\r\n### 鼠标事件\r\n\r\n- click: 鼠标单击时触发；\r\n- dblclick：鼠标双击时触发；\r\n- mouseenter：鼠标进入时触发；\r\n- mouseleave：鼠标移出时触发；\r\n- mousemove：鼠标在DOM内部移动时触发；\r\n- hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。\r\n\r\n### 键盘事件\r\n\r\n键盘事件仅作用在当前焦点的DOM上，通常是``和``。\r\n\r\n- keydown：键盘按下时触发；\r\n- keyup：键盘松开时触发；\r\n- keypress：按一次键后触发。\r\n\r\n### 其他事件\r\n\r\n- focus：当DOM获得焦点时触发；\r\n- blur：当DOM失去焦点时触发；\r\n- change：当``、``或``的内容改变时触发；\r\n- submit：当``提交时触发；\r\n- ready：当页面被载入并且DOM树完成初始化后触发。\r\n\r\n其中，`ready`仅作用于`document`对象。由于`ready`事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个``表单绑定`submit`事件，下面的代码没有预期的效果：\r\n\r\n```\r\n<html>\r\n<head>\r\n    <script>\r\n        // 代码有误:\r\n        $(\'#testForm).on(\'submit\', function () {\r\n            alert(\'submit!\');\r\n        });\r\n    </script>\r\n</head>\r\n<body>\r\n    <form id=\"testForm\">\r\n        ...\r\n    </form>\r\n</body>\r\n```\r\n\r\n因为JavaScript在此执行的时候，``尚未载入浏览器，所以`$(\'#testForm)`返回`[]`，并没有绑定事件到任何DOM上。\r\n\r\n所以我们自己的初始化代码必须放到`document`对象的`ready`事件中，保证DOM已完成初始化：\r\n\r\n```\r\n<html>\r\n<head>\r\n    <script>\r\n        $(document).on(\'ready\', function () {\r\n            $(\'#testForm).on(\'submit\', function () {\r\n                alert(\'submit!\');\r\n            });\r\n        });\r\n    </script>\r\n</head>\r\n<body>\r\n    <form id=\"testForm\">\r\n        ...\r\n    </form>\r\n</body>\r\n```\r\n\r\n这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。\r\n\r\n由于`ready`事件使用非常普遍，所以可以这样简化：\r\n\r\n```\r\n$(document).ready(function () {\r\n    // on(\'submit\', function)也可以简化:\r\n    $(\'#testForm).submit(function () {\r\n        alert(\'submit!\');\r\n    });\r\n});\r\n```\r\n\r\n甚至还可以再简化为：\r\n\r\n```\r\n$(function () {\r\n    // init...\r\n});\r\n```\r\n\r\n上面的这种写法最为常见。如果你遇到`$(function () {...})`的形式，牢记这是`document`对象的`ready`事件处理函数。\r\n\r\n完全可以反复绑定事件处理函数，它们会依次执行：\r\n\r\n```\r\n$(function () {\r\n    console.log(\'init A...\');\r\n});\r\n$(function () {\r\n    console.log(\'init B...\');\r\n});\r\n$(function () {\r\n    console.log(\'init C...\');\r\n});\r\n```\r\n\r\n### 事件参数\r\n\r\n有些事件，如`mousemove`和`keypress`，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入`Event`对象作为参数，可以从`Event`对象上获取到更多的信息：\r\n\r\n```\r\n$(function () {\r\n    $(\'#testMouseMoveDiv\').mousemove(function (e) {\r\n        $(\'#testMouseMoveSpan\').text(\'pageX = \' + e.pageX + \', pageY = \' + e.pageY);\r\n    });\r\n});\r\n```\r\n\r\n效果实测：\r\n\r\nmousemove:\r\n\r\n在此区域移动鼠标试试\r\n\r\n### 取消绑定\r\n\r\n一个已被绑定的事件可以解除绑定，通过`off(\'click\', function)`实现：\r\n\r\n```\r\nfunction hello() {\r\n    alert(\'hello!\');\r\n}\r\n\r\na.click(hello); // 绑定事件\r\n\r\n// 10秒钟后解除绑定:\r\nsetTimeout(function () {\r\n    a.off(\'click\', hello);\r\n}, 10000);\r\n```\r\n\r\n需要特别注意的是，下面这种写法是无效的：\r\n\r\n```\r\n// 绑定事件:\r\na.click(function () {\r\n    alert(\'hello!\');\r\n});\r\n\r\n// 解除绑定:\r\na.off(\'click\', function () {\r\n    alert(\'hello!\');\r\n});\r\n```\r\n\r\n这是因为两个匿名函数虽然长得一模一样，但是它们是两个*不同*的函数对象，`off(\'click\', function () {...})`无法移除已绑定的第一个匿名函数。\r\n\r\n为了实现移除效果，可以使用`off(\'click\')`一次性移除已绑定的`click`事件的所有处理函数。\r\n\r\n同理，无参数调用`off()`一次性移除已绑定的所有类型的事件处理函数。\r\n\r\n### 事件触发条件\r\n\r\n一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动：\r\n\r\n```\r\nvar input = $(\'#test-input\');\r\ninput.change(function () {\r\n    console.log(\'changed...\');\r\n});\r\n```\r\n\r\n当用户在文本框中输入时，就会触发`change`事件。但是，如果用JavaScript代码去改动文本框的值，将*不会*触发`change`事件：\r\n\r\n```\r\nvar input = $(\'#test-input\');\r\ninput.val(\'change it!\'); // 无法触发change事件\r\n```\r\n\r\n有些时候，我们希望用代码触发`change`事件，可以直接调用无参数的`change()`方法来触发该事件：\r\n\r\n```\r\nvar input = $(\'#test-input\');\r\ninput.val(\'change it!\');\r\ninput.change(); // 触发change事件\r\n```\r\n\r\n`input.change()`相当于`input.trigger(\'change\')`，它是`trigger()`方法的简写。\r\n\r\n为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。\r\n\r\n### 浏览器安全限制\r\n\r\n在浏览器中，有些JavaScript代码只有在用户触发下才能执行，例如，`window.open()`函数：\r\n\r\n```\r\n// 无法弹出新窗口，将被浏览器屏蔽:\r\n$(function () {\r\n    window.open(\'/\');\r\n});\r\n```\r\n\r\n这些“敏感代码”只能由用户操作来触发：\r\n\r\n```\r\nvar button1 = $(\'#testPopupButton1\');\r\nvar button2 = $(\'#testPopupButton2\');\r\n\r\nfunction popupTestWindow() {\r\n    window.open(\'/\');\r\n}\r\n\r\nbutton1.click(function () {\r\n    popupTestWindow();\r\n});\r\n\r\nbutton2.click(function () {\r\n    // 不立刻执行popupTestWindow()，3秒后执行:\r\n    setTimeout(popupTestWindow, 3000);\r\n});\r\n```\r\n\r\n当用户点击`button1`时，`click`事件被触发，由于`popupTestWindow()`在`click`事件处理函数内执行，这是浏览器允许的，而`button2`的`click`事件并未立刻执行`popupTestWindow()`，延迟执行的`popupTestWindow()`将被浏览器拦截。\r\n\r\n效果实测：\r\n\r\nButton 1  Button 2\r\n\r\n### 练习\r\n\r\n对如下的Form表单：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<form id=\"test-form\" action=\"test\">\r\n    <legend>请选择想要学习的编程语言：</legend>\r\n    <fieldset>\r\n        <p><label class=\"selectAll\"><input type=\"checkbox\"> <span class=\"selectAll\">全选</span><span class=\"deselectAll\">全不选</span></label> <a href=\"#0\" class=\"invertSelect\">反选</a></p>\r\n        <p><label><input type=\"checkbox\" name=\"lang\" value=\"javascript\"> JavaScript</label></p>\r\n        <p><label><input type=\"checkbox\" name=\"lang\" value=\"python\"> Python</label></p>\r\n        <p><label><input type=\"checkbox\" name=\"lang\" value=\"ruby\"> Ruby</label></p>\r\n        <p><label><input type=\"checkbox\" name=\"lang\" value=\"haskell\"> Haskell</label></p>\r\n        <p><label><input type=\"checkbox\" name=\"lang\" value=\"scheme\"> Scheme</label></p>\r\n\t\t<p><button type=\"submit\">Submit</button></p>\r\n    </fieldset>\r\n</form>\r\n```\r\n\r\n绑定合适的事件处理函数，实现以下逻辑：\r\n\r\n当用户勾上“全选”时，自动选中所有语言，并把“全选”变成“全不选”；\r\n\r\n当用户去掉“全不选”时，自动不选中所有语言；\r\n\r\n当用户点击“反选”时，自动把所有语言状态反转（选中的变为未选，未选的变为选中）；\r\n\r\n当用户把所有语言都手动勾上时，“全选”被自动勾上，并变为“全不选”；\r\n\r\n当用户手动去掉选中至少一种语言时，“全不选”自动被去掉选中，并变为“全选”。\r\n\r\n```JavaScript\r\n\'use strict\';\r\n\r\nvar\r\n    form = $(\'#test-form\'),\r\n    langs = form.find(\'[name=lang]\'),\r\n    selectAll = form.find(\'label.selectAll :checkbox\'),\r\n    selectAllLabel = form.find(\'label.selectAll span.selectAll\'),\r\n    deselectAllLabel = form.find(\'label.selectAll span.deselectAll\'),\r\n    invertSelect = form.find(\'a.invertSelect\');\r\n\r\n// 重置初始化状态:\r\nform.find(\'*\').show().off();\r\nform.find(\':checkbox\').prop(\'checked\', false).off();\r\ndeselectAllLabel.hide();\r\n// 拦截form提交事件:\r\nform.off().submit(function (e) {\r\n    e.preventDefault();\r\n    alert(form.serialize());\r\n});\r\n$(() => {  // ready\r\n\t// “全选”变“全不选”\r\n\tfunction selectAll2deselectAll() {\r\n\t\tselectAll.prop(\'checked\', true);\r\n        selectAllLabel.hide();\r\n        deselectAllLabel.show();\r\n\t}\r\n\r\n\t// “全不选”变“全选”\r\n    function deselectAll2selectAll() {\r\n\t\tselectAll.prop(\'checked\', false);\r\n        deselectAllLabel.hide();\r\n        selectAllLabel.show();\r\n\t}\r\n\r\n\t// 判断是否全部勾选\r\n\tfunction selectAllOrNot() {\r\n\t\tlangs.get().every(e => e.checked) ? selectAll2deselectAll() : deselectAll2selectAll();\r\n\t}\r\n\r\n\t// 勾“全选”与去“全不选”\r\n\tselectAll.click(() => {\r\n        if (selectAll.is(\':checked\')) {\r\n            langs.prop(\'checked\', true);\r\n            selectAll2deselectAll()\r\n        } else {\r\n            langs.prop(\'checked\', false);\r\n        \tdeselectAll2selectAll()\r\n        }\r\n\t});\r\n\r\n\t// “反选”时，选中变未选，未选变选中，并判断是否全部勾选\r\n\tinvertSelect.click(() => {\r\n\t\tlangs.prop(\'checked\', (index, oldvalue) => !oldvalue);\r\n        selectAllOrNot();\r\n\t})\r\n\r\n\t// 全部勾选与否\r\n\tlangs.click(selectAllOrNot);\r\n});\r\n// 测试:\r\nconsole.log(\'请测试功能是否正常。\');\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"76-修改Dorm.md","path":"13-语言学习project/11-JavaScript/0-jquery/76-修改Dorm.md","content":"#### 修改DOM结构\r\n\r\n阅读: 496262\r\n\r\n------\r\n\r\n直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。\r\n\r\n有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化了。\r\n\r\n### 添加DOM\r\n\r\n要添加新的DOM节点，除了通过jQuery的`html()`这种暴力方法外，还可以用`append()`方法，例如：\r\n\r\n```\r\n<div id=\"test-div\">\r\n    <ul>\r\n        <li><span>JavaScript</span></li>\r\n        <li><span>Python</span></li>\r\n        <li><span>Swift</span></li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\n如何向列表新增一个语言？首先要拿到``节点：\r\n\r\n```\r\nvar ul = $(\'#test-div>ul\');\r\n```\r\n\r\n然后，调用`append()`传入HTML片段：\r\n\r\n```\r\nul.append(\'<li><span>Haskell</span></li>\');\r\n```\r\n\r\n除了接受字符串，`append()`还可以传入原始的DOM对象，jQuery对象和函数对象：\r\n\r\n```\r\n// 创建DOM对象:\r\nvar ps = document.createElement(\'li\');\r\nps.innerHTML = \'<span>Pascal</span>\';\r\n// 添加DOM对象:\r\nul.append(ps);\r\n\r\n// 添加jQuery对象:\r\nul.append($(\'#scheme\'));\r\n\r\n// 添加函数对象:\r\nul.append(function (index, html) {\r\n    return \'<li><span>Language - \' + index + \'</span></li>\';\r\n});\r\n```\r\n\r\n传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的`append()`可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。\r\n\r\n`append()`把DOM添加到最后，`prepend()`则把DOM添加到最前。\r\n\r\n另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用`append()`，你可以移动一个DOM节点。\r\n\r\n如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用`after()`方法：\r\n\r\n```\r\nvar js = $(\'#test-div>ul>li:first-child\');\r\njs.after(\'<li><span>Lua</span></li>\');\r\n```\r\n\r\n也就是说，同级节点可以用`after()`或者`before()`方法。\r\n\r\n### 删除节点\r\n\r\n要删除DOM节点，拿到jQuery对象后直接调用`remove()`方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点：\r\n\r\n```\r\nvar li = $(\'#test-div>ul>li\');\r\nli.remove(); // 所有<li>全被删除\r\n```\r\n\r\n### 练习\r\n\r\n除了列出的3种语言外，请再添加Pascal、Lua和Ruby，然后按字母顺序排序节点：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-div\">\r\n    <ul>\r\n        <li><span>JavaScript</span></li>\r\n        <li><span>Python</span></li>\r\n        <li><span>Swift</span></li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\n- ```\r\n  \'use strict\';\r\n  \r\n  // 添加\r\n  var ul = $(\'#test-div ul\');\r\n  var arr = [\'Pascal\', \'Lua\', \'Ruby\'].map(e => \'<li><span>\' + e + \'</span></li>\');\r\n  ul.append(arr);\r\n  \r\n  // 排序\r\n  var li = ul.find(\'li\');\r\n  var sort = li.get().map(e => e.innerText).sort();\r\n  li.get().map((e, i) => e.innerText = sort[i]);\r\n  // 测试:\r\n  ;(function () {\r\n      var s = $(\'#test-div>ul>li\').map(function () {\r\n          return $(this).text();\r\n      }).get().join(\',\');\r\n      if (s === \'JavaScript,Lua,Pascal,Python,Ruby,Swift\') {\r\n          console.log(\'测试通过!\');\r\n      } else {\r\n          console.log(\'测试失败: \' + s);\r\n      }\r\n  })();\r\n  ```\r\n\r\n  ","timestamp":1590329650947},{"name":"77-动画.md","path":"13-语言学习project/11-JavaScript/0-jquery/77-动画.md","content":"#### 动画\r\n\r\n阅读: 403976\r\n\r\n------\r\n\r\n用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。\r\n\r\n但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。\r\n\r\n使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！\r\n\r\n让我们先来看看jQuery内置的几种动画样式：\r\n\r\n### show / hide\r\n\r\n直接以无参数形式调用`show()`和`hide()`，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画：\r\n\r\n```\r\nvar div = $(\'#test-show-hide\');\r\ndiv.hide(3000); // 在3秒钟内逐渐消失\r\n```\r\n\r\n时间以毫秒为单位，但也可以是`\'slow\'`，`\'fast\'`这些字符串：\r\n\r\n```\r\nvar div = $(\'#test-show-hide\');\r\ndiv.show(\'slow\'); // 在0.6秒钟内逐渐显示\r\n```\r\n\r\n`toggle()`方法则根据当前状态决定是`show()`还是`hide()`。\r\n\r\n效果实测：\r\n\r\nhide(\'slow\') show(\'slow\') toggle(\'slow\')\r\n\r\n### slideUp / slideDown\r\n\r\n你可能已经看出来了，`show()`和`hide()`是从左上角逐渐展开或收缩的，而`slideUp()`和`slideDown()`则是在垂直方向逐渐展开或收缩的。\r\n\r\n`slideUp()`把一个可见的DOM元素收起来，效果跟拉上窗帘似的，`slideDown()`相反，而`slideToggle()`则根据元素是否可见来决定下一步动作：\r\n\r\n```\r\nvar div = $(\'#test-slide\');\r\ndiv.slideUp(3000); // 在3秒钟内逐渐向上消失\r\n```\r\n\r\n效果实测：\r\n\r\nslideUp(\'slow\') slideDown(\'slow\') slideToggle(\'slow\')\r\n\r\n### fadeIn / fadeOut\r\n\r\n`fadeIn()`和`fadeOut()`的动画效果是淡入淡出，也就是通过不断设置DOM元素的`opacity`属性来实现，而`fadeToggle()`则根据元素是否可见来决定下一步动作：\r\n\r\n```\r\nvar div = $(\'#test-fade\');\r\ndiv.fadeOut(\'slow\'); // 在0.6秒内淡出\r\n```\r\n\r\nfadeOut(\'slow\') fadeIn(\'slow\') fadeToggle(\'slow\')\r\n\r\n### 自定义动画\r\n\r\n如果上述动画效果还不能满足你的要求，那就祭出最后大招：`animate()`，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值：\r\n\r\n```\r\nvar div = $(\'#test-animate\');\r\ndiv.animate({\r\n    opacity: 0.25,\r\n    width: \'256px\',\r\n    height: \'256px\'\r\n}, 3000); // 在3秒钟内CSS过渡到设定值\r\n```\r\n\r\n`animate()`还可以再传入一个函数，当动画结束时，该函数将被调用：\r\n\r\n```\r\nvar div = $(\'#test-animate\');\r\ndiv.animate({\r\n    opacity: 0.25,\r\n    width: \'256px\',\r\n    height: \'256px\'\r\n}, 3000, function () {\r\n    console.log(\'动画已结束\');\r\n    // 恢复至初始状态:\r\n    $(this).css(\'opacity\', \'1.0\').css(\'width\', \'128px\').css(\'height\', \'128px\');\r\n});\r\n```\r\n\r\n实际上这个回调函数参数对于基本动画也是适用的。\r\n\r\n有了`animate()`，你就可以实现各种自定义动画效果了：\r\n\r\nanimate()\r\n\r\n### 串行动画\r\n\r\njQuery的动画效果还可以串行执行，通过`delay()`方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单：\r\n\r\n```\r\nvar div = $(\'#test-animates\');\r\n// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小\r\ndiv.slideDown(2000)\r\n   .delay(1000)\r\n   .animate({\r\n       width: \'256px\',\r\n       height: \'256px\'\r\n   }, 2000)\r\n   .delay(1000)\r\n   .animate({\r\n       width: \'128px\',\r\n       height: \'128px\'\r\n   }, 2000);\r\n}\r\n</script>\r\n```\r\n\r\n因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。\r\n\r\n效果实测：\r\n\r\nanimate\r\n\r\n### 为什么有的动画没有效果\r\n\r\n你可能会遇到，有的动画如`slideUp()`根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如`height`从`100px`逐渐变为`0`。但是很多不是block性质的DOM元素，对它们设置`height`根本就不起作用，所以动画也就没有效果。\r\n\r\n此外，jQuery也没有实现对`background-color`的动画效果，用`animate()`设置`background-color`也没有效果。这种情况下可以使用CSS3的`transition`实现动画效果。\r\n\r\n### 练习\r\n\r\n在执行删除操作时，给用户显示一个动画比直接调用`remove()`要更好。请在表格删除一行的时候添加一个淡出的动画效果：\r\n\r\n`\'use strict\'; function deleteFirstTR() {    var tr = $(\'#test-table>tbody>tr:visible\').first(); ``} deleteFirstTR(); ` Run\r\n\r\n| Name             | Email                 | Address     | Status |\r\n| :--------------- | :-------------------- | :---------- | :----- |\r\n| Bart Simpson     | bart.s@primary.school | Springfield | Active |\r\n| Michael Scofield | m.scofield@escape.org | Fox River   | Locked |\r\n| Optimus Prime    | prime@cybertron.org   | Cybertron   | Active |\r\n| Peter Parker     | spider@movie.org      | New York    | Active |\r\n| Thor Odinson     | thor@asgard.org       | Asgard      | Active |\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction deleteFirstTR() {\r\n    var tr = $(\'#test-table>tbody>tr:visible\').first();\r\n\r\ntr.fadeOut(1000,()=>tr.remove());\r\n}\r\n\r\ndeleteFirstTR();\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"78-层级选择器.md","path":"13-语言学习project/11-JavaScript/0-jquery/78-层级选择器.md","content":"#### 层级选择器\r\n\r\n------\r\n\r\n除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大。\r\n\r\n因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。\r\n\r\n### 层级选择器（Descendant Selector）\r\n\r\n如果两个DOM元素具有层级关系，就可以用`$(\'ancestor descendant\')`来选择，层级之间用空格隔开。例如：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div class=\"testing\">\r\n    <ul class=\"lang\">\r\n        <li class=\"lang-javascript\">JavaScript</li>\r\n        <li class=\"lang-python\">Python</li>\r\n        <li class=\"lang-lua\">Lua</li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\n要选出JavaScript，可以用层级选择器：\r\n\r\n```\r\n$(\'ul.lang li.lang-javascript\'); // [<li class=\"lang-javascript\">JavaScript</li>]\r\n$(\'div.testing li.lang-javascript\'); // [<li class=\"lang-javascript\">JavaScript</li>]\r\n```\r\n\r\n```\r\n因为<div>和<ul>都是<li>的祖先节点，所以上面两种方式都可以选出相应的<li>节点。\r\n```\r\n\r\n要选择所有的`li`节点，用：\r\n\r\n```\r\n$(\'ul.lang li\');\r\n```\r\n\r\n这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。\r\n\r\n例如：\r\n\r\n```\r\n$(\'form[name=upload] input\');\r\n```\r\n\r\n就把选择范围限定在`name`属性为`upload`的表单里。如果页面有很多表单，其他表单的``不会被选择。\r\n\r\n多层选择也是允许的：\r\n\r\n```\r\n$(\'form.test p input\'); // 在form表单选择被<p>包含的<input>\r\n```\r\n\r\n### 子选择器（Child Selector）\r\n\r\n子选择器`$(\'parent>child\')`类似层级选择器，但是限定了层级关系必须是父子关系，就是``节点必须是``节点的直属子节点。还是以上面的例子：\r\n\r\n```\r\n$(\'ul.lang>li.lang-javascript\'); // 可以选出[<li class=\"lang-javascript\">JavaScript</li>]\r\n$(\'div.testing>li.lang-javascript\'); // [], 无法选出，因为<div>和<li>不构成父子关系\r\n```\r\n\r\n### 过滤器（Filter）\r\n\r\n过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果：\r\n\r\n```JavaScript\r\n$(\'ul.lang li\'); // 选出JavaScript、Python和Lua 3个节点\r\n\r\n$(\'ul.lang li:first-child\'); // 仅选出JavaScript\r\n$(\'ul.lang li:last-child\'); // 仅选出Lua\r\n$(\'ul.lang li:nth-child(2)\'); // 选出第N个元素，N从1开始\r\n$(\'ul.lang li:nth-child(even)\'); // 选出序号为偶数的元素\r\n$(\'ul.lang li:nth-child(odd)\'); // 选出序号为奇数的元素\r\n```\r\n\r\n### 表单相关\r\n\r\n针对表单元素，jQuery还有一组特殊的选择器：\r\n\r\n- ```JavaScript\r\n  :input：可以选择<input>，<textarea>，<select>和<button>；\r\n  :file：可以选择<input type=\"file\">，和input[type=file]一样；\r\n  :checkbox：可以选择复选框，和input[type=checkbox]一样；\r\n  :radio：可以选择单选框，和input[type=radio]一样；\r\n  :focus：可以选择当前输入焦点的元素，例如把光标放到一个<input>上，用$(\'input:focus\')就可以选出；\r\n  :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(\'input[type=radio]:checked\')；\r\n  :enabled：可以选择可以正常输入的<input>、<select> 等，也就是没有灰掉的输入；\r\n  :disabled：和:enabled正好相反，选择那些不能输入的。\r\n  ```\r\n\r\n此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素：\r\n\r\n```\r\n$(\'div:visible\'); // 所有可见的div\r\n$(\'div:hidden\'); // 所有隐藏的div\r\n```\r\n\r\n### 练习\r\n\r\n针对如下HTML结构：\r\n\r\n```html\r\n<!-- HTML结构 -->\r\n\r\n<div class=\"test-selector\">\r\n    <ul class=\"test-lang\">\r\n        <li class=\"lang-javascript\">JavaScript</li>\r\n        <li class=\"lang-python\">Python</li>\r\n        <li class=\"lang-lua\">Lua</li>\r\n    </ul>\r\n    <ol class=\"test-lang\">\r\n        <li class=\"lang-swift\">Swift</li>\r\n        <li class=\"lang-java\">Java</li>\r\n        <li class=\"lang-c\">C</li>\r\n    </ol>\r\n</div>\r\n```\r\n\r\n选出相应的内容并观察效果：\r\n\r\n1. ```JavaScript\r\n   \'use strict\';\r\n   var selected = null;\r\n   // 分别选择所有语言，所有动态语言，所有静态语言，JavaScript，Lua，C等:\r\n   selected = $(\'div.test-selector li\');        // 所有语言\r\n   selected = $(\'ul.test-lang li\');             // 所有动态语言\r\n   selected = $(\'ol.test-lang li\');             // 所有静态语言\r\n   selected = $(\'ul.test-lang li:first-child\')  // JavaScript\r\n   selected = $(\'ul.test-lang li:last-child\')   // Lua\r\n   selected = $(\'ol.test-lang li:last-child\')   // C\r\n   // 高亮结果:\r\n   if (!(selected instanceof jQuery)) {\r\n       return console.log(\'不是有效的jQuery对象!\');\r\n   }\r\n   $(\'#test-jquery\').find(\'*\').css(\'background-color\', \'\');\r\n   selected.css(\'background-color\', \'#ffd351\');\r\n   ```\r\n\r\n   ","timestamp":1590329650947},{"name":"79-扩展.md","path":"13-语言学习project/11-JavaScript/0-jquery/79-扩展.md","content":"#### 扩展\r\n\r\n阅读: 293177\r\n\r\n------\r\n\r\n当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。\r\n\r\n但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现：\r\n\r\n```\r\n$(\'span.hl\').css(\'backgroundColor\', \'#fffceb\').css(\'color\', \'#d85030\');\r\n\r\n$(\'p a.hl\').css(\'backgroundColor\', \'#fffceb\').css(\'color\', \'#d85030\');\r\n```\r\n\r\n总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个`highlight()`方法？\r\n\r\n```\r\n$(\'span.hl\').highlight();\r\n\r\n$(\'p a.hl\').highlight();\r\n```\r\n\r\n答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。\r\n\r\n### 编写jQuery插件\r\n\r\n给jQuery对象绑定一个新方法是通过扩展`$.fn`对象实现的。让我们来编写第一个扩展——`highlight1()`：\r\n\r\n```\r\n$.fn.highlight1 = function () {\r\n    // this已绑定为当前jQuery对象:\r\n    this.css(\'backgroundColor\', \'#fffceb\').css(\'color\', \'#d85030\');\r\n    return this;\r\n}\r\n```\r\n\r\n注意到函数内部的`this`在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。\r\n\r\n对于如下的HTML结构：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-highlight1\">\r\n    <p>什么是<span>jQuery</span></p>\r\n    <p><span>jQuery</span>是目前最流行的<span>JavaScript</span>库。</p>\r\n</div>\r\n```\r\n\r\n来测试一下`highlight1()`的效果：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n什么是jQuery\r\n\r\njQuery是目前最流行的JavaScript库。\r\n\r\n细心的童鞋可能发现了，为什么最后要`return this;`？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去：\r\n\r\n```\r\n$(\'span.hl\').highlight1().slideDown();\r\n```\r\n\r\n不然，用户调用的时候，就不得不把上面的代码拆成两行。\r\n\r\n但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？\r\n\r\n我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的`highlight2()`：\r\n\r\n```\r\n$.fn.highlight2 = function (options) {\r\n    // 要考虑到各种情况:\r\n    // options为undefined\r\n    // options只有部分key\r\n    var bgcolor = options && options.backgroundColor || \'#fffceb\';\r\n    var color = options && options.color || \'#d85030\';\r\n    this.css(\'backgroundColor\', bgcolor).css(\'color\', color);\r\n    return this;\r\n}\r\n```\r\n\r\n对于如下HTML结构：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-highlight2\">\r\n    <p>什么是<span>jQuery</span> <span>Plugin</span></p>\r\n    <p>编写<span>jQuery</span> <span>Plugin</span>可以用来扩展<span>jQuery</span>的功能。</p>\r\n</div>\r\n```\r\n\r\n来实测一下带参数的`highlight2()`：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n什么是jQuery Plugin\r\n\r\n编写jQuery Plugin可以用来扩展jQuery的功能。\r\n\r\n对于默认值的处理，我们用了一个简单的`&&`和`||`短路操作符，总能得到一个有效的值。\r\n\r\n另一种方法是使用jQuery提供的辅助方法`$.extend(target, obj1, obj2, ...)`，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高：\r\n\r\n```\r\n// 把默认值和用户传入的options合并到对象{}中并返回:\r\nvar opts = $.extend({}, {\r\n    backgroundColor: \'#00a8e6\',\r\n    color: \'#ffffff\'\r\n}, options);\r\n```\r\n\r\n紧接着用户对`highlight2()`提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的`highlight2()`？\r\n\r\n也就是说，我们设定的默认值应该能允许用户修改。\r\n\r\n那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是`$.fn.highlight2`这个函数对象本身。\r\n\r\n于是最终版的`highlight()`终于诞生了：\r\n\r\n```\r\n$.fn.highlight = function (options) {\r\n    // 合并默认值和用户设定值:\r\n    var opts = $.extend({}, $.fn.highlight.defaults, options);\r\n    this.css(\'backgroundColor\', opts.backgroundColor).css(\'color\', opts.color);\r\n    return this;\r\n}\r\n\r\n// 设定默认值:\r\n$.fn.highlight.defaults = {\r\n    color: \'#d85030\',\r\n    backgroundColor: \'#fff8de\'\r\n}\r\n```\r\n\r\n这次用户终于满意了。用户使用时，只需一次性设定默认值：\r\n\r\n```\r\n$.fn.highlight.defaults.color = \'#fff\';\r\n$.fn.highlight.defaults.backgroundColor = \'#000\';\r\n```\r\n\r\n然后就可以非常简单地调用`highlight()`了。\r\n\r\n对如下的HTML结构：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-highlight\">\r\n    <p>如何编写<span>jQuery</span> <span>Plugin</span></p>\r\n    <p>编写<span>jQuery</span> <span>Plugin</span>，要设置<span>默认值</span>，并允许用户修改<span>默认值</span>，或者运行时传入<span>其他值</span>。</p>\r\n</div>\r\n```\r\n\r\n实测一下修改默认值的效果：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n如何编写jQuery Plugin\r\n\r\n编写jQuery Plugin，要设置默认值，并允许用户修改默认值，或者运行时传入其他值。\r\n\r\n最终，我们得出编写一个jQuery插件的原则：\r\n\r\n1. 给`$.fn`绑定函数，实现插件的代码逻辑；\r\n2. 插件函数最后要`return this;`以支持链式调用；\r\n3. 插件函数要有默认值，绑定在`$.fn..defaults`上；\r\n4. 用户在调用时可传入设定值以便覆盖默认值。\r\n\r\n### 针对特定元素的扩展\r\n\r\n我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如`submit()`方法只能针对`form`。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？\r\n\r\n还记得jQuery的选择器支持`filter()`方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。\r\n\r\n举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？\r\n\r\n先写出用户调用的代码：\r\n\r\n```\r\n$(\'#main a\').external();\r\n```\r\n\r\n然后按照上面的方法编写一个`external`扩展：\r\n\r\n```\r\n$.fn.external = function () {\r\n    // return返回的each()返回结果，支持链式调用:\r\n    return this.filter(\'a\').each(function () {\r\n        // 注意: each()内部的回调函数的this绑定为DOM本身!\r\n        var a = $(this);\r\n        var url = a.attr(\'href\');\r\n        if (url && (url.indexOf(\'http://\')===0 || url.indexOf(\'https://\')===0)) {\r\n            a.attr(\'href\', \'#0\')\r\n             .removeAttr(\'target\')\r\n             .append(\' <i class=\"uk-icon-external-link\"></i>\')\r\n             .click(function () {\r\n                if(confirm(\'你确定要前往\' + url + \'？\')) {\r\n                    window.open(url);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n对如下的HTML结构：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-external\">\r\n    <p>如何学习<a href=\"http://jquery.com\">jQuery</a>？</p>\r\n    <p>首先，你要学习<a href=\"/wiki/1022910821149312\">JavaScript</a>，并了解基本的<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML\">HTML</a>。</p>\r\n</div>\r\n```\r\n\r\n实测外链效果：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n如何学习[jQuery](http://jquery.com/)？\r\n\r\n首先，你要学习[JavaScript](https://www.liaoxuefeng.com/wiki/1022910821149312)，并了解基本的[HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)。","timestamp":1590329650947},{"name":"80-操作Dorm.md","path":"13-语言学习project/11-JavaScript/0-jquery/80-操作Dorm.md","content":"#### 操作DOM\r\n\r\n阅读: 696255\r\n\r\n------\r\n\r\njQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？\r\n\r\n答案当然是操作对应的DOM节点啦！\r\n\r\n回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！\r\n\r\n### 修改Text和HTML\r\n\r\njQuery对象的`text()`和`html()`方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<ul id=\"test-ul\">\r\n    <li class=\"js\">JavaScript</li>\r\n    <li name=\"book\">Java &amp; JavaScript</li>\r\n</ul>\r\n```\r\n\r\n分别获取文本和HTML：\r\n\r\n```\r\n$(\'#test-ul li[name=book]\').text(); // \'Java & JavaScript\'\r\n$(\'#test-ul li[name=book]\').html(); // \'Java &amp; JavaScript\'\r\n```\r\n\r\n如何设置文本或HTML？jQuery的API设计非常巧妙：无参数调用`text()`是获取文本，传入参数就变成设置文本，HTML也是类似操作，自己动手试试：\r\n\r\n`\'use strict\'; var j1 = $(\'#test-ul li.js\'); var j2 = $(\'#test-ul li[name=book]\'); ` Run\r\n\r\n- JavaScript\r\n- Java & JavaScript\r\n\r\n一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试：\r\n\r\n```\r\n$(\'#test-ul li\').text(\'JS\'); // 是不是两个节点都变成了JS？\r\n```\r\n\r\n所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错：\r\n\r\n```\r\n// 如果不存在id为not-exist的节点：\r\n$(\'#not-exist\').text(\'Hello\'); // 代码不报错，没有节点被设置为\'Hello\'\r\n```\r\n\r\n这意味着jQuery帮你免去了许多`if`语句。\r\n\r\n### 修改CSS\r\n\r\njQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<ul id=\"test-css\">\r\n    <li class=\"lang dy\"><span>JavaScript</span></li>\r\n    <li class=\"lang\"><span>Java</span></li>\r\n    <li class=\"lang dy\"><span>Python</span></li>\r\n    <li class=\"lang\"><span>Swift</span></li>\r\n    <li class=\"lang dy\"><span>Scheme</span></li>\r\n</ul>\r\n```\r\n\r\n要高亮显示动态语言，调用jQuery对象的`css(\'name\', \'value\')`方法，我们用一行语句实现：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n- JavaScript\r\n- Java\r\n- Python\r\n- Swift\r\n- Scheme\r\n\r\n*注意*，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。\r\n\r\njQuery对象的`css()`方法可以这么用：\r\n\r\n```\r\nvar div = $(\'#test-div\');\r\ndiv.css(\'color\'); // \'#000033\', 获取CSS属性\r\ndiv.css(\'color\', \'#336699\'); // 设置CSS属性\r\ndiv.css(\'color\', \'\'); // 清除CSS属性\r\n```\r\n\r\n为了和JavaScript保持一致，CSS属性可以用`\'background-color\'`和`\'backgroundColor\'`两种格式。\r\n\r\n`css()`方法将作用于DOM节点的`style`属性，具有最高优先级。如果要修改`class`属性，可以用jQuery提供的下列方法：\r\n\r\n```\r\nvar div = $(\'#test-div\');\r\ndiv.hasClass(\'highlight\'); // false， class是否包含highlight\r\ndiv.addClass(\'highlight\'); // 添加highlight这个class\r\ndiv.removeClass(\'highlight\'); // 删除highlight这个class\r\n```\r\n\r\n练习：分别用`css()`方法和`addClass()`方法高亮显示JavaScript：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<style>\r\n.highlight {\r\n    color: #dd1144;\r\n    background-color: #ffd351;\r\n}\r\n</style>\r\n\r\n<div id=\"test-highlight-css\">\r\n    <ul>\r\n        <li class=\"py\"><span>Python</span></li>\r\n        <li class=\"js\"><span>JavaScript</span></li>\r\n        <li class=\"sw\"><span>Swift</span></li>\r\n        <li class=\"hk\"><span>Haskell</span></li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\n`\'use strict\'; ` Run\r\n\r\n- Python\r\n- JavaScript\r\n- Swift\r\n- Haskell\r\n\r\n### 显示和隐藏DOM\r\n\r\n要隐藏一个DOM，我们可以设置CSS的`display`属性为`none`，利用`css()`方法就可以实现。不过，要显示这个DOM就需要恢复原有的`display`属性，这就得先记下来原有的`display`属性到底是`block`还是`inline`还是别的值。\r\n\r\n考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供`show()`和`hide()`方法，我们不用关心它是如何修改`display`属性的，总之它能正常工作：\r\n\r\n```\r\nvar a = $(\'a[target=_blank]\');\r\na.hide(); // 隐藏\r\na.show(); // 显示\r\n```\r\n\r\n*注意*，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。\r\n\r\n### 获取DOM信息\r\n\r\n利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码：\r\n\r\n```\r\n// 浏览器可视窗口大小:\r\n$(window).width(); // 800\r\n$(window).height(); // 600\r\n\r\n// HTML文档大小:\r\n$(document).width(); // 800\r\n$(document).height(); // 3500\r\n\r\n// 某个div的大小:\r\nvar div = $(\'#test-div\');\r\ndiv.width(); // 600\r\ndiv.height(); // 300\r\ndiv.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效\r\ndiv.height(\'200px\'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效\r\n```\r\n\r\n`attr()`和`removeAttr()`方法用于操作DOM节点的属性：\r\n\r\n```\r\n// <div id=\"test-div\" name=\"Test\" start=\"1\">...</div>\r\nvar div = $(\'#test-div\');\r\ndiv.attr(\'data\'); // undefined, 属性不存在\r\ndiv.attr(\'name\'); // \'Test\'\r\ndiv.attr(\'name\', \'Hello\'); // div的name属性变为\'Hello\'\r\ndiv.removeAttr(\'name\'); // 删除name属性\r\ndiv.attr(\'name\'); // undefined\r\n```\r\n\r\n`prop()`方法和`attr()`类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如：\r\n\r\n```\r\n<input id=\"test-radio\" type=\"radio\" name=\"test\" checked value=\"1\">\r\n```\r\n\r\n等价于：\r\n\r\n```\r\n<input id=\"test-radio\" type=\"radio\" name=\"test\" checked=\"checked\" value=\"1\">\r\n```\r\n\r\n`attr()`和`prop()`对于属性`checked`处理有所不同：\r\n\r\n```\r\nvar radio = $(\'#test-radio\');\r\nradio.attr(\'checked\'); // \'checked\'\r\nradio.prop(\'checked\'); // true\r\n```\r\n\r\n`prop()`返回值更合理一些。不过，用`is()`方法判断更好：\r\n\r\n```\r\nvar radio = $(\'#test-radio\');\r\nradio.is(\':checked\'); // true\r\n```\r\n\r\n类似的属性还有`selected`，处理时最好用`is(\':selected\')`。\r\n\r\n### 操作表单\r\n\r\n对于表单元素，jQuery对象统一提供`val()`方法获取和设置对应的`value`属性：\r\n\r\n```\r\n/*\r\n    <input id=\"test-input\" name=\"email\" value=\"\">\r\n    <select id=\"test-select\" name=\"city\">\r\n        <option value=\"BJ\" selected>Beijing</option>\r\n        <option value=\"SH\">Shanghai</option>\r\n        <option value=\"SZ\">Shenzhen</option>\r\n    </select>\r\n    <textarea id=\"test-textarea\">Hello</textarea>\r\n*/\r\nvar\r\n    input = $(\'#test-input\'),\r\n    select = $(\'#test-select\'),\r\n    textarea = $(\'#test-textarea\');\r\n\r\ninput.val(); // \'test\'\r\ninput.val(\'abc@example.com\'); // 文本框的内容已变为abc@example.com\r\n\r\nselect.val(); // \'BJ\'\r\nselect.val(\'SH\'); // 选择框已变为Shanghai\r\n\r\ntextarea.val(); // \'Hello\'\r\ntextarea.val(\'Hi\'); // 文本区域已更新为\'Hi\'\r\n```\r\n\r\n可见，一个`val()`就统一了各种输入框的取值和赋值的问题。","timestamp":1590329650947},{"name":"81-查找和过滤.md","path":"13-语言学习project/11-JavaScript/0-jquery/81-查找和过滤.md","content":"#### 查找和过滤\r\n\r\n------\r\n\r\n通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。\r\n\r\n最常见的查找是在某个节点的所有子节点中查找，使用`find()`方法，它本身又接收一个任意的选择器。例如如下的HTML结构：\r\n\r\n- JavaScript\r\n- Python\r\n- Swift\r\n- Scheme\r\n- Haskell\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<ul class=\"lang\">\r\n    <li class=\"js dy\">JavaScript</li>\r\n    <li class=\"dy\">Python</li>\r\n    <li id=\"swift\">Swift</li>\r\n    <li class=\"dy\">Scheme</li>\r\n    <li name=\"haskell\">Haskell</li>\r\n</ul>\r\n```\r\n\r\n用`find()`查找：\r\n\r\n```\r\nvar ul = $(\'ul.lang\'); // 获得<ul>\r\nvar dy = ul.find(\'.dy\'); // 获得JavaScript, Python, Scheme\r\nvar swf = ul.find(\'#swift\'); // 获得Swift\r\nvar hsk = ul.find(\'[name=haskell]\'); // 获得Haskell\r\n```\r\n\r\n如果要从当前节点开始向上查找，使用`parent()`方法：\r\n\r\n```\r\nvar swf = $(\'#swift\'); // 获得Swift\r\nvar parent = swf.parent(); // 获得Swift的上层节点<ul>\r\nvar a = swf.parent(\'.red\'); // 获得Swift的上层节点<ul>，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象\r\n```\r\n\r\n对于位于同一层级的节点，可以通过`next()`和`prev()`方法，例如：\r\n\r\n当我们已经拿到`Swift`节点后：\r\n\r\n```\r\nvar swift = $(\'#swift\');\r\n\r\nswift.next(); // Scheme\r\nswift.next(\'[name=haskell]\'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]\r\n\r\nswift.prev(); // Python\r\nswift.prev(\'.dy\'); // Python，因为Python同时符合过滤器条件.dy\r\n```\r\n\r\n### 过滤\r\n\r\n和函数式编程的map、filter类似，jQuery对象也有类似的方法。\r\n\r\n`filter()`方法可以过滤掉不符合选择器条件的节点：\r\n\r\n```\r\nvar langs = $(\'ul.lang li\'); // 拿到JavaScript, Python, Swift, Scheme和Haskell\r\nvar a = langs.filter(\'.dy\'); // 拿到JavaScript, Python, Scheme\r\n```\r\n\r\n或者传入一个函数，要特别注意函数内部的`this`被绑定为DOM对象，不是jQuery对象：\r\n\r\n```\r\nvar langs = $(\'ul.lang li\'); // 拿到JavaScript, Python, Swift, Scheme和Haskell\r\nlangs.filter(function () {\r\n    return this.innerHTML.indexOf(\'S\') === 0; // 返回S开头的节点\r\n}); // 拿到Swift, Scheme\r\n```\r\n\r\n`map()`方法把一个jQuery对象包含的若干DOM节点转化为其他对象：\r\n\r\n```\r\nvar langs = $(\'ul.lang li\'); // 拿到JavaScript, Python, Swift, Scheme和Haskell\r\nvar arr = langs.map(function () {\r\n    return this.innerHTML;\r\n}).get(); // 用get()拿到包含string的Array：[\'JavaScript\', \'Python\', \'Swift\', \'Scheme\', \'Haskell\']\r\n```\r\n\r\n此外，一个jQuery对象如果包含了不止一个DOM节点，`first()`、`last()`和`slice()`方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉：\r\n\r\n```\r\nvar langs = $(\'ul.lang li\'); // 拿到JavaScript, Python, Swift, Scheme和Haskell\r\nvar js = langs.first(); // JavaScript，相当于$(\'ul.lang li:first-child\')\r\nvar haskell = langs.last(); // Haskell, 相当于$(\'ul.lang li:last-child\')\r\nvar sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致\r\n```\r\n\r\n### 练习\r\n\r\n对于下面的表单：\r\n\r\n```\r\n<form id=\"test-form\" action=\"#0\" onsubmit=\"return false;\">\r\n    <p><label>Name: <input name=\"name\"></label></p>\r\n    <p><label>Email: <input name=\"email\"></label></p>\r\n    <p><label>Password: <input name=\"password\" type=\"password\"></label></p>\r\n    <p>Gender: <label><input name=\"gender\" type=\"radio\" value=\"m\" checked> Male</label> <label><input name=\"gender\" type=\"radio\" value=\"f\"> Female</label></p>\r\n    <p><label>City: <select name=\"city\">\r\n    \t<option value=\"BJ\" selected>Beijing</option>\r\n    \t<option value=\"SH\">Shanghai</option>\r\n    \t<option value=\"CD\">Chengdu</option>\r\n    \t<option value=\"XM\">Xiamen</option>\r\n    </select></label></p>\r\n    <p><button type=\"submit\">Submit</button></p>\r\n</form>\r\n```\r\n\r\n输入值后，用jQuery获取表单的JSON字符串，key和value分别对应每个输入的name和相应的value，例如：`{\"name\":\"Michael\",\"email\":...}`\r\n\r\n```JavaScript\r\n\'use strict\';\r\nvar json = null;\r\n/*\r\njson = {};\r\njson.name = $(\'input[name=name]\')[0].value;\r\njson.email = $(\'input[name=email]\')[0].value;\r\njson.password = $(\'input[name=password]\')[0].value;\r\njson.gender = $(\'input[name=gender]\').filter(function() { return this.checked; })[0].value === \'m\' ? \'Male\' : \'Female\';\r\njson.city = $(\'select[name=city] option\').filter(function() { return this.selected; })[0].innerText;\r\njson = JSON.stringify(json, null, \'  \');\r\n*/\r\njson={};\r\n$(\'#test-form :input\').not(\'button\').filter(function(){\r\n   return this.type!==\'radio\'||this.checked && this.type!==\'submit\';\r\n}).map(function(){\r\n   return json[this.name]=this.value;\r\n});\r\njson=JSON.stringify(json);\r\n// 显示结果:\r\nif (typeof(json) === \'string\') {\r\n    console.log(json);\r\n}\r\nelse {\r\n    console.log(\'json变量不是string!\');\r\n}\r\n```\r\n\r\n{\"name\":\"mjt1220\",\"email\":\"mjt1220@126.com\",\"password\":\"123\",\"gender\":\"m\",\"city\":\"BJ\"}","timestamp":1590329650947},{"name":"82-选择器.md","path":"13-语言学习project/11-JavaScript/0-jquery/82-选择器.md","content":"#### 选择器\r\n\r\n阅读: 1703900\r\n\r\n------\r\n\r\n选择器是jQuery的核心。一个选择器写出来类似`$(\'#dom-id\')`。\r\n\r\n为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码：\r\n\r\n```\r\n// 按ID查找：\r\nvar a = document.getElementById(\'dom-id\');\r\n\r\n// 按tag查找：\r\nvar divs = document.getElementsByTagName(\'div\');\r\n\r\n// 查找<p class=\"red\">：\r\nvar ps = document.getElementsByTagName(\'p\');\r\n// 过滤出class=\"red\":\r\n// TODO:\r\n\r\n// 查找<table class=\"green\">里面的所有<tr>：\r\nvar table = ...\r\nfor (var i=0; i<table.children; i++) {\r\n    // TODO: 过滤出<tr>\r\n}\r\n```\r\n\r\n这些代码实在太繁琐了，并且，在层级关系中，例如，查找``里面的所有，一层循环实际上是错的，因为``的标准写法是：\r\n\r\n```\r\n<table>\r\n    <tbody>\r\n        <tr>...</tr>\r\n        <tr>...</tr>\r\n    </tbody>\r\n</table>\r\n```\r\n\r\n很多时候，需要递归查找所有子节点。\r\n\r\njQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。\r\n\r\n### 按ID查找\r\n\r\n如果某个DOM节点有`id`属性，利用jQuery查找如下：\r\n\r\n```\r\n// 查找<div id=\"abc\">:\r\nvar div = $(\'#abc\');\r\n```\r\n\r\n*注意*，`#abc`以`#`开头。返回的对象是jQuery对象。\r\n\r\n什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。\r\n\r\n以上面的查找为例，如果`id`为`abc`的``存在，返回的jQuery对象如下：\r\n\r\n```\r\n[<div id=\"abc\">...</div>]\r\n```\r\n\r\n如果`id`为`abc`的``不存在，返回的jQuery对象如下：\r\n\r\n```\r\n[]\r\n```\r\n\r\n总之jQuery的选择器不会返回`undefined`或者`null`，这样的好处是你不必在下一行判断`if (div === undefined)`。\r\n\r\njQuery对象和DOM对象之间可以互相转化：\r\n\r\n```\r\nvar div = $(\'#abc\'); // jQuery对象\r\nvar divDom = div.get(0); // 假设存在div，获取第1个DOM元素\r\nvar another = $(divDom); // 重新把DOM包装为jQuery对象\r\n```\r\n\r\n通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用`$(aDomObject)`把它变成jQuery对象，这样就可以方便地使用jQuery的API了。\r\n\r\n### 按tag查找\r\n\r\n按tag查找只需要写上tag名称就可以了：\r\n\r\n```\r\nvar ps = $(\'p\'); // 返回所有<p>节点\r\nps.length; // 数一数页面有多少个<p>节点\r\n```\r\n\r\n### 按class查找\r\n\r\n按class查找注意在class名称前加一个`.`：\r\n\r\n```\r\nvar a = $(\'.red\'); // 所有节点包含`class=\"red\"`都将返回\r\n// 例如:\r\n// <div class=\"red\">...</div>\r\n// <p class=\"green red\">...</p>\r\n```\r\n\r\n通常很多节点有多个class，我们可以查找同时包含`red`和`green`的节点：\r\n\r\n```\r\nvar a = $(\'.red.green\'); // 注意没有空格！\r\n// 符合条件的节点：\r\n// <div class=\"red green\">...</div>\r\n// <div class=\"blue green red\">...</div>\r\n```\r\n\r\n### 按属性查找\r\n\r\n一个DOM节点除了`id`和`class`外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找：\r\n\r\n```\r\nvar email = $(\'[name=email]\'); // 找出<??? name=\"email\">\r\nvar passwordInput = $(\'[type=password]\'); // 找出<??? type=\"password\">\r\nvar a = $(\'[items=\"A B\"]\'); // 找出<??? items=\"A B\">\r\n```\r\n\r\n当属性的值包含空格等特殊字符时，需要用双引号括起来。\r\n\r\n按属性查找还可以使用前缀查找或者后缀查找：\r\n\r\n```\r\nvar icons = $(\'[name^=icon]\'); // 找出所有name属性值以icon开头的DOM\r\n// 例如: name=\"icon-1\", name=\"icon-2\"\r\nvar names = $(\'[name$=with]\'); // 找出所有name属性值以with结尾的DOM\r\n// 例如: name=\"startswith\", name=\"endswith\"\r\n```\r\n\r\n这个方法尤其适合通过class属性查找，且不受class包含多个名称的影响：\r\n\r\n```\r\nvar icons = $(\'[class^=\"icon-\"]\'); // 找出所有class包含至少一个以`icon-`开头的DOM\r\n// 例如: class=\"icon-clock\", class=\"abc icon-home\"\r\n```\r\n\r\n### 组合查找\r\n\r\n组合查找就是把上述简单选择器组合起来使用。如果我们查找`$(\'[name=email]\')`，很可能把表单外的``也找出来，但我们只希望查找``，就可以这么写：\r\n\r\n```\r\nvar emailInput = $(\'input[name=email]\'); // 不会找出<div name=\"email\">\r\n```\r\n\r\n同样的，根据tag和class来组合查找也很常见：\r\n\r\n```\r\nvar tr = $(\'tr.red\'); // 找出<tr class=\"red ...\">...</tr>\r\n```\r\n\r\n### 多项选择器\r\n\r\n多项选择器就是把多个选择器用`,`组合起来一块选：\r\n\r\n```\r\n$(\'p,div\'); // 把<p>和<div>都选出来\r\n$(\'p.red,p.green\'); // 把<p class=\"red\">和<p class=\"green\">都选出来\r\n```\r\n\r\n要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，``不会被上面的`$(\'p.red,p.green\')`选择两次。\r\n\r\n### 练习\r\n\r\n使用jQuery选择器分别选出指定元素：\r\n\r\n- 仅选择JavaScript\r\n- 仅选择Erlang\r\n- 选择JavaScript和Erlang\r\n- 选择所有编程语言\r\n- 选择名字input\r\n- 选择邮件和名字input\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-jquery\">\r\n    <p id=\"para-1\" class=\"color-red\">JavaScript</p>\r\n    <p id=\"para-2\" class=\"color-green\">Haskell</p>\r\n    <p class=\"color-red color-green\">Erlang</p>\r\n    <p name=\"name\" class=\"color-black\">Python</p>\r\n    <form class=\"test-form\" target=\"_blank\" action=\"#0\" onsubmit=\"return false;\">\r\n        <legend>注册新用户</legend>\r\n        <fieldset>\r\n            <p><label>名字: <input name=\"name\"></label></p>\r\n            <p><label>邮件: <input name=\"email\"></label></p>\r\n            <p><label>口令: <input name=\"password\" type=\"password\"></label></p>\r\n            <p><button type=\"submit\">注册</button></p>\r\n        </fieldset>\r\n    </form>\r\n</div>\r\n```\r\n\r\n运行查看结果：\r\n\r\n```JavaScript\r\n\'use strict\';\r\n\r\nvar selected = null;\r\n// 仅选择JavaScript\r\nselected = $(\'#para-1\');\r\n// 仅选择Erlang\r\nselected = $(\'.color-red.color-green\');\r\n// 选择JavaScript和Erlang\r\nselected = $(\'.color-red\');\r\n// 选择所有编程语言\r\nselected = $(\'[class^=\"color-\"]\');\r\n// 选择名字input\r\nselected = $(\'p input[name=name]\');\r\n// 选择邮件和名字input\r\nselected = $(\'p input[name=name], input[name=email]\');\r\n// 高亮结果:\r\nif (!(selected instanceof jQuery)) {\r\n    return console.log(\'不是有效的jQuery对象!\');\r\n}\r\n$(\'#test-jquery\').find(\'*\').css(\'background-color\', \'\');\r\nselected.css(\'background-color\', \'#ffd351\');\r\n```\r\n\r\nJavaScript\r\n\r\nHaskell\r\n\r\nErlang\r\n\r\nPython\r\n\r\n注册新用户\r\n\r\n名字: \r\n\r\n邮件: \r\n\r\n口令: \r\n\r\n注册\r\n\r\n\r\n\r\n","timestamp":1590329650947},{"name":"83-node.md","path":"13-语言学习project/11-JavaScript/1-nodejs/83-node.md","content":"#### Node.js\r\n\r\n阅读: 38620302\r\n\r\n------\r\n\r\n从本章开始，我们就正式开启JavaScript的后端开发之旅。\r\n\r\nNode.js是目前非常火热的技术，但是它的诞生经历却很奇特。\r\n\r\n众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。\r\n\r\n后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。（2001年推出的古老的IE 6到今天仍然有人在使用！）\r\n\r\n没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。\r\n\r\n先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了Firefox浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的Safari浏览器，不过仅限于Mac平台。\r\n\r\n随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了Chrome浏览器。\r\n\r\nChrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。\r\n\r\n现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。\r\n\r\n浏览器大战和Node有何关系？\r\n\r\n话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。\r\n\r\n因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。\r\n\r\n选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。\r\n\r\n于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。\r\n\r\n在Node上运行的JavaScript相比其他后端开发语言有何优势？\r\n\r\n最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。\r\n\r\n其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。\r\n\r\n> 我还听说过io.js，这又是什么鬼？\r\n\r\n因为Node.js是开源项目，虽然由社区推动，但幕后一直由Joyent公司资助。由于一群开发者对Joyent公司的策略不满，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。\r\n\r\n然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent公司表示要和解，于是，io.js项目又决定回归Node.js。\r\n\r\n具体做法是将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。\r\n\r\n本章教程的所有代码都在Node.js上调试通过。如果你要尝试io.js也是可以的，不过两者如果遇到一些区别请自行查看io.js的文档。\r\n\r\n#### 第一个Node程序\r\n\r\n阅读: 9125805\r\n\r\n------\r\n\r\n在前面的所有章节中，我们编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。\r\n\r\n从本章开始，我们编写的JavaScript代码将*不能*在浏览器环境中执行了，而是在Node环境中执行，因此，JavaScript代码将直接在你的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写JavaScript代码，并且把它保存到本地硬盘的某个目录，才能够执行。\r\n\r\n那么问题来了：文本编辑器到底哪家强？\r\n\r\n首先，请注意，绝对不能用Word和写字板。Word和写字板保存的不是纯文本文件。如果我们要用记事本来编写JavaScript代码，要务必注意，记事本以UTF-8格式保存文件时，会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果经常会导致程序运行出现莫名其妙的错误。\r\n\r\n所以，用记事本写代码时请注意，保存文件时使用ANSI编码，并且暂时不要输入中文。\r\n\r\n如果你的电脑上已经安装了[Sublime Text](http://www.sublimetext.com/)，或者[Notepad++](http://notepad-plus-plus.org/)，也可以用来编写JavaScript代码，注意用UTF-8格式保存。\r\n\r\n输入以下代码：\r\n\r\n```\r\n\'use strict\';\r\n\r\nconsole.log(\'Hello, world.\');\r\n```\r\n\r\n第一行总是写上`\'use strict\';`是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。\r\n\r\n然后，选择一个目录，例如`C:\\Workspace`，把文件保存为`hello.js`，就可以打开命令行窗口，把当前目录切换到`hello.js`所在目录，然后输入以下命令运行这个程序了：\r\n\r\n```\r\nC:\\Workspace>node hello.js\r\nHello, world.\r\n```\r\n\r\n也可以保存为别的名字，比如`first.js`，但是必须要以`.js`结尾。此外，文件名只能是英文字母、数字和下划线的组合。\r\n\r\n如果当前目录下没有`hello.js`这个文件，运行`node hello.js`就会报错：\r\n\r\n```\r\nC:\\Workspace>node hello.js\r\nmodule.js:338\r\n    throw err;\r\n          ^\r\nError: Cannot find module \'C:\\Workspace\\hello.js\'\r\n    at Function.Module._resolveFilename\r\n    at Function.Module._load\r\n    at Function.Module.runMain\r\n    at startup\r\n    at node.js\r\n```\r\n\r\n报错的意思就是，没有找到`hello.js`这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。\r\n\r\n### 命令行模式和Node交互模式\r\n\r\n请注意区分命令行模式和Node交互模式。\r\n\r\n看到类似`C:\\>`是在Windows提供的命令行模式：\r\n\r\n![run-node-hello](D:\\Typora_pic\\l-1586076769349.png)\r\n\r\n在命令行模式下，可以执行`node`进入Node交互式环境，也可以执行`node hello.js`运行一个`.js`文件。\r\n\r\n看到`>`是在Node交互式环境下：\r\n\r\n![node-interactive-env](D:\\Typora_pic\\l-1586076769297.png)\r\n\r\n在Node交互式环境下，我们可以输入JavaScript代码并立刻执行。\r\n\r\n此外，在命令行模式运行`.js`文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。\r\n\r\n例如，在Node交互式环境下，输入：\r\n\r\n```\r\n> 100 + 200 + 300;\r\n600\r\n```\r\n\r\n直接可以看到结果`600`。\r\n\r\n但是，写一个`calc.js`的文件，内容如下：\r\n\r\n```\r\n100 + 200 + 300;\r\n```\r\n\r\n然后在命令行模式下执行：\r\n\r\n```\r\nC:\\Workspace>node calc.js\r\n```\r\n\r\n发现什么输出都没有。\r\n\r\n这是正常的。想要输出结果，必须自己用`console.log()`打印出来。把`calc.js`改造一下：\r\n\r\n```\r\nconsole.log(100 + 200 + 300);\r\n```\r\n\r\n再执行，就可以看到结果：\r\n\r\n```\r\nC:\\Workspace>node calc.js\r\n600\r\n```\r\n\r\n### 使用严格模式\r\n\r\n如果在JavaScript文件开头写上`\'use strict\';`，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上`\'use strict\';`很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：\r\n\r\n```\r\nnode --use_strict calc.js\r\n```\r\n\r\n后续代码，如无特殊说明，我们都会直接给Node传递`--use_strict`参数来开启严格模式。\r\n\r\n### 小结\r\n\r\n用文本编辑器写JavaScript程序，然后保存为后缀为`.js`的文件，就可以用node直接运行这个程序了。\r\n\r\nNode的交互模式和直接运行`.js`文件有什么区别呢？\r\n\r\n直接输入`node`进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。\r\n\r\n直接运行`node hello.js`文件相当于启动了Node解释器，然后一次性把`hello.js`文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。\r\n\r\n在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27\'的超大显示器！\r\n\r\n### 参考源码\r\n\r\n[hello.js和calc.js](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/first)\r\n\r\n#### 搭建Node开发环境\r\n\r\n阅读: 7450636\r\n\r\n------\r\n\r\n使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。\r\n\r\n所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。\r\n\r\nJava的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？\r\n\r\n考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。\r\n\r\n综合考察后，我们隆重向大家推荐Node.js集成开发环境：\r\n\r\n# Visual Studio Code\r\n\r\nVisual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。\r\n\r\n### 安装Visual Studio Code\r\n\r\n可以从Visual Studio Code的[官方网站](http://code.visualstudio.com/)下载并安装最新的版本。\r\n\r\n安装过程中，请务必钩上以下选项：\r\n\r\n![install-vsc](D:\\Typora_pic\\l-1586076913891.png)\r\n\r\n 将“通过Code打开”操作添加到Windows资源管理器目录上下文菜单\r\n\r\n这将大大提升将来的操作快捷度。\r\n\r\n在Mac系统上，Finder选中一个目录，右键菜单并没有“通过Code打开”这个操作。不过我们可以通过Automator自己添加这个操作。\r\n\r\n先运行Automator，选择“服务”：\r\n\r\n![automator-service](D:\\Typora_pic\\l-1586076913898.png)\r\n\r\n然后，执行以下操作：\r\n\r\n![automator](D:\\Typora_pic\\l.jfif)\r\n\r\n1. 在右侧面板选择“服务”收到选定的“文件夹”，位于“Finder.app“，该选项是为了从Finder中接收一个文件夹；\r\n2. 在左侧面板选择”实用工具“，然后找到”运行Shell脚本“，把它拽到右侧面板里；\r\n3. 在右侧”运行Shell脚本“的面板里，选择Shell”/bin/bash“，传递输入“作为自变量”，然后修改Shell脚本如下：\r\n\r\n```\r\nfor f in \"$@\"\r\ndo\r\n    open -a \"Visual Studio Code\" \"$f\"\r\ndone\r\n```\r\n\r\n保存为“Open With VSCode”后，打开Finder，选中一个文件夹，点击右键，“服务”，就可以看到“Open With VSCode”菜单：\r\n\r\n![open-with-vscode](D:\\Typora_pic\\l-1586076913929.png)\r\n\r\n### 运行和调试JavaScript\r\n\r\n在VS Code中，我们可以非常方便地运行JavaScript文件。\r\n\r\nVS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个`.vscode`的配置目录，里面存放里VS Code需要的配置文件。\r\n\r\n假设我们在`C:\\Work\\`目录下创建了一个`hello`目录作为工程目录，并编写了一个`hello.js`文件，则该工程目录的结构如下：\r\n\r\n```\r\nhello/ <-- workspace dir\r\n|\r\n+- hello.js <-- JavaScript file\r\n|\r\n+- .vscode/  <-- VS Code config\r\n   |\r\n   +- launch.json <-- VS Code config file for JavaScript\r\n```\r\n\r\n可以用VS Code快速创建`launch.json`，然后修改如下：\r\n\r\n```\r\n{\r\n    \"version\": \"0.2.0\",\r\n    \"configurations\": [\r\n        {\r\n            \"name\": \"Run hello.js\",\r\n            \"type\": \"node\",\r\n            \"request\": \"launch\",\r\n            \"program\": \"${workspaceRoot}/hello.js\",\r\n            \"stopOnEntry\": false,\r\n            \"args\": [],\r\n            \"cwd\": \"${workspaceRoot}\",\r\n            \"preLaunchTask\": null,\r\n            \"runtimeExecutable\": null,\r\n            \"runtimeArgs\": [\r\n                \"--nolazy\"\r\n            ],\r\n            \"env\": {\r\n                \"NODE_ENV\": \"development\"\r\n            },\r\n            \"externalConsole\": false,\r\n            \"sourceMaps\": false,\r\n            \"outDir\": null\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n有了配置文件，即可使用VS Code调试JavaScript。\r\n\r\n视频演示：\r\n\r\n\r\n\r\n### 参考源码\r\n\r\n[hello.js](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/hello)","timestamp":1590329650947},{"name":"84-Untitled.md","path":"13-语言学习project/11-JavaScript/1-nodejs/84-Untitled.md","content":"","timestamp":1590329650947},{"name":"85-基本模块.md","path":"13-语言学习project/11-JavaScript/1-nodejs/85-基本模块.md","content":"#### 基本模块\r\n\r\n阅读: 2806584\r\n\r\n------\r\n\r\n因为Node.js是运行在服务区端的JavaScript环境，服务器程序和浏览器程序相比，最大的特点是没有浏览器的安全限制了，而且，服务器程序必须能接收网络请求，读写文件，处理二进制内容，所以，Node.js内置的常用模块就是为了实现基本的服务器功能。这些模块在浏览器环境中是无法被执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。\r\n\r\n### global\r\n\r\n在前面的JavaScript课程中，我们已经知道，JavaScript有且仅有一个全局对象，在浏览器中，叫`window`对象。而在Node.js环境中，也有唯一的全局对象，但不叫`window`，而叫`global`，这个对象的属性和方法也和浏览器环境的`window`不同。进入Node.js交互环境，可以直接输入：\r\n\r\n```\r\n> global.console\r\nConsole {\r\n  log: [Function: bound ],\r\n  info: [Function: bound ],\r\n  warn: [Function: bound ],\r\n  error: [Function: bound ],\r\n  dir: [Function: bound ],\r\n  time: [Function: bound ],\r\n  timeEnd: [Function: bound ],\r\n  trace: [Function: bound trace],\r\n  assert: [Function: bound ],\r\n  Console: [Function: Console] }\r\n```\r\n\r\n### process\r\n\r\n`process`也是Node.js提供的一个对象，它代表当前Node.js进程。通过`process`对象可以拿到许多有用信息：\r\n\r\n```\r\n> process === global.process;\r\ntrue\r\n> process.version;\r\n\'v5.2.0\'\r\n> process.platform;\r\n\'darwin\'\r\n> process.arch;\r\n\'x64\'\r\n> process.cwd(); //返回当前工作目录\r\n\'/Users/michael\'\r\n> process.chdir(\'/private/tmp\'); // 切换当前工作目录\r\nundefined\r\n> process.cwd();\r\n\'/private/tmp\'\r\n```\r\n\r\nJavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。\r\n\r\n如果我们想要在下一次事件响应中执行代码，可以调用`process.nextTick()`：\r\n\r\n```\r\n// test.js\r\n\r\n// process.nextTick()将在下一轮事件循环中调用:\r\nprocess.nextTick(function () {\r\n    console.log(\'nextTick callback!\');\r\n});\r\nconsole.log(\'nextTick was set!\');\r\n```\r\n\r\n用Node执行上面的代码`node test.js`，你会看到，打印输出是：\r\n\r\n```\r\nnextTick was set!\r\nnextTick callback!\r\n```\r\n\r\n这说明传入`process.nextTick()`的函数不是立刻执行，而是要等到下一次事件循环。\r\n\r\nNode.js进程本身的事件就由`process`对象来处理。如果我们响应`exit`事件，就可以在程序即将退出时执行某个回调函数：\r\n\r\n```\r\n// 程序即将退出时的回调函数:\r\nprocess.on(\'exit\', function (code) {\r\n    console.log(\'about to exit with code: \' + code);\r\n});\r\n```\r\n\r\n### 判断JavaScript执行环境\r\n\r\n有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：\r\n\r\n```\r\nif (typeof(window) === \'undefined\') {\r\n    console.log(\'node.js\');\r\n} else {\r\n    console.log(\'browser\');\r\n}\r\n```\r\n\r\n后面，我们将介绍Node.js的常用内置模块。\r\n\r\n### 参考源码\r\n\r\n[gl.js](https://github.com/michaelliao/learn-javascript/blob/master/samples/node/global/gl.js)\r\n\r\n#### fs\r\n\r\n阅读: 3045850\r\n\r\n------\r\n\r\nNode.js内置的`fs`模块就是文件系统模块，负责读写文件。\r\n\r\n和所有其它JavaScript模块不同的是，`fs`模块同时提供了异步和同步的方法。\r\n\r\n回顾一下什么是异步方法。因为JavaScript的单线程模型，执行IO操作时，JavaScript代码无需等待，而是传入回调函数后，继续执行后续JavaScript代码。比如jQuery提供的`getJSON()`操作：\r\n\r\n```\r\n$.getJSON(\'http://example.com/ajax\', function (data) {\r\n    console.log(\'IO结果返回后执行...\');\r\n});\r\nconsole.log(\'不等待IO结果直接执行后续代码...\');\r\n```\r\n\r\n而同步的IO操作则需要等待函数返回：\r\n\r\n```\r\n// 根据网络耗时，函数将执行几十毫秒~几秒不等:\r\nvar data = getJSONSync(\'http://example.com/ajax\');\r\n```\r\n\r\n同步操作的好处是代码简单，缺点是程序将等待IO操作，在等待时间内，无法响应其它任何事件。而异步读取不用等待IO操作，但代码较麻烦。\r\n\r\n### 异步读文件\r\n\r\n按照JavaScript的标准，异步读取一个文本文件的代码如下：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nfs.readFile(\'sample.txt\', \'utf-8\', function (err, data) {\r\n    if (err) {\r\n        console.log(err);\r\n    } else {\r\n        console.log(data);\r\n    }\r\n});\r\n```\r\n\r\n请注意，`sample.txt`文件必须在当前目录下，且文件编码为`utf-8`。\r\n\r\n异步读取时，传入的回调函数接收两个参数，当正常读取时，`err`参数为`null`，`data`参数为读取到的String。当读取发生错误时，`err`参数代表一个错误对象，`data`为`undefined`。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。\r\n\r\n由于`err`是否为`null`就是判断是否出错的标志，所以通常的判断逻辑总是：\r\n\r\n```\r\nif (err) {\r\n    // 出错了\r\n} else {\r\n    // 正常\r\n}\r\n```\r\n\r\n如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？\r\n\r\n下面的例子演示了如何读取一个图片文件：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nfs.readFile(\'sample.png\', function (err, data) {\r\n    if (err) {\r\n        console.log(err);\r\n    } else {\r\n        console.log(data);\r\n        console.log(data.length + \' bytes\');\r\n    }\r\n});\r\n```\r\n\r\n当读取二进制文件时，不传入文件编码时，回调函数的`data`参数将返回一个`Buffer`对象。在Node.js中，`Buffer`对象就是一个包含零个或任意个字节的数组（注意和Array不同）。\r\n\r\n`Buffer`对象可以和String作转换，例如，把一个`Buffer`对象转换成String：\r\n\r\n```\r\n// Buffer -> String\r\nvar text = data.toString(\'utf-8\');\r\nconsole.log(text);\r\n```\r\n\r\n或者把一个String转换成`Buffer`：\r\n\r\n```\r\n// String -> Buffer\r\nvar buf = Buffer.from(text, \'utf-8\');\r\nconsole.log(buf);\r\n```\r\n\r\n### 同步读文件\r\n\r\n除了标准的异步读取模式外，`fs`也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果。\r\n\r\n用`fs`模块同步读取一个文本文件的代码如下：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nvar data = fs.readFileSync(\'sample.txt\', \'utf-8\');\r\nconsole.log(data);\r\n```\r\n\r\n可见，原异步调用的回调函数的`data`被函数直接返回，函数名需要改为`readFileSync`，其它参数不变。\r\n\r\n如果同步读取文件发生错误，则需要用`try...catch`捕获该错误：\r\n\r\n```\r\ntry {\r\n    var data = fs.readFileSync(\'sample.txt\', \'utf-8\');\r\n    console.log(data);\r\n} catch (err) {\r\n    // 出错了\r\n}\r\n```\r\n\r\n### 写文件\r\n\r\n将数据写入文件是通过`fs.writeFile()`实现的：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nvar data = \'Hello, Node.js\';\r\nfs.writeFile(\'output.txt\', data, function (err) {\r\n    if (err) {\r\n        console.log(err);\r\n    } else {\r\n        console.log(\'ok.\');\r\n    }\r\n});\r\n```\r\n\r\n`writeFile()`的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是`Buffer`，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个`err`参数。\r\n\r\n和`readFile()`类似，`writeFile()`也有一个同步方法，叫`writeFileSync()`：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nvar data = \'Hello, Node.js\';\r\nfs.writeFileSync(\'output.txt\', data);\r\n```\r\n\r\n### stat\r\n\r\n如果我们要获取文件大小，创建时间等信息，可以使用`fs.stat()`，它返回一个`Stat`对象，能告诉我们文件或目录的详细信息：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nfs.stat(\'sample.txt\', function (err, stat) {\r\n    if (err) {\r\n        console.log(err);\r\n    } else {\r\n        // 是否是文件:\r\n        console.log(\'isFile: \' + stat.isFile());\r\n        // 是否是目录:\r\n        console.log(\'isDirectory: \' + stat.isDirectory());\r\n        if (stat.isFile()) {\r\n            // 文件大小:\r\n            console.log(\'size: \' + stat.size);\r\n            // 创建时间, Date对象:\r\n            console.log(\'birth time: \' + stat.birthtime);\r\n            // 修改时间, Date对象:\r\n            console.log(\'modified time: \' + stat.mtime);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n运行结果如下：\r\n\r\n```\r\nisFile: true\r\nisDirectory: false\r\nsize: 181\r\nbirth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)\r\nmodified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)\r\n```\r\n\r\n`stat()`也有一个对应的同步函数`statSync()`，请试着改写上述异步代码为同步代码。\r\n\r\n### 异步还是同步\r\n\r\n在`fs`模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？\r\n\r\n由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，*必须使用异步代码*，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。\r\n\r\n服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。\r\n\r\n### 参考源码\r\n\r\n[fs](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/fs)\r\n\r\n#### stream\r\n\r\n阅读: 1343759\r\n\r\n------\r\n\r\n`stream`是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。\r\n\r\n什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。\r\n\r\n如果应用程序把字符一个一个输出到显示器上，这也可以看成是一个流，这个流也有名字：标准输出流（stdout）。流的特点是数据是有序的，而且必须依次读取，或者依次写入，不能像Array那样随机定位。\r\n\r\n![nodejs-stream](D:\\Typora_pic\\l-1586078358821.png)\r\n\r\n有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。有些流用来写入数据，比如向文件写入数据时，只需要把数据不断地往文件流中写进去就可以了。\r\n\r\n在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：`data`事件表示流的数据已经可以读取了，`end`事件表示这个流已经到末尾了，没有数据可以读取了，`error`事件表示出错了。\r\n\r\n下面是一个从文件流读取文本内容的示例：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\n// 打开一个流:\r\nvar rs = fs.createReadStream(\'sample.txt\', \'utf-8\');\r\n\r\nrs.on(\'data\', function (chunk) {\r\n    console.log(\'DATA:\')\r\n    console.log(chunk);\r\n});\r\n\r\nrs.on(\'end\', function () {\r\n    console.log(\'END\');\r\n});\r\n\r\nrs.on(\'error\', function (err) {\r\n    console.log(\'ERROR: \' + err);\r\n});\r\n```\r\n\r\n要注意，`data`事件可能会有多次，每次传递的`chunk`是流的一部分数据。\r\n\r\n要以流的形式写入文件，只需要不断调用`write()`方法，最后以`end()`结束：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nvar ws1 = fs.createWriteStream(\'output1.txt\', \'utf-8\');\r\nws1.write(\'使用Stream写入文本数据...\\n\');\r\nws1.write(\'END.\');\r\nws1.end();\r\n\r\nvar ws2 = fs.createWriteStream(\'output2.txt\');\r\nws2.write(new Buffer(\'使用Stream写入二进制数据...\\n\', \'utf-8\'));\r\nws2.write(new Buffer(\'END.\', \'utf-8\'));\r\nws2.end();\r\n```\r\n\r\n所有可以读取数据的流都继承自`stream.Readable`，所有可以写入的流都继承自`stream.Writable`。\r\n\r\n### pipe\r\n\r\n就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个`Readable`流和一个`Writable`流串起来后，所有的数据自动从`Readable`流进入`Writable`流，这种操作叫`pipe`。\r\n\r\n在Node.js中，`Readable`流有一个`pipe()`方法，就是用来干这件事的。\r\n\r\n让我们用`pipe()`把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar fs = require(\'fs\');\r\n\r\nvar rs = fs.createReadStream(\'sample.txt\');\r\nvar ws = fs.createWriteStream(\'copied.txt\');\r\n\r\nrs.pipe(ws);\r\n```\r\n\r\n默认情况下，当`Readable`流的数据读取完毕，`end`事件触发后，将自动关闭`Writable`流。如果我们不希望自动关闭`Writable`流，需要传入参数：\r\n\r\n```\r\nreadable.pipe(writable, { end: false });\r\n```\r\n\r\n### 参考源码\r\n\r\n[stream](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/stream)\r\n\r\n#### http\r\n\r\n阅读: 1515544\r\n\r\n------\r\n\r\nNode.js开发的目的就是为了用JavaScript编写Web服务器程序。因为JavaScript实际上已经统治了浏览器端的脚本，其优势就是有世界上数量最多的前端开发人员。如果已经掌握了JavaScript前端开发，再学习一下如何将JavaScript应用在后端开发，就是名副其实的*全栈*了。\r\n\r\n### HTTP协议\r\n\r\n要理解Web服务器程序的工作原理，首先，我们要对HTTP协议有基本的了解。如果你对HTTP协议不太熟悉，先看一看[HTTP协议简介](http://www.liaoxuefeng.com/wiki/1016959663602400/1017804782304672)。\r\n\r\n### HTTP服务器\r\n\r\n要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的`http`模块完成了。应用程序并不直接和HTTP协议打交道，而是操作`http`模块提供的`request`和`response`对象。\r\n\r\n`request`对象封装了HTTP请求，我们调用`request`对象的属性和方法就可以拿到所有HTTP请求的信息；\r\n\r\n`response`对象封装了HTTP响应，我们操作`response`对象的方法，就可以把HTTP响应返回给浏览器。\r\n\r\n用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序`hello.js`，它对于所有请求，都返回`Hello world!`：\r\n\r\n```\r\n\'use strict\';\r\n\r\n// 导入http模块:\r\nvar http = require(\'http\');\r\n\r\n// 创建http server，并传入回调函数:\r\nvar server = http.createServer(function (request, response) {\r\n    // 回调函数接收request和response对象,\r\n    // 获得HTTP请求的method和url:\r\n    console.log(request.method + \': \' + request.url);\r\n    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:\r\n    response.writeHead(200, {\'Content-Type\': \'text/html\'});\r\n    // 将HTTP响应的HTML内容写入response:\r\n    response.end(\'<h1>Hello world!</h1>\');\r\n});\r\n\r\n// 让服务器监听8080端口:\r\nserver.listen(8080);\r\n\r\nconsole.log(\'Server is running at http://127.0.0.1:8080/\');\r\n```\r\n\r\n在命令提示符下运行该程序，可以看到以下输出：\r\n\r\n```\r\n$ node hello.js \r\nServer is running at http://127.0.0.1:8080/\r\n```\r\n\r\n不要关闭命令提示符，直接打开浏览器输入`http://localhost:8080`，即可看到服务器响应的内容：\r\n\r\n![http-hello-sample](D:\\Typora_pic\\l-1586078533849.jfif)\r\n\r\n同时，在命令提示符窗口，可以看到程序打印的请求信息：\r\n\r\n```\r\nGET: /\r\nGET: /favicon.ico\r\n```\r\n\r\n这就是我们编写的第一个HTTP服务器程序！\r\n\r\n### 文件服务器\r\n\r\n让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析`request.url`中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。\r\n\r\n解析URL需要用到Node.js提供的`url`模块，它使用起来非常简单，通过`parse()`将一个字符串解析为一个`Url`对象：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar url = require(\'url\');\r\n\r\nconsole.log(url.parse(\'http://user:pass@host.com:8080/path/to/file?query=string#hash\'));\r\n```\r\n\r\n结果如下：\r\n\r\n```\r\nUrl {\r\n  protocol: \'http:\',\r\n  slashes: true,\r\n  auth: \'user:pass\',\r\n  host: \'host.com:8080\',\r\n  port: \'8080\',\r\n  hostname: \'host.com\',\r\n  hash: \'#hash\',\r\n  search: \'?query=string\',\r\n  query: \'query=string\',\r\n  pathname: \'/path/to/file\',\r\n  path: \'/path/to/file?query=string\',\r\n  href: \'http://user:pass@host.com:8080/path/to/file?query=string#hash\' }\r\n```\r\n\r\n处理本地文件目录需要使用Node.js提供的`path`模块，它可以方便地构造目录：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar path = require(\'path\');\r\n\r\n// 解析当前目录:\r\nvar workDir = path.resolve(\'.\'); // \'/Users/michael\'\r\n\r\n// 组合完整的文件路径:当前目录+\'pub\'+\'index.html\':\r\nvar filePath = path.join(workDir, \'pub\', \'index.html\');\r\n// \'/Users/michael/pub/index.html\'\r\n```\r\n\r\n使用`path`模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于`C:\\Users\\michael\\static\\index.html`，这样，我们就不关心怎么拼接路径了。\r\n\r\n最后，我们实现一个文件服务器`file_server.js`：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar\r\n    fs = require(\'fs\'),\r\n    url = require(\'url\'),\r\n    path = require(\'path\'),\r\n    http = require(\'http\');\r\n\r\n// 从命令行参数获取root目录，默认是当前目录:\r\nvar root = path.resolve(process.argv[2] || \'.\');\r\n\r\nconsole.log(\'Static root dir: \' + root);\r\n\r\n// 创建服务器:\r\nvar server = http.createServer(function (request, response) {\r\n    // 获得URL的path，类似 \'/css/bootstrap.css\':\r\n    var pathname = url.parse(request.url).pathname;\r\n    // 获得对应的本地文件路径，类似 \'/srv/www/css/bootstrap.css\':\r\n    var filepath = path.join(root, pathname);\r\n    // 获取文件状态:\r\n    fs.stat(filepath, function (err, stats) {\r\n        if (!err && stats.isFile()) {\r\n            // 没有出错并且文件存在:\r\n            console.log(\'200 \' + request.url);\r\n            // 发送200响应:\r\n            response.writeHead(200);\r\n            // 将文件流导向response:\r\n            fs.createReadStream(filepath).pipe(response);\r\n        } else {\r\n            // 出错了或者文件不存在:\r\n            console.log(\'404 \' + request.url);\r\n            // 发送404响应:\r\n            response.writeHead(404);\r\n            response.end(\'404 Not Found\');\r\n        }\r\n    });\r\n});\r\n\r\nserver.listen(8080);\r\n\r\nconsole.log(\'Server is running at http://127.0.0.1:8080/\');\r\n```\r\n\r\n没有必要手动读取文件内容。由于`response`对象本身是一个`Writable Stream`，直接用`pipe()`方法就实现了自动读取文件内容并输出到HTTP响应。\r\n\r\n在命令行运行`node file_server.js /path/to/dir`，把`/path/to/dir`改成你本地的一个有效的目录，然后在浏览器中输入`http://localhost:8080/index.html`：\r\n\r\n![http-index-page](D:\\Typora_pic\\l-1586078533851.png)\r\n\r\n只要当前目录下存在文件`index.html`，服务器就可以把文件内容发送给浏览器。观察控制台输出：\r\n\r\n```\r\n200 /index.html\r\n200 /css/uikit.min.css\r\n200 /js/jquery.min.js\r\n200 /fonts/fontawesome-webfont.woff2\r\n```\r\n\r\n第一个请求是浏览器请求`index.html`页面，后续请求是浏览器解析HTML后发送的其它资源请求。\r\n\r\n### 练习\r\n\r\n在浏览器输入`http://localhost:8080/`时，会返回404，原因是程序识别出HTTP请求的不是文件，而是目录。请修改`file_server.js`，如果遇到请求的路径是目录，则自动在目录下依次搜索`index.html`、`default.html`，如果找到了，就返回HTML文件的内容。\r\n\r\n### 参考源码\r\n\r\n[http服务器代码](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/http)（含静态网站）\r\n\r\n#### crypto\r\n\r\n阅读: 3593291\r\n\r\n------\r\n\r\ncrypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。\r\n\r\n### MD5和SHA1\r\n\r\nMD5是一种常用的哈希算法，用于给任意数据一个“签名”。这个签名通常用一个十六进制的字符串表示：\r\n\r\n```\r\nconst crypto = require(\'crypto\');\r\n\r\nconst hash = crypto.createHash(\'md5\');\r\n\r\n// 可任意多次调用update():\r\nhash.update(\'Hello, world!\');\r\nhash.update(\'Hello, nodejs!\');\r\n\r\nconsole.log(hash.digest(\'hex\')); // 7e1977739c748beac0c0fd14fd26a544\r\n```\r\n\r\n`update()`方法默认字符串编码为`UTF-8`，也可以传入Buffer。\r\n\r\n如果要计算SHA1，只需要把`\'md5\'`改成`\'sha1\'`，就可以得到SHA1的结果`1f32b9c9932c02227819a4151feed43e131aca40`。\r\n\r\n还可以使用更安全的`sha256`和`sha512`。\r\n\r\n### Hmac\r\n\r\nHmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法。不同的是，Hmac还需要一个密钥：\r\n\r\n```\r\nconst crypto = require(\'crypto\');\r\n\r\nconst hmac = crypto.createHmac(\'sha256\', \'secret-key\');\r\n\r\nhmac.update(\'Hello, world!\');\r\nhmac.update(\'Hello, nodejs!\');\r\n\r\nconsole.log(hmac.digest(\'hex\')); // 80f7e22570...\r\n```\r\n\r\n只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此，可以把Hmac理解为用随机数“增强”的哈希算法。\r\n\r\n### AES\r\n\r\nAES是一种常用的对称加密算法，加解密都用同一个密钥。crypto模块提供了AES支持，但是需要自己封装好函数，便于使用：\r\n\r\n```\r\nconst crypto = require(\'crypto\');\r\n\r\nfunction aesEncrypt(data, key) {\r\n    const cipher = crypto.createCipher(\'aes192\', key);\r\n    var crypted = cipher.update(data, \'utf8\', \'hex\');\r\n    crypted += cipher.final(\'hex\');\r\n    return crypted;\r\n}\r\n\r\nfunction aesDecrypt(encrypted, key) {\r\n    const decipher = crypto.createDecipher(\'aes192\', key);\r\n    var decrypted = decipher.update(encrypted, \'hex\', \'utf8\');\r\n    decrypted += decipher.final(\'utf8\');\r\n    return decrypted;\r\n}\r\n\r\nvar data = \'Hello, this is a secret message!\';\r\nvar key = \'Password!\';\r\nvar encrypted = aesEncrypt(data, key);\r\nvar decrypted = aesDecrypt(encrypted, key);\r\n\r\nconsole.log(\'Plain text: \' + data);\r\nconsole.log(\'Encrypted text: \' + encrypted);\r\nconsole.log(\'Decrypted text: \' + decrypted);\r\n```\r\n\r\n运行结果如下：\r\n\r\n```\r\nPlain text: Hello, this is a secret message!\r\nEncrypted text: 8a944d97bdabc157a5b7a40cb180e7...\r\nDecrypted text: Hello, this is a secret message!\r\n```\r\n\r\n可以看出，加密后的字符串通过解密又得到了原始内容。\r\n\r\n注意到AES有很多不同的算法，如`aes192`，`aes-128-ecb`，`aes-256-cbc`等，AES除了密钥外还可以指定IV（Initial Vector），不同的系统只要IV不同，用相同的密钥加密相同的数据得到的加密结果也是不同的。加密结果通常有两种表示方法：hex和base64，这些功能Nodejs全部都支持，但是在应用中要注意，如果加解密双方一方用Nodejs，另一方用Java、PHP等其它语言，需要仔细测试。如果无法正确解密，要确认双方是否遵循同样的AES算法，字符串密钥和IV是否相同，加密后的数据是否统一为hex或base64格式。\r\n\r\n### Diffie-Hellman\r\n\r\nDH算法是一种密钥交换协议，它可以让双方在不泄漏密钥的情况下协商出一个密钥来。DH算法基于数学原理，比如小明和小红想要协商一个密钥，可以这么做：\r\n\r\n1. 小明先选一个素数和一个底数，例如，素数`p=23`，底数`g=5`（底数可以任选），再选择一个秘密整数`a=6`，计算`A=g^a mod p=8`，然后大声告诉小红：`p=23，g=5，A=8`；\r\n2. 小红收到小明发来的`p`，`g`，`A`后，也选一个秘密整数`b=15`，然后计算`B=g^b mod p=19`，并大声告诉小明：`B=19`；\r\n3. 小明自己计算出`s=B^a mod p=2`，小红也自己计算出`s=A^b mod p=2`，因此，最终协商的密钥`s`为`2`。\r\n\r\n在这个过程中，密钥`2`并不是小明告诉小红的，也不是小红告诉小明的，而是双方协商计算出来的。第三方只能知道`p=23`，`g=5`，`A=8`，`B=19`，由于不知道双方选的秘密整数`a=6`和`b=15`，因此无法计算出密钥`2`。\r\n\r\n用crypto模块实现DH算法如下：\r\n\r\n```\r\nconst crypto = require(\'crypto\');\r\n\r\n// xiaoming\'s keys:\r\nvar ming = crypto.createDiffieHellman(512);\r\nvar ming_keys = ming.generateKeys();\r\n\r\nvar prime = ming.getPrime();\r\nvar generator = ming.getGenerator();\r\n\r\nconsole.log(\'Prime: \' + prime.toString(\'hex\'));\r\nconsole.log(\'Generator: \' + generator.toString(\'hex\'));\r\n\r\n// xiaohong\'s keys:\r\nvar hong = crypto.createDiffieHellman(prime, generator);\r\nvar hong_keys = hong.generateKeys();\r\n\r\n// exchange and generate secret:\r\nvar ming_secret = ming.computeSecret(hong_keys);\r\nvar hong_secret = hong.computeSecret(ming_keys);\r\n\r\n// print secret:\r\nconsole.log(\'Secret of Xiao Ming: \' + ming_secret.toString(\'hex\'));\r\nconsole.log(\'Secret of Xiao Hong: \' + hong_secret.toString(\'hex\'));\r\n```\r\n\r\n运行后，可以得到如下输出：\r\n\r\n```\r\n$ node dh.js \r\nPrime: a8224c...deead3\r\nGenerator: 02\r\nSecret of Xiao Ming: 695308...d519be\r\nSecret of Xiao Hong: 695308...d519be\r\n```\r\n\r\n注意每次输出都不一样，因为素数的选择是随机的。\r\n\r\n### RSA\r\n\r\nRSA算法是一种非对称加密算法，即由一个私钥和一个公钥构成的密钥对，通过私钥加密，公钥解密，或者通过公钥加密，私钥解密。其中，公钥可以公开，私钥必须保密。\r\n\r\nRSA算法是1977年由Ron Rivest、Adi Shamir和Leonard Adleman共同提出的，所以以他们三人的姓氏的头字母命名。\r\n\r\n当小明给小红发送信息时，可以用小明自己的私钥加密，小红用小明的公钥解密，也可以用小红的公钥加密，小红用她自己的私钥解密，这就是非对称加密。相比对称加密，非对称加密只需要每个人各自持有自己的私钥，同时公开自己的公钥，不需要像AES那样由两个人共享同一个密钥。\r\n\r\n在使用Node进行RSA加密前，我们先要准备好私钥和公钥。\r\n\r\n首先，在命令行执行以下命令以生成一个RSA密钥对：\r\n\r\n```\r\nopenssl genrsa -aes256 -out rsa-key.pem 2048\r\n```\r\n\r\n根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的`rsa-key.pem`文件。\r\n\r\n第二步，通过上面的`rsa-key.pem`加密文件，我们可以导出原始的私钥，命令如下：\r\n\r\n```\r\nopenssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem\r\n```\r\n\r\n输入第一步的密码，我们获得了解密后的私钥。\r\n\r\n类似的，我们用下面的命令导出原始的公钥：\r\n\r\n```\r\nopenssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem\r\n```\r\n\r\n这样，我们就准备好了原始私钥文件`rsa-prv.pem`和原始公钥文件`rsa-pub.pem`，编码格式均为PEM。\r\n\r\n下面，使用`crypto`模块提供的方法，即可实现非对称加解密。\r\n\r\n首先，我们用私钥加密，公钥解密：\r\n\r\n```\r\nconst\r\n    fs = require(\'fs\'),\r\n    crypto = require(\'crypto\');\r\n\r\n// 从文件加载key:\r\nfunction loadKey(file) {\r\n    // key实际上就是PEM编码的字符串:\r\n    return fs.readFileSync(file, \'utf8\');\r\n}\r\n\r\nlet\r\n    prvKey = loadKey(\'./rsa-prv.pem\'),\r\n    pubKey = loadKey(\'./rsa-pub.pem\'),\r\n    message = \'Hello, world!\';\r\n\r\n// 使用私钥加密:\r\nlet enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, \'utf8\'));\r\nconsole.log(\'encrypted by private key: \' + enc_by_prv.toString(\'hex\'));\r\n\r\n\r\nlet dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);\r\nconsole.log(\'decrypted by public key: \' + dec_by_pub.toString(\'utf8\'));\r\n```\r\n\r\n执行后，可以得到解密后的消息，与原始消息相同。\r\n\r\n接下来我们使用公钥加密，私钥解密：\r\n\r\n```\r\n// 使用公钥加密:\r\nlet enc_by_pub = crypto.publicEncrypt(pubKey, Buffer.from(message, \'utf8\'));\r\nconsole.log(\'encrypted by public key: \' + enc_by_pub.toString(\'hex\'));\r\n\r\n// 使用私钥解密:\r\nlet dec_by_prv = crypto.privateDecrypt(prvKey, enc_by_pub);\r\nconsole.log(\'decrypted by private key: \' + dec_by_prv.toString(\'utf8\'));\r\n```\r\n\r\n执行得到的解密后的消息仍与原始消息相同。\r\n\r\n如果我们把`message`字符串的长度增加到很长，例如1M，这时，执行RSA加密会得到一个类似这样的错误：`data too large for key size`，这是因为RSA加密的原始信息必须小于Key的长度。那如何用RSA加密一个很长的消息呢？实际上，RSA并不适合加密大数据，而是先生成一个随机的AES密码，用AES加密原始信息，然后用RSA加密AES口令，这样，实际使用RSA时，给对方传的密文分两部分，一部分是AES加密的密文，另一部分是RSA加密的AES口令。对方用RSA先解密出AES口令，再用AES解密密文，即可获得明文。\r\n\r\n### 证书\r\n\r\ncrypto模块也可以处理数字证书。数字证书通常用在SSL连接，也就是Web的https连接。一般情况下，https连接只需要处理服务器端的单向认证，如无特殊需求（例如自己作为Root给客户发认证证书），建议用反向代理服务器如Nginx等Web服务器去处理证书。\r\n\r\n### 参考源码\r\n\r\n[crypto常用算法](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/crypto)","timestamp":1590329650947},{"name":"86-模块.md","path":"13-语言学习project/11-JavaScript/1-nodejs/86-模块.md","content":"#### 模块\r\n\r\n阅读: 6737274\r\n\r\n------\r\n\r\n在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。\r\n\r\n为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。\r\n\r\n使用模块有什么好处？\r\n\r\n最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。\r\n\r\n使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。\r\n\r\n在上一节，我们编写了一个`hello.js`文件，这个`hello.js`文件就是一个模块，模块的名字就是文件名（去掉`.js`后缀），所以`hello.js`文件就是名为`hello`的模块。\r\n\r\n我们把`hello.js`改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar s = \'Hello\';\r\n\r\nfunction greet(name) {\r\n    console.log(s + \', \' + name + \'!\');\r\n}\r\n\r\nmodule.exports = greet;\r\n```\r\n\r\n函数`greet()`是我们在`hello`模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数`greet`作为模块的输出暴露出去，这样其他模块就可以使用`greet`函数了。\r\n\r\n问题是其他模块怎么使用`hello`模块的这个`greet`函数呢？我们再编写一个`main.js`文件，调用`hello`模块的`greet`函数：\r\n\r\n```\r\n\'use strict\';\r\n\r\n// 引入hello模块:\r\nvar greet = require(\'./hello\');\r\n\r\nvar s = \'Michael\';\r\n\r\ngreet(s); // Hello, Michael!\r\n```\r\n\r\n注意到引入`hello`模块用Node提供的`require`函数：\r\n\r\n```\r\nvar greet = require(\'./hello\');\r\n```\r\n\r\n引入的模块作为变量保存在`greet`变量中，那`greet`变量到底是什么东西？其实变量`greet`就是在`hello.js`中我们用`module.exports = greet;`输出的`greet`函数。所以，`main.js`就成功地引用了`hello.js`模块中定义的`greet()`函数，接下来就可以直接使用它了。\r\n\r\n在使用`require()`引入模块的时候，请注意模块的相对路径。因为`main.js`和`hello.js`位于同一个目录，所以我们用了当前目录`.`：\r\n\r\n```\r\nvar greet = require(\'./hello\'); // 不要忘了写相对目录!\r\n```\r\n\r\n如果只写模块名：\r\n\r\n```\r\nvar greet = require(\'hello\');\r\n```\r\n\r\n则Node会依次在内置模块、全局模块和当前模块下查找`hello.js`，你很可能会得到一个错误：\r\n\r\n```\r\nmodule.js\r\n    throw err;\r\n          ^\r\nError: Cannot find module \'hello\'\r\n    at Function.Module._resolveFilename\r\n    at Function.Module._load\r\n    ...\r\n    at Function.Module._load\r\n    at Function.Module.runMain\r\n```\r\n\r\n遇到这个错误，你要检查：\r\n\r\n- 模块名是否写对了；\r\n- 模块文件是否存在；\r\n- 相对路径是否写对了。\r\n\r\n### CommonJS规范\r\n\r\n这种模块加载机制被称为CommonJS规范。在这个规范下，每个`.js`文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，`hello.js`和`main.js`都申明了全局变量`var s = \'xxx\'`，但互不影响。\r\n\r\n一个模块想要对外暴露变量（函数也是变量），可以用`module.exports = variable;`，一个模块要引用其他模块暴露的变量，用`var ref = require(\'module_name\');`就拿到了引用模块的变量。\r\n\r\n### 结论\r\n\r\n要在模块中对外输出变量，用：\r\n\r\n```\r\nmodule.exports = variable;\r\n```\r\n\r\n输出的变量可以是任意对象、函数、数组等等。\r\n\r\n要引入其他模块输出的对象，用：\r\n\r\n```\r\nvar foo = require(\'other_module\');\r\n```\r\n\r\n引入的对象具体是什么，取决于引入模块输出的对象。\r\n\r\n### 深入了解模块原理\r\n\r\n如果你想详细地了解CommonJS的模块实现原理，请继续往下阅读。如果不想了解，请直接跳到最后做练习。\r\n\r\n当我们编写JavaScript代码时，我们可以申明全局变量：\r\n\r\n```\r\nvar s = \'global\';\r\n```\r\n\r\n在浏览器中，大量使用全局变量可不好。如果你在`a.js`中使用了全局变量`s`，那么，在`b.js`中也使用全局变量`s`，将造成冲突，`b.js`中对`s`赋值会改变`a.js`的运行逻辑。\r\n\r\n也就是说，JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。\r\n\r\n那Node.js是如何实现这一点的？\r\n\r\n其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js也并不会增加任何JavaScript语法。实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。\r\n\r\n请注意我们编写的`hello.js`代码是这样的：\r\n\r\n```\r\nvar s = \'Hello\';\r\nvar name = \'world\';\r\n\r\nconsole.log(s + \' \' + name + \'!\');\r\n```\r\n\r\nNode.js加载了`hello.js`后，它可以把代码包装一下，变成这样执行：\r\n\r\n```\r\n(function () {\r\n    // 读取的hello.js代码:\r\n    var s = \'Hello\';\r\n    var name = \'world\';\r\n\r\n    console.log(s + \' \' + name + \'!\');\r\n    // hello.js代码结束\r\n})();\r\n```\r\n\r\n这样一来，原来的全局变量`s`现在变成了匿名函数内部的局部变量。如果Node.js继续加载其他模块，这些模块中定义的“全局”变量`s`也互不干扰。\r\n\r\n所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。\r\n\r\n但是，模块的输出`module.exports`怎么实现？\r\n\r\n这个也很容易实现，Node可以先准备一个对象`module`：\r\n\r\n```\r\n// 准备module对象:\r\nvar module = {\r\n    id: \'hello\',\r\n    exports: {}\r\n};\r\nvar load = function (module) {\r\n    // 读取的hello.js代码:\r\n    function greet(name) {\r\n        console.log(\'Hello, \' + name + \'!\');\r\n    }\r\n    \r\n    module.exports = greet;\r\n    // hello.js代码结束\r\n    return module.exports;\r\n};\r\nvar exported = load(module);\r\n// 保存module:\r\nsave(module, exported);\r\n```\r\n\r\n可见，变量`module`是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在`hello.js`中可以直接使用变量`module`原因就在于它实际上是函数的一个参数：\r\n\r\n```\r\nmodule.exports = greet;\r\n```\r\n\r\n通过把参数`module`传递给`load()`函数，`hello.js`就顺利地把一个变量传递给了Node执行环境，Node会把`module`变量保存到某个地方。\r\n\r\n由于Node保存了所有导入的`module`，当我们用`require()`获取module时，Node找到对应的`module`，把这个`module`的`exports`变量返回，这样，另一个模块就顺利拿到了模块的输出：\r\n\r\n```\r\nvar greet = require(\'./hello\');\r\n```\r\n\r\n以上是Node实现JavaScript模块的一个简单的原理介绍。\r\n\r\n### module.exports vs exports\r\n\r\n很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量：\r\n\r\n方法一：对module.exports赋值：\r\n\r\n```\r\n// hello.js\r\n\r\nfunction hello() {\r\n    console.log(\'Hello, world!\');\r\n}\r\n\r\nfunction greet(name) {\r\n    console.log(\'Hello, \' + name + \'!\');\r\n}\r\n\r\nmodule.exports = {\r\n    hello: hello,\r\n    greet: greet\r\n};\r\n```\r\n\r\n方法二：直接使用exports：\r\n\r\n```\r\n// hello.js\r\n\r\nfunction hello() {\r\n    console.log(\'Hello, world!\');\r\n}\r\n\r\nfunction greet(name) {\r\n    console.log(\'Hello, \' + name + \'!\');\r\n}\r\n\r\nfunction hello() {\r\n    console.log(\'Hello, world!\');\r\n}\r\n\r\nexports.hello = hello;\r\nexports.greet = greet;\r\n```\r\n\r\n但是你不可以直接对`exports`赋值：\r\n\r\n```\r\n// 代码可以执行，但是模块并没有输出任何变量:\r\nexports = {\r\n    hello: hello,\r\n    greet: greet\r\n};\r\n```\r\n\r\n如果你对上面的写法感到十分困惑，不要着急，我们来分析Node的加载机制：\r\n\r\n首先，Node会把整个待加载的`hello.js`文件放入一个包装函数`load`中执行。在执行这个`load()`函数前，Node准备好了module变量：\r\n\r\n```\r\nvar module = {\r\n    id: \'hello\',\r\n    exports: {}\r\n};\r\n```\r\n\r\n`load()`函数最终返回`module.exports`：\r\n\r\n```\r\nvar load = function (exports, module) {\r\n    // hello.js的文件内容\r\n    ...\r\n    // load函数返回:\r\n    return module.exports;\r\n};\r\n\r\nvar exported = load(module.exports, module);\r\n```\r\n\r\n也就是说，默认情况下，Node准备的`exports`变量和`module.exports`变量实际上是同一个变量，并且初始化为空对象`{}`，于是，我们可以写：\r\n\r\n```\r\nexports.foo = function () { return \'foo\'; };\r\nexports.bar = function () { return \'bar\'; };\r\n```\r\n\r\n也可以写：\r\n\r\n```\r\nmodule.exports.foo = function () { return \'foo\'; };\r\nmodule.exports.bar = function () { return \'bar\'; };\r\n```\r\n\r\n换句话说，Node默认给你准备了一个空对象`{}`，这样你可以直接往里面加东西。\r\n\r\n但是，如果我们要输出的是一个函数或数组，那么，只能给`module.exports`赋值：\r\n\r\n```\r\nmodule.exports = function () { return \'foo\'; };\r\n```\r\n\r\n给`exports`赋值是无效的，因为赋值后，`module.exports`仍然是空对象`{}`。\r\n\r\n### 结论\r\n\r\n如果要输出一个键值对象`{}`，可以利用`exports`这个已存在的空对象`{}`，并继续在上面添加新的键值；\r\n\r\n如果要输出一个函数或数组，必须直接对`module.exports`对象赋值。\r\n\r\n所以我们可以得出结论：直接对`module.exports`赋值，可以应对任何情况：\r\n\r\n```\r\nmodule.exports = {\r\n    foo: function () { return \'foo\'; }\r\n};\r\n```\r\n\r\n或者：\r\n\r\n```\r\nmodule.exports = function () { return \'foo\'; };\r\n```\r\n\r\n最终，我们*强烈建议*使用`module.exports = xxx`的方式来输出模块变量，这样，你只需要记忆一种方法。\r\n\r\n### 练习\r\n\r\n编写`hello.js`，输出一个或多个函数；\r\n\r\n编写`main.js`，引入`hello`模块，调用其函数。\r\n\r\n### 参考源码\r\n\r\n[module](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/module)","timestamp":1590329650947},{"name":"87-underscore.md","path":"13-语言学习project/11-JavaScript/2-underscore/87-underscore.md","content":"#### underscore\r\n\r\n阅读: 2248601\r\n\r\n------\r\n\r\n前面我们已经讲过了，JavaScript是函数式编程语言，支持高阶函数和闭包。函数式编程非常强大，可以写出非常简洁的代码。例如`Array`的`map()`和`filter()`方法：\r\n\r\n```\r\n\'use strict\';\r\nvar a1 = [1, 4, 9, 16];\r\nvar a2 = a1.map(Math.sqrt); // [1, 2, 3, 4]\r\nvar a3 = a2.filter((x) => { return x % 2 === 0; }); // [2, 4]\r\n```\r\n\r\n现在问题来了，`Array`有`map()`和`filter()`方法，可是Object没有这些方法。此外，低版本的浏览器例如IE6～8也没有这些方法，怎么办？\r\n\r\n方法一，自己把这些方法添加到`Array.prototype`中，然后给`Object.prototype`也加上`mapObject()`等类似的方法。\r\n\r\n方法二，直接找一个成熟可靠的第三方开源库，使用统一的函数来实现`map()`、`filter()`这些操作。\r\n\r\n我们采用方法二，选择的第三方库就是underscore。\r\n\r\n正如jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作，underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程。\r\n\r\njQuery在加载时，会把自身绑定到唯一的全局变量`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=上，underscore与其类似，会把自身绑定到唯一的全局变量`_`上，这也是为啥它的名字叫underscore的原因。\r\n\r\n用underscore实现`map()`操作如下：\r\n\r\n```\r\n\'use strict\';\r\n_.map([1, 2, 3], (x) => x * x); // [1, 4, 9]\r\n```\r\n\r\n咋一看比直接用`Array.map()`要麻烦一点，可是underscore的`map()`还可以作用于Object：\r\n\r\n```\r\n\'use strict\';\r\n_.map({ a: 1, b: 2, c: 3 }, (v, k) => k + \'=\' + v); // [\'a=1\', \'b=2\', \'c=3\']\r\n```\r\n\r\n后面我们会详细介绍underscore提供了一系列函数式接口。\r\n\r\n#### Collections\r\n\r\n阅读: 468716\r\n\r\n------\r\n\r\nunderscore为集合类对象提供了一致的接口。集合类是指Array和Object，暂不支持Map和Set。\r\n\r\n### map/filter\r\n\r\n和`Array`的`map()`与`filter()`类似，但是underscore的`map()`和`filter()`可以作用于Object。当作用于Object时，传入的函数为`function (value, key)`，第一个参数接收value，第二个参数接收key：\r\n\r\n`\'use strict\'; var obj = {    name: \'bob\',    school: \'No.1 middle school\',    address: \'xueyuan road\' }; ``console.log(JSON.stringify(upper)); ` Run\t\r\n\r\n```JavaScript\r\n\'use strict\';\r\n\r\nvar obj = {\r\n    name: \'bob\',\r\n    school: \'No.1 middle school\',\r\n    address: \'xueyuan road\'\r\n};\r\nvar upper = _.map(obj, function (value, key) {\r\n    return key+\'=\'+value;\r\n});\r\n\r\n\r\nconsole.log(JSON.stringify(upper));//[\"name=bob\",\"school=No.1 middle school\",\"address=xueyuan road\"]\r\n\r\n```\r\n\r\n你也许会想，为啥对Object作`map()`操作的返回结果是`Array`？应该是Object才合理啊！把`_.map`换成`_.mapObject`再试试。\r\n\r\n### every / some\r\n\r\n当集合的所有元素都满足条件时，`_.every()`函数返回`true`，当集合的至少一个元素满足条件时，`_.some()`函数返回`true`：\r\n\r\n```\r\n\'use strict\';\r\n// 所有元素都大于0？\r\n_.every([1, 4, 7, -3, -9], (x) => x > 0); // false\r\n// 至少一个元素大于0？\r\n_.some([1, 4, 7, -3, -9], (x) => x > 0); // true\r\n```\r\n\r\n当集合是Object时，我们可以同时获得value和key：\r\n\r\n`\'use strict\'; var obj = {    name: \'bob\',    school: \'No.1 middle school\',    address: \'xueyuan road\' }; // 判断key和value是否全部是小写： ``console.log(\'every key-value are lowercase: \' + r1 + \'\\nsome key-value are lowercase: \' + r2); ` Run\r\n\r\n### max / min\r\n\r\n这两个函数直接返回集合中最大和最小的数：\r\n\r\n```\r\n\'use strict\';\r\nvar arr = [3, 5, 7, 9];\r\n_.max(arr); // 9\r\n_.min(arr); // 3\r\n\r\n// 空集合会返回-Infinity和Infinity，所以要先判断集合不为空：\r\n_.max([])\r\n-Infinity\r\n_.min([])\r\nInfinity\r\n```\r\n\r\n注意，如果集合是Object，`max()`和`min()`只作用于value，忽略掉key：\r\n\r\n```\r\n\'use strict\';\r\n_.max({ a: 1, b: 2, c: 3 }); // 3\r\n```\r\n\r\n### groupBy\r\n\r\n`groupBy()`把集合的元素按照key归类，key由传入的函数返回：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar scores = [20, 81, 75, 40, 91, 59, 77, 66, 72, 88, 99];\r\nvar groups = _.groupBy(scores, function (x) {\r\n    if (x < 60) {\r\n        return \'C\';\r\n    } else if (x < 80) {\r\n        return \'B\';\r\n    } else {\r\n        return \'A\';\r\n    }\r\n});\r\n// 结果:\r\n// {\r\n//   A: [81, 91, 88, 99],\r\n//   B: [75, 77, 66, 72],\r\n//   C: [20, 40, 59]\r\n// }\r\n```\r\n\r\n可见`groupBy()`用来分组是非常方便的。\r\n\r\n### shuffle / sample\r\n\r\n`shuffle()`用洗牌算法随机打乱一个集合：\r\n\r\n```\r\n\'use strict\';\r\n// 注意每次结果都不一样：\r\n_.shuffle([1, 2, 3, 4, 5, 6]); // [3, 5, 4, 6, 2, 1]\r\n```\r\n\r\n`sample()`则是随机选择一个或多个元素：\r\n\r\n```\r\n\'use strict\';\r\n// 注意每次结果都不一样：\r\n// 随机选1个：\r\n_.sample([1, 2, 3, 4, 5, 6]); // 2\r\n// 随机选3个：\r\n_.sample([1, 2, 3, 4, 5, 6], 3); // [6, 1, 4]\r\n```\r\n\r\n更多完整的函数请参考underscore的文档：http://underscorejs.org/#collections\r\n\r\n### 读后有收获可以支付宝请作者喝咖啡，读后有疑问请加微信群讨论\r\n\r\n#### Arrays\r\n\r\n阅读: 261456\r\n\r\n------\r\n\r\nunderscore为`Array`提供了许多工具类方法，可以更方便快捷地操作`Array`。\r\n\r\n### first / last\r\n\r\n顾名思义，这两个函数分别取第一个和最后一个元素：\r\n\r\n```\r\n\'use strict\';\r\nvar arr = [2, 4, 6, 8];\r\n_.first(arr); // 2\r\n_.last(arr); // 8\r\n```\r\n\r\n### flatten\r\n\r\n`flatten()`接收一个`Array`，无论这个`Array`里面嵌套了多少个`Array`，`flatten()`最后都把它们变成一个一维数组：\r\n\r\n```\r\n\'use strict\';\r\n\r\n_.flatten([1, [2], [3, [[4], [5]]]]); // [1, 2, 3, 4, 5]\r\n```\r\n\r\n### zip / unzip\r\n\r\n`zip()`把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。例如，你有一个`Array`保存了名字，另一个`Array`保存了分数，现在，要把名字和分数给对上，用`zip()`轻松实现：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar names = [\'Adam\', \'Lisa\', \'Bart\'];\r\nvar scores = [85, 92, 59];\r\n_.zip(names, scores);\r\n// [[\'Adam\', 85], [\'Lisa\', 92], [\'Bart\', 59]]\r\n```\r\n\r\n`unzip()`则是反过来：\r\n\r\n```\r\n\'use strict\';\r\nvar namesAndScores = [[\'Adam\', 85], [\'Lisa\', 92], [\'Bart\', 59]];\r\n_.unzip(namesAndScores);\r\n// [[\'Adam\', \'Lisa\', \'Bart\'], [85, 92, 59]]\r\n```\r\n\r\n### object\r\n\r\n有时候你会想，与其用`zip()`，为啥不把名字和分数直接对应成Object呢？别急，`object()`函数就是干这个的：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar names = [\'Adam\', \'Lisa\', \'Bart\'];\r\nvar scores = [85, 92, 59];\r\n_.object(names, scores);\r\n// {Adam: 85, Lisa: 92, Bart: 59}\r\n```\r\n\r\n注意`_.object()`是一个函数，不是JavaScript的`Object`对象。\r\n\r\n### range\r\n\r\n`range()`让你快速生成一个序列，不再需要用`for`循环实现了：\r\n\r\n```\r\n\'use strict\';\r\n\r\n// 从0开始小于10:\r\n_.range(10); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n// 从1开始小于11：\r\n_.range(1, 11); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\n// 从0开始小于30，步长5:\r\n_.range(0, 30, 5); // [0, 5, 10, 15, 20, 25]\r\n\r\n// 从0开始大于-10，步长-1:\r\n_.range(0, -10, -1); // [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\r\n```\r\n\r\n更多完整的函数请参考underscore的文档：http://underscorejs.org/#arrays\r\n\r\n### 练习\r\n\r\n请根据underscore官方文档，使用`_.uniq`对数组元素进行*不区分大小写*去重：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar arr = [\'Apple\', \'orange\', \'banana\', \'ORANGE\', \'apple\', \'PEAR\'];\r\nvar result = _.uniq(arr, (e) => e.toLowerCase());\r\n\r\n// 测试\r\nif (result.toString() === [\"Apple\", \"orange\", \"banana\", \"PEAR\"].toString()) {\r\n    console.log(\'测试成功!\');\r\n} else {\r\n    console.log(\'测试失败!\');\r\n}\r\n```\r\n\r\n#### Functions\r\n\r\n阅读: 195684\r\n\r\n------\r\n\r\n因为underscore本来就是为了充分发挥JavaScript的函数式编程特性，所以也提供了大量JavaScript本身没有的高阶函数。\r\n\r\n### bind\r\n\r\n`bind()`有什么用？我们先看一个常见的错误用法：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar s = \' Hello  \';\r\ns.trim();\r\n// 输出\'Hello\'\r\n\r\nvar fn = s.trim;\r\nfn();\r\n// Uncaught TypeError: String.prototype.trim called on null or undefined\r\n```\r\n\r\n如果你想用`fn()`取代`s.trim()`，按照上面的做法是不行的，因为直接调用`fn()`传入的`this`指针是`undefined`，必须这么用：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar s = \' Hello  \';\r\nvar fn = s.trim;\r\n// 调用call并传入s对象作为this:\r\nfn.call(s)\r\n// 输出Hello\r\n```\r\n\r\n这样搞多麻烦！还不如直接用`s.trim()`。但是，`bind()`可以帮我们把`s`对象直接绑定在`fn()`的`this`指针上，以后调用`fn()`就可以直接正常调用了：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar s = \' Hello  \';\r\nvar fn = _.bind(s.trim, s);\r\nfn();\r\n// 输出Hello\r\n```\r\n\r\n结论：当用一个变量`fn`指向一个对象的方法时，直接调用`fn()`是不行的，因为丢失了`this`对象的引用。用`bind`可以修复这个问题。\r\n\r\n### partial\r\n\r\n`partial()`就是为一个函数创建偏函数。偏函数是什么东东？看例子：\r\n\r\n假设我们要计算xy，这时只需要调用`Math.pow(x, y)`就可以了。\r\n\r\n假设我们经常计算2y，每次都写`Math.pow(2, y)`就比较麻烦，如果创建一个新的函数能直接这样写`pow2N(y)`就好了，这个新函数`pow2N(y)`就是根据`Math.pow(x, y)`创建出来的偏函数，它固定住了原函数的第一个参数（始终为2）：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar pow2N = _.partial(Math.pow, 2);\r\npow2N(3); // 8\r\npow2N(5); // 32\r\npow2N(10); // 1024\r\n```\r\n\r\n如果我们不想固定第一个参数，想固定第二个参数怎么办？比如，希望创建一个偏函数`cube(x)`，计算x3，可以用`_`作占位符，固定住第二个参数：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar cube = _.partial(Math.pow, _, 3);\r\ncube(3); // 27\r\ncube(5); // 125\r\ncube(10); // 1000\r\n```\r\n\r\n可见，创建偏函数的目的是将原函数的某些参数固定住，可以降低新函数调用的难度。\r\n\r\n### memoize\r\n\r\n如果一个函数调用开销很大，我们就可能希望能把结果缓存下来，以便后续调用时直接获得结果。举个例子，计算阶乘就比较耗时：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction factorial(n) {\r\n    console.log(\'start calculate \' + n + \'!...\');\r\n    var s = 1, i = n;\r\n    while (i > 1) {\r\n        s = s * i;\r\n        i --;\r\n    }\r\n    console.log(n + \'! = \' + s);\r\n    return s;\r\n}\r\n\r\nfactorial(10); // 3628800\r\n// 注意控制台输出:\r\n// start calculate 10!...\r\n// 10! = 3628800\r\n```\r\n\r\n用`memoize()`就可以自动缓存函数计算的结果：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar factorial = _.memoize(function(n) {\r\n    console.log(\'start calculate \' + n + \'!...\');\r\n    var s = 1, i = n;\r\n    while (i > 1) {\r\n        s = s * i;\r\n        i --;\r\n    }\r\n    console.log(n + \'! = \' + s);\r\n    return s;\r\n});\r\n\r\n// 第一次调用:\r\nfactorial(10); // 3628800\r\n// 注意控制台输出:\r\n// start calculate 10!...\r\n// 10! = 3628800\r\n\r\n// 第二次调用:\r\nfactorial(10); // 3628800\r\n// 控制台没有输出\r\n```\r\n\r\n对于相同的调用，比如连续两次调用`factorial(10)`，第二次调用并没有计算，而是直接返回上次计算后缓存的结果。不过，当你计算`factorial(9)`的时候，仍然会重新计算。\r\n\r\n可以对`factorial()`进行改进，让其递归调用：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar factorial = _.memoize(function(n) {\r\n    console.log(\'start calculate \' + n + \'!...\');\r\n    if (n < 2) {\r\n        return 1;\r\n    }\r\n    return n * factorial(n - 1);\r\n});\r\n\r\nfactorial(10); // 3628800\r\n// 输出结果说明factorial(1)~factorial(10)都已经缓存了:\r\n// start calculate 10!...\r\n// start calculate 9!...\r\n// start calculate 8!...\r\n// start calculate 7!...\r\n// start calculate 6!...\r\n// start calculate 5!...\r\n// start calculate 4!...\r\n// start calculate 3!...\r\n// start calculate 2!...\r\n// start calculate 1!...\r\n\r\nfactorial(9); // 362880\r\n// console无输出\r\n```\r\n\r\n### once\r\n\r\n顾名思义，`once()`保证某个函数执行且仅执行一次。如果你有一个方法叫`register()`，用户在页面上点两个按钮的任何一个都可以执行的话，就可以用`once()`保证函数仅调用一次，无论用户点击多少次：\r\n\r\n`\'use strict\'; ``// 测试效果: register(); register(); register(); ` Run\r\n\r\n### delay\r\n\r\n`delay()`可以让一个函数延迟执行，效果和`setTimeout()`是一样的，但是代码明显简单了：\r\n\r\n```\r\n\'use strict\';\r\n\r\n// 2秒后调用alert():\r\n_.delay(alert, 2000);\r\n```\r\n\r\n如果要延迟调用的函数有参数，把参数也传进去：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar log = _.bind(console.log, console);\r\n_.delay(log, 2000, \'Hello,\', \'world!\');\r\n// 2秒后打印\'Hello, world!\':\r\n```\r\n\r\n更多完整的函数请参考underscore的文档：http://underscorejs.org/#functions\r\n\r\n#### Objects\r\n\r\n阅读: 181265\r\n\r\n------\r\n\r\n和`Array`类似，underscore也提供了大量针对Object的函数。\r\n\r\n### keys / allKeys\r\n\r\n`keys()`可以非常方便地返回一个object自身所有的key，但不包含从原型链继承下来的：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction Student(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n}\r\n\r\nvar xiaoming = new Student(\'小明\', 20);\r\n_.keys(xiaoming); // [\'name\', \'age\']\r\n```\r\n\r\n`allKeys()`除了object自身的key，还包含从原型链继承下来的：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction Student(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n}\r\nStudent.prototype.school = \'No.1 Middle School\';\r\nvar xiaoming = new Student(\'小明\', 20);\r\n_.allKeys(xiaoming); // [\'name\', \'age\', \'school\']\r\n```\r\n\r\n### values\r\n\r\n和`keys()`类似，`values()`返回object自身但不包含原型链继承的所有值：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar obj = {\r\n    name: \'小明\',\r\n    age: 20\r\n};\r\n\r\n_.values(obj); // [\'小明\', 20]\r\n```\r\n\r\n注意，没有`allValues()`，原因我也不知道。\r\n\r\n### mapObject\r\n\r\n`mapObject()`就是针对object的map版本：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar obj = { a: 1, b: 2, c: 3 };\r\n// 注意传入的函数签名，value在前，key在后:\r\n_.mapObject(obj, (v, k) => 100 + v); // { a: 101, b: 102, c: 103 }\r\n```\r\n\r\n### invert\r\n\r\n`invert()`把object的每个key-value来个交换，key变成value，value变成key：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar obj = {\r\n    Adam: 90,\r\n    Lisa: 85,\r\n    Bart: 59\r\n};\r\n_.invert(obj); // { \'59\': \'Bart\', \'85\': \'Lisa\', \'90\': \'Adam\' }\r\n```\r\n\r\n### extend / extendOwn\r\n\r\n`extend()`把多个object的key-value合并到第一个object并返回：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar a = {name: \'Bob\', age: 20};\r\n_.extend(a, {age: 15}, {age: 88, city: \'Beijing\'}); // {name: \'Bob\', age: 88, city: \'Beijing\'}\r\n// 变量a的内容也改变了：\r\na; // {name: \'Bob\', age: 88, city: \'Beijing\'}\r\n```\r\n\r\n注意：如果有相同的key，后面的object的value将覆盖前面的object的value。\r\n\r\n`extendOwn()`和`extend()`类似，但获取属性时忽略从原型链继承下来的属性。\r\n\r\n### clone\r\n\r\n如果我们要复制一个object对象，就可以用`clone()`方法，它会把原有对象的所有属性都复制到新的对象中：\r\n\r\n`\'use strict\'; var source = {    name: \'小明\',    age: 20,    skills: [\'JavaScript\', \'CSS\', \'HTML\'] }; ``console.log(JSON.stringify(copied, null, \'  \')); ` Run\r\n\r\n注意，`clone()`是“浅复制”。所谓“浅复制”就是说，两个对象相同的key所引用的value其实是同一对象：\r\n\r\n```\r\nsource.skills === copied.skills; // true\r\n```\r\n\r\n也就是说，修改`source.skills`会影响`copied.skills`。\r\n\r\n### isEqual\r\n\r\n`isEqual()`对两个object进行深度比较，如果内容完全相同，则返回`true`：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar o1 = { name: \'Bob\', skills: { Java: 90, JavaScript: 99 }};\r\nvar o2 = { name: \'Bob\', skills: { JavaScript: 99, Java: 90 }};\r\n\r\no1 === o2; // false\r\n_.isEqual(o1, o2); // true\r\n```\r\n\r\n`isEqual()`其实对`Array`也可以比较：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar o1 = [\'Bob\', { skills: [\'Java\', \'JavaScript\'] }];\r\nvar o2 = [\'Bob\', { skills: [\'Java\', \'JavaScript\'] }];\r\n\r\no1 === o2; // false\r\n_.isEqual(o1, o2); // true\r\n```\r\n\r\n更多完整的函数请参考underscore的文档：http://underscorejs.org/#objects\r\n\r\n#### Chaining\r\n\r\n阅读: 168247\r\n\r\n------\r\n\r\n还记得jQuery支持链式调用吗？\r\n\r\n```\r\n$(\'a\').attr(\'target\', \'_blank\')\r\n      .append(\' <i class=\"uk-icon-external-link\"></i>\')\r\n      .click(function () {});\r\n```\r\n\r\n如果我们有一组操作，用underscore提供的函数，写出来像这样：\r\n\r\n```\r\n_.filter(_.map([1, 4, 9, 16, 25], Math.sqrt), x => x % 2 === 1);\r\n// [1, 3, 5]\r\n```\r\n\r\n能不能写成链式调用？\r\n\r\n能！\r\n\r\nunderscore提供了把对象包装成能进行链式调用的方法，就是`chain()`函数：\r\n\r\n\\```console.log(r); // [1, 3, 5] ` Run\r\n\r\n因为每一步返回的都是包装对象，所以最后一步的结果需要调用`value()`获得最终结果。\r\n\r\n### 小结","timestamp":1590329650947},{"name":"88-kora.md","path":"13-语言学习project/11-JavaScript/3-web开发/88-kora.md","content":"#### koa\r\n\r\n阅读: 3390527\r\n\r\n------\r\n\r\nkoa是Express的下一代基于Node.js的web框架，目前有1.x和2.0两个版本。\r\n\r\n### 历史\r\n\r\n#### 1. Express\r\n\r\nExpress是第一代最流行的web框架，它对Node.js的http进行了封装，用起来如下：\r\n\r\n```\r\nvar express = require(\'express\');\r\nvar app = express();\r\n\r\napp.get(\'/\', function (req, res) {\r\n    res.send(\'Hello World!\');\r\n});\r\n\r\napp.listen(3000, function () {\r\n    console.log(\'Example app listening on port 3000!\');\r\n});\r\n```\r\n\r\n虽然Express的API很简单，但是它是基于ES5的语法，要实现异步代码，只有一个方法：回调。如果异步嵌套层次过多，代码写起来就非常难看：\r\n\r\n```\r\napp.get(\'/test\', function (req, res) {\r\n    fs.readFile(\'/file1\', function (err, data) {\r\n        if (err) {\r\n            res.status(500).send(\'read file1 error\');\r\n        }\r\n        fs.readFile(\'/file2\', function (err, data) {\r\n            if (err) {\r\n                res.status(500).send(\'read file2 error\');\r\n            }\r\n            res.type(\'text/plain\');\r\n            res.send(data);\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n虽然可以用async这样的库来组织异步代码，但是用回调写异步实在是太痛苦了！\r\n\r\n#### 2. koa 1.0\r\n\r\n随着新版Node.js开始支持ES6，Express的团队又基于ES6的generator重新编写了下一代web框架koa。和Express相比，koa 1.0使用generator实现异步，代码看起来像同步的：\r\n\r\n```\r\nvar koa = require(\'koa\');\r\nvar app = koa();\r\n\r\napp.use(\'/test\', function *() {\r\n    yield doReadFile1();\r\n    var data = yield doReadFile2();\r\n    this.body = data;\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n用generator实现异步比回调简单了不少，但是generator的本意并不是异步。Promise才是为异步设计的，但是Promise的写法……想想就复杂。为了简化异步代码，ES7（目前是草案，还没有发布）引入了新的关键字`async`和`await`，可以轻松地把一个function变为异步模式：\r\n\r\n```\r\nasync function () {\r\n    var data = await fs.read(\'/file1\');\r\n}\r\n```\r\n\r\n这是JavaScript未来标准的异步代码，非常简洁，并且易于使用。\r\n\r\n#### 3. koa2\r\n\r\nkoa团队并没有止步于koa 1.0，他们非常超前地基于ES7开发了koa2，和koa 1相比，koa2完全使用Promise并配合`async`来实现异步。\r\n\r\nkoa2的代码看上去像这样：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    await next();\r\n    var data = await doReadFile();\r\n    ctx.response.type = \'text/plain\';\r\n    ctx.response.body = data;\r\n});\r\n```\r\n\r\n出于兼容性考虑，目前koa2仍支持generator的写法，但下一个版本将会去掉。\r\n\r\n### 选择哪个版本？\r\n\r\n目前JavaScript处于高速进化中，ES7是大势所趋。为了紧跟时代潮流，教程将使用最新的koa2开发！\r\n\r\n#### koa入门\r\n\r\n阅读: 8200989\r\n\r\n------\r\n\r\n### 创建koa2工程\r\n\r\n首先，我们创建一个目录`hello-koa`并作为工程目录用VS Code打开。然后，我们创建`app.js`，输入以下代码：\r\n\r\n```\r\n// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:\r\nconst Koa = require(\'koa\');\r\n\r\n// 创建一个Koa对象表示web app本身:\r\nconst app = new Koa();\r\n\r\n// 对于任何请求，app将调用该异步函数处理请求：\r\napp.use(async (ctx, next) => {\r\n    await next();\r\n    ctx.response.type = \'text/html\';\r\n    ctx.response.body = \'<h1>Hello, koa2!</h1>\';\r\n});\r\n\r\n// 在端口3000监听:\r\napp.listen(3000);\r\nconsole.log(\'app started at port 3000...\');\r\n```\r\n\r\n对于每一个http请求，koa将调用我们传入的异步函数来处理：\r\n\r\n```\r\nasync (ctx, next) => {\r\n    await next();\r\n    // 设置response的Content-Type:\r\n    ctx.response.type = \'text/html\';\r\n    // 设置response的内容:\r\n    ctx.response.body = \'<h1>Hello, koa2!</h1>\';\r\n}\r\n```\r\n\r\n其中，参数`ctx`是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，`next`是koa传入的将要处理的下一个异步函数。\r\n\r\n上面的异步函数中，我们首先用`await next();`处理下一个异步函数，然后，设置response的Content-Type和内容。\r\n\r\n由`async`标记的函数称为异步函数，在异步函数中，可以用`await`调用另一个异步函数，这两个关键字将在ES7中引入。\r\n\r\n现在我们遇到第一个问题：koa这个包怎么装，`app.js`才能正常导入它？\r\n\r\n方法一：可以用npm命令直接安装koa。先打开命令提示符，务必把当前目录切换到`hello-koa`这个目录，然后执行命令：\r\n\r\n```\r\nC:\\...\\hello-koa> npm install koa@2.0.0\r\n```\r\n\r\nnpm会把koa2以及koa2依赖的所有包全部安装到当前目录的node_modules目录下。\r\n\r\n方法二：在`hello-koa`这个目录下创建一个`package.json`，这个文件描述了我们的`hello-koa`工程会用到哪些包。完整的文件内容如下：\r\n\r\n```\r\n{\r\n    \"name\": \"hello-koa2\",\r\n    \"version\": \"1.0.0\",\r\n    \"description\": \"Hello Koa 2 example with async\",\r\n    \"main\": \"app.js\",\r\n    \"scripts\": {\r\n        \"start\": \"node app.js\"\r\n    },\r\n    \"keywords\": [\r\n        \"koa\",\r\n        \"async\"\r\n    ],\r\n    \"author\": \"Michael Liao\",\r\n    \"license\": \"Apache-2.0\",\r\n    \"repository\": {\r\n        \"type\": \"git\",\r\n        \"url\": \"https://github.com/michaelliao/learn-javascript.git\"\r\n    },\r\n    \"dependencies\": {\r\n        \"koa\": \"2.0.0\"\r\n    }\r\n}\r\n```\r\n\r\n其中，`dependencies`描述了我们的工程依赖的包以及版本号。其他字段均用来描述项目信息，可任意填写。\r\n\r\n然后，我们在`hello-koa`目录下执行`npm install`就可以把所需包以及依赖包一次性全部装好：\r\n\r\n```\r\nC:\\...\\hello-koa> npm install\r\n```\r\n\r\n很显然，第二个方法更靠谱，因为我们只要在`package.json`正确设置了依赖，npm就会把所有用到的包都装好。\r\n\r\n*注意*，任何时候都可以直接删除整个`node_modules`目录，因为用`npm install`命令可以完整地重新下载所有依赖。并且，这个目录不应该被放入版本控制中。\r\n\r\n现在，我们的工程结构如下：\r\n\r\n```\r\nhello-koa/\r\n|\r\n+- .vscode/\r\n|  |\r\n|  +- launch.json <-- VSCode 配置文件\r\n|\r\n+- app.js <-- 使用koa的js\r\n|\r\n+- package.json <-- 项目描述文件\r\n|\r\n+- node_modules/ <-- npm安装的所有依赖包\r\n```\r\n\r\n紧接着，我们在`package.json`中添加依赖包：\r\n\r\n```\r\n\"dependencies\": {\r\n    \"koa\": \"2.0.0\"\r\n}\r\n```\r\n\r\n然后使用`npm install`命令安装后，在VS Code中执行`app.js`，调试控制台输出如下：\r\n\r\n```\r\nnode --debug-brk=40645 --nolazy app.js \r\nDebugger listening on port 40645\r\napp started at port 3000...\r\n```\r\n\r\n我们打开浏览器，输入`http://localhost:3000`，即可看到效果：\r\n\r\n![koa-browser](D:\\Typora_pic\\l-1586080468257.png)\r\n\r\n还可以直接用命令`node app.js`在命令行启动程序，或者用`npm start`启动。`npm start`命令会让npm执行定义在`package.json`文件中的start对应命令：\r\n\r\n```\r\n\"scripts\": {\r\n    \"start\": \"node app.js\"\r\n}\r\n```\r\n\r\n### koa middleware\r\n\r\n让我们再仔细看看koa的执行逻辑。核心代码是：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    await next();\r\n    ctx.response.type = \'text/html\';\r\n    ctx.response.body = \'<h1>Hello, koa2!</h1>\';\r\n});\r\n```\r\n\r\n每收到一个http请求，koa就会调用通过`app.use()`注册的async函数，并传入`ctx`和`next`参数。\r\n\r\n我们可以对`ctx`操作，并设置返回内容。但是为什么要调用`await next()`？\r\n\r\n原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用`await next()`来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。\r\n\r\n例如，可以用以下3个middleware组成处理链，依次打印日志，记录处理时间，输出HTML：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    console.log(`${ctx.request.method} ${ctx.request.url}`); // 打印URL\r\n    await next(); // 调用下一个middleware\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n    const start = new Date().getTime(); // 当前时间\r\n    await next(); // 调用下一个middleware\r\n    const ms = new Date().getTime() - start; // 耗费时间\r\n    console.log(`Time: ${ms}ms`); // 打印耗费时间\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n    await next();\r\n    ctx.response.type = \'text/html\';\r\n    ctx.response.body = \'<h1>Hello, koa2!</h1>\';\r\n});\r\n```\r\n\r\nmiddleware的顺序很重要，也就是调用`app.use()`的顺序决定了middleware的顺序。\r\n\r\n此外，如果一个middleware没有调用`await next()`，会怎么办？答案是后续的middleware将不再执行了。这种情况也很常见，例如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    if (await checkUserPermission(ctx)) {\r\n        await next();\r\n    } else {\r\n        ctx.response.status = 403;\r\n    }\r\n});\r\n```\r\n\r\n理解了middleware，我们就已经会用koa了！\r\n\r\n最后注意`ctx`对象有一些简写的方法，例如`ctx.url`相当于`ctx.request.url`，`ctx.type`相当于`ctx.response.type`。\r\n\r\n### 参考源码\r\n\r\n[hello-koa](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/web/koa/hello-koa)处理URL\r\n\r\n阅读: 1634238\r\n\r\n------\r\n\r\n在hello-koa工程中，我们处理http请求一律返回相同的HTML，这样虽然非常简单，但是用浏览器一测，随便输入任何URL都会返回相同的网页。\r\n\r\n![buduijin](D:\\Typora_pic\\l-1586080670451.png)\r\n\r\n正常情况下，我们应该对不同的URL调用不同的处理函数，这样才能返回不同的结果。例如像这样写：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    if (ctx.request.path === \'/\') {\r\n        ctx.response.body = \'index page\';\r\n    } else {\r\n        await next();\r\n    }\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n    if (ctx.request.path === \'/test\') {\r\n        ctx.response.body = \'TEST page\';\r\n    } else {\r\n        await next();\r\n    }\r\n});\r\n\r\napp.use(async (ctx, next) => {\r\n    if (ctx.request.path === \'/error\') {\r\n        ctx.response.body = \'ERROR page\';\r\n    } else {\r\n        await next();\r\n    }\r\n});\r\n```\r\n\r\n这么写是可以运行的，但是好像有点蠢。\r\n\r\n应该有一个能集中处理URL的middleware，它根据不同的URL调用不同的处理函数，这样，我们才能专心为每个URL编写处理函数。\r\n\r\n### koa-router\r\n\r\n为了处理URL，我们需要引入`koa-router`这个middleware，让它负责处理URL映射。\r\n\r\n我们把上一节的`hello-koa`工程复制一份，重命名为`url-koa`。\r\n\r\n先在`package.json`中添加依赖项：\r\n\r\n```\r\n\"koa-router\": \"7.0.0\"\r\n```\r\n\r\n然后用`npm install`安装。\r\n\r\n接下来，我们修改`app.js`，使用`koa-router`来处理URL：\r\n\r\n```\r\nconst Koa = require(\'koa\');\r\n\r\n// 注意require(\'koa-router\')返回的是函数:\r\nconst router = require(\'koa-router\')();\r\n\r\nconst app = new Koa();\r\n\r\n// log request URL:\r\napp.use(async (ctx, next) => {\r\n    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\r\n    await next();\r\n});\r\n\r\n// add url-route:\r\nrouter.get(\'/hello/:name\', async (ctx, next) => {\r\n    var name = ctx.params.name;\r\n    ctx.response.body = `<h1>Hello, ${name}!</h1>`;\r\n});\r\n\r\nrouter.get(\'/\', async (ctx, next) => {\r\n    ctx.response.body = \'<h1>Index</h1>\';\r\n});\r\n\r\n// add router middleware:\r\napp.use(router.routes());\r\n\r\napp.listen(3000);\r\nconsole.log(\'app started at port 3000...\');\r\n```\r\n\r\n注意导入`koa-router`的语句最后的`()`是函数调用：\r\n\r\n```\r\nconst router = require(\'koa-router\')();\r\n```\r\n\r\n相当于：\r\n\r\n```\r\nconst fn_router = require(\'koa-router\');\r\nconst router = fn_router();\r\n```\r\n\r\n然后，我们使用`router.get(\'/path\', async fn)`来注册一个GET请求。可以在请求路径中使用带变量的`/hello/:name`，变量可以通过`ctx.params.name`访问。\r\n\r\n再运行`app.js`，我们就可以测试不同的URL：\r\n\r\n输入首页：http://localhost:3000/\r\n\r\n![url-index](D:\\Typora_pic\\l-1586080670458.png)\r\n\r\n输入：http://localhost:3000/hello/koa\r\n\r\n![url-hello](D:\\Typora_pic\\l-1586080670470.png)\r\n\r\n### 处理post请求\r\n\r\n用`router.get(\'/path\', async fn)`处理的是get请求。如果要处理post请求，可以用`router.post(\'/path\', async fn)`。\r\n\r\n用post请求处理URL时，我们会遇到一个问题：post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都*不提供*解析request的body的功能！\r\n\r\n所以，我们又需要引入另一个middleware来解析原始request请求，然后，把解析后的参数，绑定到`ctx.request.body`中。\r\n\r\n`koa-bodyparser`就是用来干这个活的。\r\n\r\n我们在`package.json`中添加依赖项：\r\n\r\n```\r\n\"koa-bodyparser\": \"3.2.0\"\r\n```\r\n\r\n然后使用`npm install`安装。\r\n\r\n下面，修改`app.js`，引入`koa-bodyparser`：\r\n\r\n```\r\nconst bodyParser = require(\'koa-bodyparser\');\r\n```\r\n\r\n在合适的位置加上：\r\n\r\n```\r\napp.use(bodyParser());\r\n```\r\n\r\n由于middleware的顺序很重要，这个`koa-bodyparser`必须在`router`之前被注册到`app`对象上。\r\n\r\n现在我们就可以处理post请求了。写一个简单的登录表单：\r\n\r\n```\r\nrouter.get(\'/\', async (ctx, next) => {\r\n    ctx.response.body = `<h1>Index</h1>\r\n        <form action=\"/signin\" method=\"post\">\r\n            <p>Name: <input name=\"name\" value=\"koa\"></p>\r\n            <p>Password: <input name=\"password\" type=\"password\"></p>\r\n            <p><input type=\"submit\" value=\"Submit\"></p>\r\n        </form>`;\r\n});\r\n\r\nrouter.post(\'/signin\', async (ctx, next) => {\r\n    var\r\n        name = ctx.request.body.name || \'\',\r\n        password = ctx.request.body.password || \'\';\r\n    console.log(`signin with name: ${name}, password: ${password}`);\r\n    if (name === \'koa\' && password === \'12345\') {\r\n        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\r\n    } else {\r\n        ctx.response.body = `<h1>Login failed!</h1>\r\n        <p><a href=\"/\">Try again</a></p>`;\r\n    }\r\n});\r\n```\r\n\r\n注意到我们用`var name = ctx.request.body.name || \'\'`拿到表单的`name`字段，如果该字段不存在，默认值设置为`\'\'`。\r\n\r\n类似的，put、delete、head请求也可以由router处理。\r\n\r\n### 重构\r\n\r\n现在，我们已经可以处理不同的URL了，但是看看`app.js`，总觉得还是有点不对劲。\r\n\r\n![still-buduijin](D:\\Typora_pic\\l-1586080670479.png)\r\n\r\n所有的URL处理函数都放到`app.js`里显得很乱，而且，每加一个URL，就需要修改`app.js`。随着URL越来越多，`app.js`就会越来越长。\r\n\r\n如果能把URL处理函数集中到某个js文件，或者某几个js文件中就好了，然后让`app.js`自动导入所有处理URL的函数。这样，代码一分离，逻辑就显得清楚了。最好是这样：\r\n\r\n```\r\nurl2-koa/\r\n|\r\n+- .vscode/\r\n|  |\r\n|  +- launch.json <-- VSCode 配置文件\r\n|\r\n+- controllers/\r\n|  |\r\n|  +- login.js <-- 处理login相关URL\r\n|  |\r\n|  +- users.js <-- 处理用户管理相关URL\r\n|\r\n+- app.js <-- 使用koa的js\r\n|\r\n+- package.json <-- 项目描述文件\r\n|\r\n+- node_modules/ <-- npm安装的所有依赖包\r\n```\r\n\r\n于是我们把`url-koa`复制一份，重命名为`url2-koa`，准备重构这个项目。\r\n\r\n我们先在`controllers`目录下编写`index.js`：\r\n\r\n```\r\nvar fn_index = async (ctx, next) => {\r\n    ctx.response.body = `<h1>Index</h1>\r\n        <form action=\"/signin\" method=\"post\">\r\n            <p>Name: <input name=\"name\" value=\"koa\"></p>\r\n            <p>Password: <input name=\"password\" type=\"password\"></p>\r\n            <p><input type=\"submit\" value=\"Submit\"></p>\r\n        </form>`;\r\n};\r\n\r\nvar fn_signin = async (ctx, next) => {\r\n    var\r\n        name = ctx.request.body.name || \'\',\r\n        password = ctx.request.body.password || \'\';\r\n    console.log(`signin with name: ${name}, password: ${password}`);\r\n    if (name === \'koa\' && password === \'12345\') {\r\n        ctx.response.body = `<h1>Welcome, ${name}!</h1>`;\r\n    } else {\r\n        ctx.response.body = `<h1>Login failed!</h1>\r\n        <p><a href=\"/\">Try again</a></p>`;\r\n    }\r\n};\r\n\r\nmodule.exports = {\r\n    \'GET /\': fn_index,\r\n    \'POST /signin\': fn_signin\r\n};\r\n```\r\n\r\n这个`index.js`通过`module.exports`把两个URL处理函数暴露出来。\r\n\r\n类似的，`hello.js`把一个URL处理函数暴露出来：\r\n\r\n```\r\nvar fn_hello = async (ctx, next) => {\r\n    var name = ctx.params.name;\r\n    ctx.response.body = `<h1>Hello, ${name}!</h1>`;\r\n};\r\n\r\nmodule.exports = {\r\n    \'GET /hello/:name\': fn_hello\r\n};\r\n```\r\n\r\n现在，我们修改`app.js`，让它自动扫描`controllers`目录，找到所有`js`文件，导入，然后注册每个URL：\r\n\r\n```\r\n// 先导入fs模块，然后用readdirSync列出文件\r\n// 这里可以用sync是因为启动时只运行一次，不存在性能问题:\r\nvar files = fs.readdirSync(__dirname + \'/controllers\');\r\n\r\n// 过滤出.js文件:\r\nvar js_files = files.filter((f)=>{\r\n    return f.endsWith(\'.js\');\r\n});\r\n\r\n// 处理每个js文件:\r\nfor (var f of js_files) {\r\n    console.log(`process controller: ${f}...`);\r\n    // 导入js文件:\r\n    let mapping = require(__dirname + \'/controllers/\' + f);\r\n    for (var url in mapping) {\r\n        if (url.startsWith(\'GET \')) {\r\n            // 如果url类似\"GET xxx\":\r\n            var path = url.substring(4);\r\n            router.get(path, mapping[url]);\r\n            console.log(`register URL mapping: GET ${path}`);\r\n        } else if (url.startsWith(\'POST \')) {\r\n            // 如果url类似\"POST xxx\":\r\n            var path = url.substring(5);\r\n            router.post(path, mapping[url]);\r\n            console.log(`register URL mapping: POST ${path}`);\r\n        } else {\r\n            // 无效的URL:\r\n            console.log(`invalid URL: ${url}`);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n如果上面的大段代码看起来还是有点费劲，那就把它拆成更小单元的函数：\r\n\r\n```\r\nfunction addMapping(router, mapping) {\r\n    for (var url in mapping) {\r\n        if (url.startsWith(\'GET \')) {\r\n            var path = url.substring(4);\r\n            router.get(path, mapping[url]);\r\n            console.log(`register URL mapping: GET ${path}`);\r\n        } else if (url.startsWith(\'POST \')) {\r\n            var path = url.substring(5);\r\n            router.post(path, mapping[url]);\r\n            console.log(`register URL mapping: POST ${path}`);\r\n        } else {\r\n            console.log(`invalid URL: ${url}`);\r\n        }\r\n    }\r\n}\r\n\r\nfunction addControllers(router) {\r\n    var files = fs.readdirSync(__dirname + \'/controllers\');\r\n    var js_files = files.filter((f) => {\r\n        return f.endsWith(\'.js\');\r\n    });\r\n\r\n    for (var f of js_files) {\r\n        console.log(`process controller: ${f}...`);\r\n        let mapping = require(__dirname + \'/controllers/\' + f);\r\n        addMapping(router, mapping);\r\n    }\r\n}\r\n\r\naddControllers(router);\r\n```\r\n\r\n确保每个函数功能非常简单，一眼能看明白，是代码可维护的关键。\r\n\r\n### Controller Middleware\r\n\r\n最后，我们把扫描`controllers`目录和创建`router`的代码从`app.js`中提取出来，作为一个简单的middleware使用，命名为`controller.js`：\r\n\r\n```\r\nconst fs = require(\'fs\');\r\n\r\nfunction addMapping(router, mapping) {\r\n    ...\r\n}\r\n\r\nfunction addControllers(router, dir) {\r\n    ...\r\n}\r\n\r\nmodule.exports = function (dir) {\r\n    let\r\n        controllers_dir = dir || \'controllers\', // 如果不传参数，扫描目录默认为\'controllers\'\r\n        router = require(\'koa-router\')();\r\n    addControllers(router, controllers_dir);\r\n    return router.routes();\r\n};\r\n```\r\n\r\n这样一来，我们在`app.js`的代码又简化了：\r\n\r\n```\r\n...\r\n\r\n// 导入controller middleware:\r\nconst controller = require(\'./controller\');\r\n\r\n...\r\n\r\n// 使用middleware:\r\napp.use(controller());\r\n\r\n...\r\n```\r\n\r\n经过重新整理后的工程`url2-koa`目前具备非常好的模块化，所有处理URL的函数按功能组存放在`controllers`目录，今后我们也只需要不断往这个目录下加东西就可以了，`app.js`保持不变。\r\n\r\n### 参考源码\r\n\r\n[url-koa](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/web/koa/url-koa)\r\n\r\n[url2-koa](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/web/koa/url2-koa)\r\n\r\n#### 使用Nunjucks\r\n\r\n阅读: 770492\r\n\r\n------\r\n\r\n### Nunjucks\r\n\r\nNunjucks是什么东东？其实它是一个模板引擎。\r\n\r\n那什么是模板引擎？\r\n\r\n模板引擎就是基于模板配合数据构造出字符串输出的一个组件。比如下面的函数就是一个模板引擎：\r\n\r\n```\r\nfunction examResult (data) {\r\n    return `${data.name}同学一年级期末考试语文${data.chinese}分，数学${data.math}分，位于年级第${data.ranking}名。`\r\n}\r\n```\r\n\r\n如果我们输入数据如下：\r\n\r\n```\r\nexamResult({\r\n    name: \'小明\',\r\n    chinese: 78,\r\n    math: 87,\r\n    ranking: 999\r\n});\r\n```\r\n\r\n该模板引擎把模板字符串里面对应的变量替换以后，就可以得到以下输出：\r\n\r\n```\r\n小明同学一年级期末考试语文78分，数学87分，位于年级第999名。\r\n```\r\n\r\n模板引擎最常见的输出就是输出网页，也就是HTML文本。当然，也可以输出任意格式的文本，比如Text，XML，Markdown等等。\r\n\r\n有同学要问了：既然JavaScript的模板字符串可以实现模板功能，那为什么我们还需要另外的模板引擎？\r\n\r\n因为JavaScript的模板字符串必须写在JavaScript代码中，要想写出新浪首页这样复杂的页面，是非常困难的。\r\n\r\n输出HTML有几个特别重要的问题需要考虑：\r\n\r\n#### 转义\r\n\r\n对特殊字符要转义，避免受到XSS攻击。比如，如果变量`name`的值不是`小明`，而是`小明...`，模板引擎输出的HTML到了浏览器，就会自动执行恶意JavaScript代码。\r\n\r\n#### 格式化\r\n\r\n对不同类型的变量要格式化，比如，货币需要变成`12,345.00`这样的格式，日期需要变成`2016-01-01`这样的格式。\r\n\r\n#### 简单逻辑\r\n\r\n模板还需要能执行一些简单逻辑，比如，要按条件输出内容，需要if实现如下输出：\r\n\r\n```\r\n{{ name }}同学，\r\n{% if score >= 90 %}\r\n    成绩优秀，应该奖励\r\n{% elif score >=60 %}\r\n    成绩良好，继续努力\r\n{% else %}\r\n    不及格，建议回家打屁股\r\n{% endif %}\r\n```\r\n\r\n所以，我们需要一个功能强大的模板引擎，来完成页面输出的功能。\r\n\r\n### Nunjucks\r\n\r\n我们选择Nunjucks作为模板引擎。Nunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，既可以用在Node环境下，又可以运行在浏览器端。但是，主要还是运行在Node环境下，因为浏览器端有更好的模板解决方案，例如MVVM框架。\r\n\r\n如果你使用过Python的模板引擎[jinja2](https://www.liaoxuefeng.com/wiki/1016959663602400/1017806952856928)，那么使用Nunjucks就非常简单，两者的语法几乎是一模一样的，因为Nunjucks就是用JavaScript重新实现了jinjia2。\r\n\r\n从上面的例子我们可以看到，虽然模板引擎内部可能非常复杂，但是使用一个模板引擎是非常简单的，因为本质上我们只需要构造这样一个函数：\r\n\r\n```\r\nfunction render(view, model) {\r\n    // TODO:...\r\n}\r\n```\r\n\r\n其中，`view`是模板的名称（又称为视图），因为可能存在多个模板，需要选择其中一个。`model`就是数据，在JavaScript中，它就是一个简单的Object。`render`函数返回一个字符串，就是模板的输出。\r\n\r\n下面我们来使用Nunjucks这个模板引擎来编写几个HTML模板，并且用实际数据来渲染模板并获得最终的HTML输出。\r\n\r\n我们创建一个`use-nunjucks`的VS Code工程结构如下：\r\n\r\n```\r\nuse-nunjucks/\r\n|\r\n+- .vscode/\r\n|  |\r\n|  +- launch.json <-- VSCode 配置文件\r\n|\r\n+- views/\r\n|  |\r\n|  +- hello.html <-- HTML模板文件\r\n|\r\n+- app.js <-- 入口js\r\n|\r\n+- package.json <-- 项目描述文件\r\n|\r\n+- node_modules/ <-- npm安装的所有依赖包\r\n```\r\n\r\n其中，模板文件存放在`views`目录中。\r\n\r\n我们先在`package.json`中添加`nunjucks`的依赖：\r\n\r\n```\r\n\"nunjucks\": \"2.4.2\"\r\n```\r\n\r\n注意，模板引擎是可以独立使用的，并不需要依赖koa。用`npm install`安装所有依赖包。\r\n\r\n紧接着，我们要编写使用Nunjucks的函数`render`。怎么写？方法是查看Nunjucks的[官方文档](http://mozilla.github.io/nunjucks/)，仔细阅读后，在`app.js`中编写代码如下：\r\n\r\n```\r\nconst nunjucks = require(\'nunjucks\');\r\n\r\nfunction createEnv(path, opts) {\r\n    var\r\n        autoescape = opts.autoescape === undefined ? true : opts.autoescape,\r\n        noCache = opts.noCache || false,\r\n        watch = opts.watch || false,\r\n        throwOnUndefined = opts.throwOnUndefined || false,\r\n        env = new nunjucks.Environment(\r\n            new nunjucks.FileSystemLoader(\'views\', {\r\n                noCache: noCache,\r\n                watch: watch,\r\n            }), {\r\n                autoescape: autoescape,\r\n                throwOnUndefined: throwOnUndefined\r\n            });\r\n    if (opts.filters) {\r\n        for (var f in opts.filters) {\r\n            env.addFilter(f, opts.filters[f]);\r\n        }\r\n    }\r\n    return env;\r\n}\r\n\r\nvar env = createEnv(\'views\', {\r\n    watch: true,\r\n    filters: {\r\n        hex: function (n) {\r\n            return \'0x\' + n.toString(16);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n变量`env`就表示Nunjucks模板引擎对象，它有一个`render(view, model)`方法，正好传入`view`和`model`两个参数，并返回字符串。\r\n\r\n创建`env`需要的参数可以查看文档获知。我们用`autoescape = opts.autoescape && true`这样的代码给每个参数加上默认值，最后使用`new nunjucks.FileSystemLoader(\'views\')`创建一个文件系统加载器，从`views`目录读取模板。\r\n\r\n我们编写一个`hello.html`模板文件，放到`views`目录下，内容如下：\r\n\r\n```\r\n<h1>Hello {{ name }}</h1>\r\n```\r\n\r\n然后，我们就可以用下面的代码来渲染这个模板：\r\n\r\n```\r\nvar s = env.render(\'hello.html\', { name: \'小明\' });\r\nconsole.log(s);\r\n```\r\n\r\n获得输出如下：\r\n\r\n```\r\n<h1>Hello 小明</h1>\r\n```\r\n\r\n咋一看，这和使用JavaScript模板字符串没啥区别嘛。不过，试试：\r\n\r\n```\r\nvar s = env.render(\'hello.html\', { name: \'<script>alert(\"小明\")</script>\' });\r\nconsole.log(s);\r\n```\r\n\r\n获得输出如下：\r\n\r\n```\r\n<h1>Hello &lt;script&gt;alert(\"小明\")&lt;/script&gt;</h1>\r\n```\r\n\r\n这样就避免了输出恶意脚本。\r\n\r\n此外，可以使用Nunjucks提供的功能强大的tag，编写条件判断、循环等功能，例如：\r\n\r\n```\r\n<!-- 循环输出名字 -->\r\n<body>\r\n    <h3>Fruits List</h3>\r\n    {% for f in fruits %}\r\n    <p>{{ f }}</p>\r\n    {% endfor %}\r\n</body>\r\n```\r\n\r\nNunjucks模板引擎最强大的功能在于模板的继承。仔细观察各种网站可以发现，网站的结构实际上是类似的，头部、尾部都是固定格式，只有中间页面部分内容不同。如果每个模板都重复头尾，一旦要修改头部或尾部，那就需要改动所有模板。\r\n\r\n更好的方式是使用继承。先定义一个基本的网页框架`base.html`：\r\n\r\n```\r\n<html><body>\r\n{% block header %} <h3>Unnamed</h3> {% endblock %}\r\n{% block body %} <div>No body</div> {% endblock %}\r\n{% block footer %} <div>copyright</div> {% endblock %}\r\n</body>\r\n```\r\n\r\n`base.html`定义了三个可编辑的块，分别命名为`header`、`body`和`footer`。子模板可以有选择地对块进行重新定义：\r\n\r\n```\r\n{% extends \'base.html\' %}\r\n\r\n{% block header %}<h1>{{ header }}</h1>{% endblock %}\r\n\r\n{% block body %}<p>{{ body }}</p>{% endblock %}\r\n```\r\n\r\n然后，我们对子模板进行渲染：\r\n\r\n```\r\nconsole.log(env.render(\'extend.html\', {\r\n    header: \'Hello\',\r\n    body: \'bla bla bla...\'\r\n}));\r\n```\r\n\r\n输出HTML如下：\r\n\r\n```\r\n<html><body>\r\n<h1>Hello</h1>\r\n<p>bla bla bla...</p>\r\n<div>copyright</div> <-- footer没有重定义，所以仍使用父模板的内容\r\n</body>\r\n```\r\n\r\n### 性能\r\n\r\n最后我们要考虑一下Nunjucks的性能。\r\n\r\n对于模板渲染本身来说，速度是非常非常快的，因为就是拼字符串嘛，纯CPU操作。\r\n\r\n性能问题主要出现在从文件读取模板内容这一步。这是一个IO操作，在Node.js环境中，我们知道，单线程的JavaScript最不能忍受的就是同步IO，但Nunjucks默认就使用同步IO读取模板文件。\r\n\r\n好消息是Nunjucks会缓存已读取的文件内容，也就是说，模板文件最多读取一次，就会放在内存中，后面的请求是不会再次读取文件的，只要我们指定了`noCache: false`这个参数。\r\n\r\n在开发环境下，可以关闭cache，这样每次重新加载模板，便于实时修改模板。在生产环境下，一定要打开cache，这样就不会有性能问题。\r\n\r\nNunjucks也提供了异步读取的方式，但是这样写起来很麻烦，有简单的写法我们就不会考虑复杂的写法。保持代码简单是可维护性的关键。\r\n\r\n### 参考源码\r\n\r\n[use-nunjucks](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/web/koa/use-nunjucks)\r\n\r\n#### 使用MVC\r\n\r\n阅读: 889117\r\n\r\n------\r\n\r\n### MVC\r\n\r\n我们已经可以用koa处理不同的URL，还可以用Nunjucks渲染模板。现在，是时候把这两者结合起来了！\r\n\r\n当用户通过浏览器请求一个URL时，koa将调用某个异步函数处理该URL。在这个异步函数内部，我们用一行代码：\r\n\r\n```\r\nctx.render(\'home.html\', { name: \'Michael\' });\r\n```\r\n\r\n通过Nunjucks把数据用指定的模板渲染成HTML，然后输出给浏览器，用户就可以看到渲染后的页面了：\r\n\r\n![mvc](D:\\Typora_pic\\l-1586081569795.png)\r\n\r\n这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。\r\n\r\n异步函数是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；\r\n\r\n包含变量`{{ name }}`的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。\r\n\r\nMVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。\r\n\r\n上面的例子中，Model就是一个JavaScript对象：\r\n\r\n```\r\n{ name: \'Michael\' }\r\n```\r\n\r\n下面，我们根据原来的`url2-koa`创建工程`view-koa`，把koa2、Nunjucks整合起来，然后，把原来直接输出字符串的方式，改为`ctx.render(view, model)`的方式。\r\n\r\n工程`view-koa`结构如下：\r\n\r\n```\r\nview-koa/\r\n|\r\n+- .vscode/\r\n|  |\r\n|  +- launch.json <-- VSCode 配置文件\r\n|\r\n+- controllers/ <-- Controller\r\n|\r\n+- views/ <-- html模板文件\r\n|\r\n+- static/ <-- 静态资源文件\r\n|\r\n+- controller.js <-- 扫描注册Controller\r\n|\r\n+- app.js <-- 使用koa的js\r\n|\r\n+- package.json <-- 项目描述文件\r\n|\r\n+- node_modules/ <-- npm安装的所有依赖包\r\n```\r\n\r\n在`package.json`中，我们将要用到的依赖包有：\r\n\r\n```\r\n\"koa\": \"2.0.0\",\r\n\"koa-bodyparser\": \"3.2.0\",\r\n\"koa-router\": \"7.0.0\",\r\n\"nunjucks\": \"2.4.2\",\r\n\"mime\": \"1.3.4\",\r\n\"mz\": \"2.4.0\"\r\n```\r\n\r\n先用`npm install`安装依赖包。\r\n\r\n然后，我们准备编写以下两个Controller：\r\n\r\n#### 处理首页 GET /\r\n\r\n我们定义一个async函数处理首页URL`/`：\r\n\r\n```\r\nasync (ctx, next) => {\r\n    ctx.render(\'index.html\', {\r\n        title: \'Welcome\'\r\n    });\r\n}\r\n```\r\n\r\n注意到koa并没有在`ctx`对象上提供`render`方法，这里我们假设应该这么使用，这样，我们在编写Controller的时候，最后一步调用`ctx.render(view, model)`就完成了页面输出。\r\n\r\n#### 处理登录请求 POST /signin\r\n\r\n我们再定义一个async函数处理登录请求`/signin`：\r\n\r\n```\r\nasync (ctx, next) => {\r\n    var\r\n        email = ctx.request.body.email || \'\',\r\n        password = ctx.request.body.password || \'\';\r\n    if (email === \'admin@example.com\' && password === \'123456\') {\r\n        // 登录成功:\r\n        ctx.render(\'signin-ok.html\', {\r\n            title: \'Sign In OK\',\r\n            name: \'Mr Node\'\r\n        });\r\n    } else {\r\n        // 登录失败:\r\n        ctx.render(\'signin-failed.html\', {\r\n            title: \'Sign In Failed\'\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n由于登录请求是一个POST，我们就用`ctx.request.body.`拿到POST请求的数据，并给一个默认值。\r\n\r\n登录成功时我们用`signin-ok.html`渲染，登录失败时我们用`signin-failed.html`渲染，所以，我们一共需要以下3个View：\r\n\r\n- index.html\r\n- signin-ok.html\r\n- signin-failed.html\r\n\r\n### 编写View\r\n\r\n在编写View的时候，我们实际上是在编写HTML页。为了让页面看起来美观大方，使用一个现成的CSS框架是非常有必要的。我们用[Bootstrap](http://getbootstrap.com/)这个CSS框架。从首页下载zip包后解压，我们把所有静态资源文件放到`/static`目录下：\r\n\r\n```\r\nview-koa/\r\n|\r\n+- static/\r\n   |\r\n   +- css/ <- 存放bootstrap.css等\r\n   |\r\n   +- fonts/ <- 存放字体文件\r\n   |\r\n   +- js/ <- 存放bootstrap.js等   \r\n```\r\n\r\n这样我们在编写HTML的时候，可以直接用Bootstrap的CSS，像这样：\r\n\r\n```\r\n<link rel=\"stylesheet\" href=\"/static/css/bootstrap.css\">\r\n```\r\n\r\n现在，在使用MVC之前，第一个问题来了，如何处理静态文件？\r\n\r\n我们把所有静态资源文件全部放入`/static`目录，目的就是能统一处理静态文件。在koa中，我们需要编写一个middleware，处理以`/static/`开头的URL。\r\n\r\n### 编写middleware\r\n\r\n我们来编写一个处理静态文件的middleware。编写middleware实际上一点也不复杂。我们先创建一个`static-files.js`的文件，编写一个能处理静态文件的middleware：\r\n\r\n```\r\nconst path = require(\'path\');\r\nconst mime = require(\'mime\');\r\nconst fs = require(\'mz/fs\');\r\n\r\n// url: 类似 \'/static/\'\r\n// dir: 类似 __dirname + \'/static\'\r\nfunction staticFiles(url, dir) {\r\n    return async (ctx, next) => {\r\n        let rpath = ctx.request.path;\r\n        // 判断是否以指定的url开头:\r\n        if (rpath.startsWith(url)) {\r\n            // 获取文件完整路径:\r\n            let fp = path.join(dir, rpath.substring(url.length));\r\n            // 判断文件是否存在:\r\n            if (await fs.exists(fp)) {\r\n                // 查找文件的mime:\r\n                ctx.response.type = mime.lookup(rpath);\r\n                // 读取文件内容并赋值给response.body:\r\n                ctx.response.body = await fs.readFile(fp);\r\n            } else {\r\n                // 文件不存在:\r\n                ctx.response.status = 404;\r\n            }\r\n        } else {\r\n            // 不是指定前缀的URL，继续处理下一个middleware:\r\n            await next();\r\n        }\r\n    };\r\n}\r\n\r\nmodule.exports = staticFiles;\r\n```\r\n\r\n`staticFiles`是一个普通函数，它接收两个参数：URL前缀和一个目录，然后返回一个async函数。这个async函数会判断当前的URL是否以指定前缀开头，如果是，就把URL的路径视为文件，并发送文件内容。如果不是，这个async函数就不做任何事情，而是简单地调用`await next()`让下一个middleware去处理请求。\r\n\r\n我们使用了一个`mz`的包，并通过`require(\'mz/fs\');`导入。`mz`提供的API和Node.js的`fs`模块完全相同，但`fs`模块使用回调，而`mz`封装了`fs`对应的函数，并改为Promise。这样，我们就可以非常简单的用`await`调用`mz`的函数，而不需要任何回调。\r\n\r\n所有的第三方包都可以通过npm官网搜索并查看其文档：\r\n\r\nhttps://www.npmjs.com/\r\n\r\n最后，这个middleware使用起来也很简单，在`app.js`里加一行代码：\r\n\r\n```\r\nlet staticFiles = require(\'./static-files\');\r\napp.use(staticFiles(\'/static/\', __dirname + \'/static\'));\r\n```\r\n\r\n*注意*：也可以去npm搜索能用于koa2的处理静态文件的包并直接使用。\r\n\r\n### 集成Nunjucks\r\n\r\n集成Nunjucks实际上也是编写一个middleware，这个middleware的作用是给`ctx`对象绑定一个`render(view, model)`的方法，这样，后面的Controller就可以调用这个方法来渲染模板了。\r\n\r\n我们创建一个`templating.js`来实现这个middleware：\r\n\r\n```\r\nconst nunjucks = require(\'nunjucks\');\r\n\r\nfunction createEnv(path, opts) {\r\n    var\r\n        autoescape = opts.autoescape === undefined ? true : opts.autoescape,\r\n        noCache = opts.noCache || false,\r\n        watch = opts.watch || false,\r\n        throwOnUndefined = opts.throwOnUndefined || false,\r\n        env = new nunjucks.Environment(\r\n            new nunjucks.FileSystemLoader(path || \'views\', {\r\n                noCache: noCache,\r\n                watch: watch,\r\n            }), {\r\n                autoescape: autoescape,\r\n                throwOnUndefined: throwOnUndefined\r\n            });\r\n    if (opts.filters) {\r\n        for (var f in opts.filters) {\r\n            env.addFilter(f, opts.filters[f]);\r\n        }\r\n    }\r\n    return env;\r\n}\r\n\r\nfunction templating(path, opts) {\r\n    // 创建Nunjucks的env对象:\r\n    var env = createEnv(path, opts);\r\n    return async (ctx, next) => {\r\n        // 给ctx绑定render函数:\r\n        ctx.render = function (view, model) {\r\n            // 把render后的内容赋值给response.body:\r\n            ctx.response.body = env.render(view, Object.assign({}, ctx.state || {}, model || {}));\r\n            // 设置Content-Type:\r\n            ctx.response.type = \'text/html\';\r\n        };\r\n        // 继续处理请求:\r\n        await next();\r\n    };\r\n}\r\n\r\nmodule.exports = templating;\r\n```\r\n\r\n注意到`createEnv()`函数和前面使用Nunjucks时编写的函数是一模一样的。我们主要关心`tempating()`函数，它会返回一个middleware，在这个middleware中，我们只给`ctx`“安装”了一个`render()`函数，其他什么事情也没干，就继续调用下一个middleware。\r\n\r\n使用的时候，我们在`app.js`添加如下代码：\r\n\r\n```\r\nconst isProduction = process.env.NODE_ENV === \'production\';\r\n\r\napp.use(templating(\'views\', {\r\n    noCache: !isProduction,\r\n    watch: !isProduction\r\n}));\r\n```\r\n\r\n这里我们定义了一个常量`isProduction`，它判断当前环境是否是production环境。如果是，就使用缓存，如果不是，就关闭缓存。在开发环境下，关闭缓存后，我们修改View，可以直接刷新浏览器看到效果，否则，每次修改都必须重启Node程序，会极大地降低开发效率。\r\n\r\nNode.js在全局变量`process`中定义了一个环境变量`env.NODE_ENV`，为什么要使用该环境变量？因为我们在开发的时候，环境变量应该设置为`\'development\'`，而部署到服务器时，环境变量应该设置为`\'production\'`。在编写代码的时候，要根据当前环境作不同的判断。\r\n\r\n*注意*：生产环境上必须配置环境变量`NODE_ENV = \'production\'`，而开发环境不需要配置，实际上`NODE_ENV`可能是`undefined`，所以判断的时候，不要用`NODE_ENV === \'development\'`。\r\n\r\n类似的，我们在使用上面编写的处理静态文件的middleware时，也可以根据环境变量判断：\r\n\r\n```\r\nif (! isProduction) {\r\n    let staticFiles = require(\'./static-files\');\r\n    app.use(staticFiles(\'/static/\', __dirname + \'/static\'));\r\n}\r\n```\r\n\r\n这是因为在生产环境下，静态文件是由部署在最前面的反向代理服务器（如Nginx）处理的，Node程序不需要处理静态文件。而在开发环境下，我们希望koa能顺带处理静态文件，否则，就必须手动配置一个反向代理服务器，这样会导致开发环境非常复杂。\r\n\r\n### 编写View\r\n\r\n在编写View的时候，非常有必要先编写一个`base.html`作为骨架，其他模板都继承自`base.html`，这样，才能大大减少重复工作。\r\n\r\n编写HTML不在本教程的讨论范围之内。这里我们参考Bootstrap的官网简单编写了`base.html`。\r\n\r\n### 运行\r\n\r\n一切顺利的话，这个`view-koa`工程应该可以顺利运行。运行前，我们再检查一下`app.js`里的middleware的顺序：\r\n\r\n第一个middleware是记录URL以及页面执行时间：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    console.log(`Process ${ctx.request.method} ${ctx.request.url}...`);\r\n    var\r\n        start = new Date().getTime(),\r\n        execTime;\r\n    await next();\r\n    execTime = new Date().getTime() - start;\r\n    ctx.response.set(\'X-Response-Time\', `${execTime}ms`);\r\n});\r\n```\r\n\r\n第二个middleware处理静态文件：\r\n\r\n```\r\nif (! isProduction) {\r\n    let staticFiles = require(\'./static-files\');\r\n    app.use(staticFiles(\'/static/\', __dirname + \'/static\'));\r\n}\r\n```\r\n\r\n第三个middleware解析POST请求：\r\n\r\n```\r\napp.use(bodyParser());\r\n```\r\n\r\n第四个middleware负责给`ctx`加上`render()`来使用Nunjucks：\r\n\r\n```\r\napp.use(templating(\'view\', {\r\n    noCache: !isProduction,\r\n    watch: !isProduction\r\n}));\r\n```\r\n\r\n最后一个middleware处理URL路由：\r\n\r\n```\r\napp.use(controller());\r\n```\r\n\r\n现在，在VS Code中运行代码，不出意外的话，在浏览器输入`localhost:3000/`，可以看到首页内容：\r\n\r\n![koa-index](D:\\Typora_pic\\l-1586081569803.png)\r\n\r\n直接在首页登录，如果输入正确的Email和Password，进入登录成功的页面：\r\n\r\n![koa-signin-ok](https://www.liaoxuefeng.com/files/attachments/1100575896762496/l)\r\n\r\n如果输入的Email和Password不正确，进入登录失败的页面：\r\n\r\n![koa-signin-failed](https://www.liaoxuefeng.com/files/attachments/1100575918131328/l)\r\n\r\n怎么判断正确的Email和Password？目前我们在`signin.js`中是这么判断的：\r\n\r\n```\r\nif (email === \'admin@example.com\' && password === \'123456\') {\r\n    ...\r\n}\r\n```\r\n\r\n当然，真实的网站会根据用户输入的Email和Password去数据库查询并判断登录是否成功，不过这需要涉及到Node.js环境如何操作数据库，我们后面再讨论。\r\n\r\n### 扩展\r\n\r\n注意到`ctx.render`内部渲染模板时，Model对象并不是传入的model变量，而是：\r\n\r\n```\r\nObject.assign({}, ctx.state || {}, model || {})\r\n```\r\n\r\n这个小技巧是为了扩展。\r\n\r\n首先，`model || {}`确保了即使传入`undefined`，model也会变为默认值`{}`。`Object.assign()`会把除第一个参数外的其他参数的所有属性复制到第一个参数中。第二个参数是`ctx.state || {}`，这个目的是为了能把一些公共的变量放入`ctx.state`并传给View。\r\n\r\n例如，某个middleware负责检查用户权限，它可以把当前用户放入`ctx.state`中：\r\n\r\n```\r\napp.use(async (ctx, next) => {\r\n    var user = tryGetUserFromCookie(ctx.request);\r\n    if (user) {\r\n        ctx.state.user = user;\r\n        await next();\r\n    } else {\r\n        ctx.response.status = 403;\r\n    }\r\n});\r\n```\r\n\r\n这样就没有必要在每个Controller的async函数中都把user变量放入model中。\r\n\r\n### 参考源码\r\n\r\n[view-koa](https://github.com/michaelliao/learn-javascript/tree/master/samples/node/web/koa/view-koa)","timestamp":1590329650947},{"name":"89-web.md","path":"13-语言学习project/11-JavaScript/3-web开发/89-web.md","content":"#### Web开发\r\n\r\n阅读: 2607220\r\n\r\n------\r\n\r\n最早的软件都是运行在大型机上的，软件使用者通过“哑终端”登陆到大型机上去运行软件。后来随着PC机的兴起，软件开始主要运行在桌面上，而数据库这样的软件运行在服务器端，这种Client/Server模式简称CS架构。\r\n\r\n随着互联网的兴起，人们发现，CS架构不适合Web，最大的原因是Web应用程序的修改和升级非常迅速，而CS架构需要每个客户端逐个升级桌面App，因此，Browser/Server模式开始流行，简称BS架构。\r\n\r\n在BS架构下，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。\r\n\r\n当然，Web页面也具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构迅速流行起来。\r\n\r\n今天，除了重量级的软件如Office，Photoshop等，大部分软件都以Web形式提供。比如，新浪提供的新闻、博客、微博等服务，均是Web应用。\r\n\r\nWeb应用开发可以说是目前软件开发中最重要的部分。Web开发也经历了好几个阶段：\r\n\r\n静态Web页面：由文本编辑器直接编辑并生成静态的HTML页面，如果要修改Web页面的内容，就需要再次编辑HTML源文件，早期的互联网Web页面就是静态的；\r\n\r\nCGI：由于静态Web页面无法与用户交互，比如用户填写了一个注册表单，静态Web页面就无法处理。要处理用户发送的动态数据，出现了Common Gateway Interface，简称CGI，用C/C++编写。\r\n\r\nASP/JSP/PHP：由于Web应用特点是修改频繁，用C/C++这样的低级语言非常不适合Web开发，而脚本语言由于开发效率高，与HTML结合紧密，因此，迅速取代了CGI模式。ASP是微软推出的用VBScript脚本编程的Web开发技术，而JSP用Java来编写脚本，PHP本身则是开源的脚本语言。\r\n\r\nMVC：为了解决直接用脚本语言嵌入HTML导致的可维护性差的问题，Web应用也引入了Model-View-Controller的模式，来简化Web开发。ASP发展为ASP.Net，JSP和PHP也有一大堆MVC框架。\r\n\r\n目前，Web开发技术仍在快速发展中，异步开发、新的MVVM前端技术层出不穷。\r\n\r\n由于Node.js把JavaScript引入了服务器端，因此，原来必须使用PHP/Java/C#/Python/Ruby等其他语言来开发服务器端程序，现在可以使用Node.js开发了！\r\n\r\n用Node.js开发Web服务器端，有几个显著的优势：\r\n\r\n一是后端语言也是JavaScript，以前掌握了前端JavaScript的开发人员，现在可以同时编写后端代码；\r\n\r\n二是前后端统一使用JavaScript，就没有切换语言的障碍了；\r\n\r\n三是速度快，非常快！这得益于Node.js天生是异步的。\r\n\r\n在Node.js诞生后的短短几年里，出现了无数种Web框架、ORM框架、模版引擎、测试框架、自动化构建工具，数量之多，即使是JavaScript老司机，也不免眼花缭乱。\r\n\r\n常见的Web框架包括：[Express](http://expressjs.com/)，[Sails.js](http://sailsjs.org/)，[koa](http://koajs.com/)，[Meteor](https://www.meteor.com/)，[DerbyJS](http://derbyjs.com/)，[Total.js](https://www.totaljs.com/)，[restify](http://restify.com/)……\r\n\r\nORM框架比Web框架要少一些：[Sequelize](http://www.sequelizejs.com/)，[ORM2](http://dresende.github.io/node-orm2/)，[Bookshelf.js](http://bookshelfjs.org/)，[Objection.js](http://vincit.github.io/objection.js/)……\r\n\r\n模版引擎PK：[Jade](http://jade-lang.com/)，[EJS](http://ejs.co/)，[Swig](https://github.com/paularmstrong/swig)，[Nunjucks](http://mozilla.github.io/nunjucks/)，[doT.js](http://olado.github.io/doT/)……\r\n\r\n测试框架包括：[Mocha](http://mochajs.org/)，[Expresso](http://visionmedia.github.io/expresso/)，[Unit.js](http://unitjs.com/)，[Karma](http://karma-runner.github.io/)……\r\n\r\n构建工具有：[Grunt](http://gruntjs.com/)，[Gulp](http://gulpjs.com/)，[Webpack](http://webpack.github.io/)……\r\n\r\n目前，在npm上已发布的开源Node.js模块数量超过了30万个。\r\n\r\n有选择恐惧症的朋友，看到这里可以洗洗睡了。\r\n\r\n好消息是这个教程已经帮你选好了，你只需要跟着教程一条道走到黑就可以了。\t","timestamp":1590329650947},{"name":"100-数据类型和变量.md","path":"13-语言学习project/11-JavaScript/4-基础/100-数据类型和变量.md","content":"#### 数据类型和变量\r\n\r\n计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：\r\n\r\n| 数据类型  | 说明                             |\r\n| --------- | -------------------------------- |\r\n| null      | 空值，表示非对象                 |\r\n| undefined | 未定义的值，表示未赋值的初始化值 |\r\n| number    | 数字，数学运算的值               |\r\n| string    | 字符串，表示信息流               |\r\n| boolean   | 布尔值，逻辑运算的值             |\r\n| object    | 对象，表示复合结构的数据集       |\r\n\r\n```javascript\r\n//下面代码使用 typeof 运算符分别检测常用值的类型。\r\nconsole.log(typeof 1);  //返回字符串\"number\"\r\nconsole.log(typeof \"1\");  //返回字符串\"string\"\r\nconsole.log(typeof true);  //返回字符串\"boolean\"\r\nconsole.log(typeof {});  //返回字符串\"object\"\r\nconsole.log(typeof []);  //返回字符串\"object\"\r\nconsole.log(typeof function(){});  //返回字符串\"function\"\r\nconsole.log(typeof null);  //返回字符串\"object\"\r\nconsole.log(typeof undefined) ;  //返回字符串\"undefined\"\r\n```\r\n\r\ntypeof 运算符以字符串的形式返回 6 种基本类型之一，不过通过比较可以发现，typeof 返回值与上表存在两点差异，简单说明如下：\r\n\r\n- 把 null 归为 Object 类型，而不是作为一种特殊类型（Null）的值。\r\n- 把 function(,){} 归为 Function 类型。即把函数视为一种独立的基本数据类型，而不是 Object 类型的一种特殊子类。\r\n\r\n==null 值返回类型为 Object，使用下面自定义函数可以避开因为 null 值影响基本类型检测==。\r\n\r\n```javascript\r\n//如果是 null 值，则先返回字符串 \"null\" 否则返回（typeof o）的值\r\nfunction typeOf(o){    \r\n    return (o === null) ? \"null\" : (typeof o);\r\n}\r\nconsole.log(typeOf(1));  //返回字符串\"number\"\r\nconsole.log(typeOf(\"1\"));  //返回字符串\"string\"\r\nconsole.log(typeOf(true));  //返回字符串 \"boolean\"\r\nconsole.log(typeOf({}));  //返回字符串\"object\"\r\nconsole.log(typeOf(null));  //返回字符串\"null\"\r\nconsole.log(typeOf(undefined));  //返回字符串\"undefined\"\r\n```\r\n\r\n## Number\r\n\r\nJavaScript==不区分整数和浮点数==，统一用Number表示，以下都是合法的Number类型：\r\n\r\n```javascript\r\n123; // 整数123\r\n0.456; // 浮点数0.456\r\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\r\n-99; // 负数\r\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\r\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\r\n```\r\n\r\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：`0xff00`，`0xa5b4c3d2`，等等，它们和十进制表示的数值完全一样。\r\n\r\nNumber可以==直接做四则运算，规则和数学一致==：\r\n\r\n```javascript\r\n1 + 2; // 3\r\n(1 + 2) * 5 / 2; // 7.5\r\n2 / 0; // Infinity\r\n0 / 0; // NaN\r\n10 % 3; // 1\r\n10.5 % 3; // 1.5\r\n```\r\n\r\n注意`%`是求余运算。\r\n\r\n```JavaScript\r\n//数值直接量可以细分为整型直接量和浮点型直接量。浮点数就是带有小数点的数值，而整数是不带小数点的数值\r\n//整数一般都是 32 位数值，而浮点数一般都是 64 位数值\r\nvar int = 1;  //整型数值\r\nvar float = 1.0;  //浮点型数值\r\n//浮点数可以使用科学计数法来表示。\r\nvar float = 1.2e3;\r\n//其中 e （或 E）表示底数，其值为 10，而 e 后面跟随的是 10 的指数。指数是一个整型数值，可以取正负值。上述代码等价于：\r\nvar float = 1.2*10*10*10;\r\nvar float = 1200;\r\n//科学计数法表示的浮点数也可以转换为普通的浮点数。\r\nvar float = 1.2e-3; var float = 0.0012;\r\n```\r\n### 浮点数溢出\r\n```JavaScript\r\n//执行数值计算时，要防止浮点数溢出。例如，0.1+0.2 并不等于 0.3。\r\nnum = 0.1+0.2;   //0.30000000000000004\r\n//这是因为 JavaScript 遵循二进制浮点数算术标准（IEEE 754）而导致的问题。这个标准适合很多应用，但它违背了数字基本常识。\r\n\r\n//解决方法：浮点数中的整数运算是精确的，所以小数表现出来的问题可以通过指定精度来避免。例如，针对上面的相加可以这样进行处理。\r\na = (1+2)/10;   //0.3\r\n```\r\n\r\n## 特殊数值\r\n\r\nJavaScript 定义了几个特殊的数值常量，说明如表所示。\r\n\r\n\r\n\r\n| 特殊值                   | 说明                                                         |\r\n| ------------------------ | ------------------------------------------------------------ |\r\n| Infinity                 | 无穷大。当数值超过浮点型所能够表示的范围；反之，负无穷大为-Infinity |\r\n| NaN                      | 非数值。不等于任何数值，包括自己。如当0除以0时会返回这个特殊值 |\r\n| Number.MAX_VALUE         | 表示最大数值                                                 |\r\n| Number.MIN_VALUE         | 表示最小数值，一个接近0的值                                  |\r\n| Number.NaN               | 非数值，与NaN常量相同                                        |\r\n| Number.POSITIVE_INFINITY | 表示正无穷大的数值                                           |\r\n| Number.NEGATIVE_INFINITY | 表示负无穷大的数值                                           |\r\n\r\n```JavaScript\r\n//NaN（Not a Number，非数字值）是在 IEEE 754 中定义的一个特殊的数值。\r\ntypeof NaN === \'number \'   //true\r\n//当试图将非数字形式的字符串转换为数字时，就会生成 NaN。\r\n+ \'0\'  //0\r\n+ \'oops\'  //NaN\r\n//当 NaN 参与数学运算时，运算结果也是 NaN。因此，如果表达式的运算值为 NaN，那么可以推断其中至少一个运算数是 NaN。\r\n//typeof 不能分辨数字和 NaN，并且 NaN 不等同于它自己。\r\nNaN === NaN //false\r\nNaN !== NaN //true\r\n//使用 isNaN() 全局函数可以判断 NaN。\r\nisNaN(NaN) //true\r\nisNaN(0) //false\r\nisNaN(\'oops\') //true\r\nisNaN(\'0\') //false\r\n```\r\n\r\n使用 ==isFinite()== 全局函数可以==判断 NaN 和 Infinity==。因此，可以使用它来检测 NaN、正负无穷大。如果是有限数值，或者可以转换为有限数值，那么将返回 true。如果只是 NaN、正负无穷大的数值，则返回 false 。\r\n\r\nisFinite() 会试图把检测到的值转换为一个数字。如果值不是一个数字，那么使用 isFinite() 直接检测就不是有效的方法。通过自定义 isNumber 函数可以避免 isFinite() 的缺陷。下面自定义函数先判断值是否为数值类型，如果是数值类型，再使用 isFinite() 过滤出有效数字。\r\n\r\n```JavaScript\r\nvar isNumber = function isNumber(value){    \r\n    return typeof value === \'number\' && isFinite(value);\r\n}\r\n```\r\n\r\n## 数值运算\r\n\r\n使用算数运算符，数值可以参与各种计算，如加、减、乘、除等运算操作。\r\n\r\n为了解决复杂数学运算，JavaScript 提供了大量的数值运算函数，这些函数作为 Math 对象的方法可以直接调用。\r\n\r\n```JavaScript\r\nvar a = Math.floor(20.5);  //调用数学函数，向下舍入\r\nvar b = Math.round(20.5);  //调用数学函数，四舍五入\r\ndocument.write(a);  //返回20\r\ndocument.write(b);  //返回21\r\n```\r\n\r\ntoString() 方法可以根据所传递的参数把数值转换为对应进制的数字字符串。参数范围为 2~36 之间的任意整数。\r\n\r\n```JavaScript\r\nvar a = 32;\r\ndocument.writeln(a.toString(2));  //返回字符串100000\r\ndocument.writeln(a.toString(4));  //返回字符串200\r\ndocument.writeln(a.toString(16));  //返回字符串20\r\ndocument.writeln(a.toString(30));  //返回字符串12\r\ndocument.writeln(a.toString(32));  //返回字符串10\r\n```\r\n==数值直接量不能直接调用 toString() 方法，必须先使用小括号或其他方法强制把数字转换为对象。==\r\n\r\n```JavaScript\r\ndocument.writeln(32.toString(16));  //抛出语法错误document.writeln((32).toString(16));   //返回20\r\n```\r\n\r\n### JavaScript二进制、八进制和十六进制\r\n\r\n[JavaScript]支持把十进制数值转换为二进制、八进制和十六进制等不同进制的数值。\r\n\r\n==十六进制数值==以“0X”或“0x”作为前缀，后面跟随十六进制的数值直接量。\r\n\r\n```\r\nvar num = 0x1F4;  //十六进制数值document.write(num);  //返回 500\r\n```\r\n\r\n十六进制的数值是 0~9 和 a~f 的数字或字母任意组合，用来表示 0~15 之间的某个字。\r\n\r\n在 [Java](http://c.biancheng.net/java/)Script 中，可以使用 ==Number 的 toString(16)== 方法把十进制整数转换为十六进制字符串的形式表示。\r\n\r\n==八进制数值==以数字 0 为前缀，其后跟随一个八进制的数值直接量。\r\n\r\n```\r\nvar num = 0764;  //八进制数值\r\ndocument.write(num);  //返回 500\r\n```\r\n\r\n==二进制数值==以“0B”或“0b”作为前缀，后面跟随二进制的数值直接量。例如：0b11 //等于十进制的 3\r\n\r\n<font color=red>注意：</font>\r\n\r\n- ==八进制或十六进制==的数值在参与数学运算之后，==返回的都是十进制数值==。\r\n- 考虑到安全性，不建议使用八进制数值，因为 JavaScript 可能会误解为十进制数值。\r\n- 各主流浏览器对二进制数值表示方法的支持不是很统一，应慎重使用。\r\n\r\n#### 字符串\r\n\r\n字符串是==以单引号\'或双引号\"括起来的任意文本==，比如`\'abc\'`，`\"xyz\"`等等。请注意，`\'\'`或`\"\"`本身只是一种表示方式，不是字符串的一部分，因此，字符串`\'abc\'`只有`a`，`b`，`c`这3个字符。\r\n\r\n==如果字符串包含在双引号中，则字符串内可以包含单引号；反之，也可以在单引号中包含双引号==\r\n\r\n```javascript\r\n//如果要换行显示字符串，可以在字符串中添加换行符\\n。例如：\r\nconsole.log(\"字符串\\n直接量\");  //在字符串中添加换行符\r\n//ECMAScript 5 中，字符串允许多行表示。\r\n//实现方法：在换行结尾处添加反斜杠\\。反斜杠和换行符不作为字符串直接量的内容。例如：\r\nconsole.log(\"字符串\\\r\n直接量\");  //显示“字符串直接量”\r\n\r\n//字符串连接和长度\r\nvar str1 = \"学而不思则罔\",\r\n    str2 = \"思而不学则殆\",\r\n    string = str1 + \"，\" + str2;//加号+运算符连接两个字符串\r\ndocument.write(string);  //显示“学而不思则罔，思而不学则殆”\r\ndocument.write(string.length);  //显示 13 字符串的 length 属性获取字符串的字符个数\r\n```\r\n\r\n#### 字符序列\r\n\r\nJavaScript 字符串是固定不变的字符序列，虽然可以使用各种方法对字符串执行操作，但是返回的都是==新的字符串==，==原字符串保持固定不变==。此外，也不能使用 delete 运算符删除字符串中指定位置的字符。\r\n\r\n在 ECMAScript 5 中，字符串可以作为==只读数组==使用。除了使用 ==charAt()== 访问其中的字符外，还可以使用==中括号运算符==来访问。位置下标从 0 开始，最大位置下标为 length-1。\r\n\r\n```JavaScript\r\n//下面代码使用 for 语句逐个读取字符串中每个字符并显示出来\r\nvar str = \"学而不思则罔，思而不学则殆\";for(var i=0; i<str.length; i++){  console.log(str[i]);}\r\n```\r\n\r\n注意：字符串中的字符不能被 for/in 语句循环枚举。\r\n\r\n# JS给字符串添加HTML标签\r\n\r\n\r\n\r\n[C语言中文网推出辅导班啦，包括「C语言辅导班、C++辅导班、算法/数据结构辅导班」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！](http://fudao.biancheng.net/)\r\n\r\n[JavaScript](http://c.biancheng.net/js/) 定义了一组格式化字符串显示（给字符串添加 HTML 标签）的方法，说明如表所示。\r\n\r\n\r\n\r\n| 方法        | 说明                                                       |\r\n| ----------- | ---------------------------------------------------------- |\r\n| anchor()    | 返回 HTML a 标签中 name 属性值为 String 字符串文本的锚     |\r\n| big()       | 返回使用 HTML big 标签定义的大字体                         |\r\n| blink()     | 返回使用 HTML blink标签定义的闪烁字符串                    |\r\n| bold()      | 返回使用 HTML b 标签定义的粗体字符串                       |\r\n| fixed()     | 返回使用 HTML tt 标签定义的单间距字符串                    |\r\n| fontcolor() | 返回使用 HTML font 标签中 color 属性定义的带有颜色的字符串 |\r\n| fontsize()  | 返回使用 HTML font 标签中 size 属性定义的指定尺寸的字符串  |\r\n| italics()   | 返回使用 HTML i 标签定义的斜体字符串                       |\r\n| link()      | 返回使用 HTML a 标签定义的链接                             |\r\n| small()     | 返回使用 HTML small 标签定义的小字体的字符串               |\r\n| strike()    | 返回使用 HTML strike 标签定义删除线样式的字符串            |\r\n| sub()       | 返回使用 HTML sub 标签定义的下标字符串                     |\r\n| sup()       | 返回使用 HTML sup 标签定义的上标字符串                     |\r\n\r\n由于这些方法没有获得 ECMAScript 标准的支持，应慎重使用。\r\n\r\n#### 示例\r\n\r\n下面示例演示了如何使用上面字符串方法为字符串定义格式化显示属性。\r\n\r\n```\r\nvar s = \"abcdef\";document.write(s.bold());  //定义加粗显示字符串“abcdef”document.write(s.link(\"c.biancheng.net\"));  //为字符串“abcdef”定义超链接document.write(s.italics());  //定义斜体显示字符串“abcdef”document.write(s.fontcolor(\"red\"));  //定义字符串“abcdef”红色显示\r\n```\r\n\r\n由于这些方法都是针对早期浏览器定义的，虽然获得大部分浏览器的支持，但是 IE 不支持 blink 标签，所以字符串调用 blink() 之后，在 IE 下是无效的。\r\n\r\n使用 trim() 方法快速清除掉字符串首尾空格。\r\n\r\n```\r\nvar s = \"    abc def   \\r\\n  \";s = s.trim();console.log(\"[\" + s + \"]\");  //[abc def]console.log(s.length);  //7\r\n```\r\n\r\n## 布尔值\r\n\r\n布尔值和布尔代数的表示完全一致，一个布尔值只有==`true`、`false`==两种值，要么是`true`，要么是`false`，可以直接用`true`、`false`表示布尔值，也可以通过布尔运算计算出来：\r\n\r\n```javascript\r\ntrue; // 这是一个true值\r\nfalse; // 这是一个false值\r\n2 > 1; // 这是一个true值\r\n2 >= 3; // 这是一个false值\r\n//使用 Boolean() 函数可以强制转换值为布尔值\r\nconsole.log(Boolean(0));  //返回 false\r\nconsole.log(Boolean(NaN)); //返回 false\r\nconsole.log(Boolean(null)); //返回 false\r\nconsole.log(Boolean(\"\")); //返回 false\r\nconsole.log(Boolean(undefined)); //返回 false\r\n```\r\n## 逻辑运算符\r\n`&&`运算是与运算，只有所有都为`true`，`&&`运算结果才是`true`：\r\n\r\n```javascript\r\ntrue && true; // 这个&&语句计算结果为true\r\ntrue && false; // 这个&&语句计算结果为false\r\nfalse && true && false; // 这个&&语句计算结果为false\r\n```\r\n`||`运算是或运算，只要其中有一个为`true`，`||`运算结果就是`true`：\r\n```javascript\r\nfalse || false; // 这个||语句计算结果为false\r\ntrue || false; // 这个||语句计算结果为true\r\nfalse || true || false; // 这个||语句计算结果为true\r\n```\r\n`!`运算是非运算，它是一个单目运算符，把`true`变成`false`，`false`变成`true`：\r\n```javascript\r\n! true; // 结果为false\r\n! false; // 结果为true\r\n! (2 > 5); // 结果为true\r\n```\r\n==布尔值经常用在条件判断==中，比如：\r\n\r\n```javascript\r\nvar age = 15;\r\nif (age >= 18) {\r\n    alert(\'adult\');\r\n} else {\r\n    alert(\'teenager\');\r\n}\r\n```\r\n\r\n## 比较运算符\r\n\r\n当我们对Number做比较时，可以通过比较运算符得到一个布尔值：\r\n\r\n```\r\n2 > 5; // false\r\n5 >= 2; // true\r\n7 == 7; // true\r\n```\r\n\r\n实际上，JavaScript允许对==任意数据类型做比较==：\r\n\r\n```\r\nfalse == 0; // true\r\nfalse === 0; // false\r\n```\r\n\r\n要特别注意相等运算符`==`。JavaScript在设计时，有两种比较运算符：\r\n\r\n第一种是`==`比较，它会==自动转换数据类型再比较==，很多时候，会得到非常诡异的结果；\r\n\r\n第二种是`===`比较，它==不会自动转换数据类型==，如果==数据类型不一致==，返回`false`，如果一致，再比较。\r\n\r\n<font color=red>由于JavaScript这个设计缺陷，*不要*使用`==`比较，始终坚持使用`===`比较。</font>\r\n\r\n另一个例外是`NaN`这个特殊的Number==与所有其他值都不相等，包括它自己==：\r\n\r\n```\r\nNaN === NaN; // false\r\n```\r\n\r\n唯一能判断`NaN`的方法是通过`isNaN()`函数：\r\n\r\n```\r\nisNaN(NaN); // true\r\n```\r\n\r\n最后要注意浮点数的相等比较：\r\n\r\n```\r\n1 / 3 === (1 - 2 / 3); // false\r\n```\r\n\r\n这不是JavaScript的设计缺陷。==浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数==。要比较两个浮点数是否相等，<font color=red>只能==计算它们之差的绝对值，看是否小于某个阈值==：</font>\r\n\r\n```javascript\r\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\r\n```\r\n\r\n### null和undefined\r\n\r\n`null`表示一个“空”的值，它和`0`以及空字符串`\'\'`不同，`0`是一个数值，`\'\'`表示长度为0的字符串，而`null`表示==“空”==。\r\n\r\n在其他语言中，也有类似JavaScript的`null`的表示，例如Java也用`null`，Swift用`nil`，Python用`None`表示。但是，在JavaScript中，还有一个和`null`类似的`undefined`，它表示“未定义”。\r\n\r\nJavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在==判断函数参数是否传递==的情况下有用。\r\n\r\n##  JS Undefined类型\r\n\r\nundefined 是 Undefined 类型的唯一值，它表示==未定义的值==。当声明变量==未赋值时，或者定义属性未设置值时，默认值都为 undefined==。\r\n\r\nundefined 派生自 null，null 和 undefined 都表示空缺的值，转化为布尔值时都是假值，可以相等。\r\n\r\n```\r\nconsole.log(null == undefined);  //返回 true\r\n```\r\n\r\nnull 和 undefined 属于两种不同类型，使用全等运算符（==）或 typeof 运算符可以进行检测。\r\n\r\n```javascript\r\nconsole.log(null === undefined);  //false\r\nconsole.log(typeof null);  //返回\"object\"\r\nconsole.log(typeof undefined);  //返回\"undefined\"\r\n```\r\n\r\n#### ==一个变量是否初始化，可以使用 undefined 快速检测==。\r\n\r\n```\r\nvar a; //声明变量console.log(a);  //返回变量默认值为 undefined(a == undefined) && (a = 0);  //检测变量是否初始化，否则为其赋值console.log(a);  //返回初始值 0\r\n```\r\n\r\n也可以使用 typeof 运算符检测变量的类型是否为 undefined。\r\n\r\n```\r\n(typeof a == \"undefined\") && (a = 0);  //检测变量是否初始化，否则为其赋值\r\n```\r\n\r\n在下面代码中，声明了变量 a，但没有声明变量 b，然后使用 typeof 运算符检测它们的类型，返回的值都是字符串 \"undefined\"。说明不管是声明的变量，还是未声明的变量，都可以通过 typeof 运算符检测变量是否初始化。\r\n\r\n```javascript\r\nvar a;\r\nconsole.log(typeof a);  //返回\"undefined”\r\nconsole.log(typeof b);  //返回\"undefined\"\r\n```\r\n\r\n对于未声明的变量 b 来说，如果直接在表达式中使用，会引发异常。\r\n\r\n```\r\nconsole.log(b == undefined); //提75未定义的错误信息\r\n```\r\n\r\n对于函数来说，如果没有明确的返回值，则默认返回值也为\r\n\r\n```javascript\r\nfunction f(){}\r\nconsole.log(f());  //返回\"undefined\"\r\n```\r\n\r\n==undefined 隐含着意外的空值==，而 ==null 隐含着意料之中的空值==。因此，设置一个变量、参数为空值时，建议使用 ==null==，而不是 undefined。\r\n\r\n#### 数组\r\n\r\n数组是一组按顺序排列的集合，集合的每个值称为元素。\r\n\r\n1. JavaScript的==数组可以包括任意数据类型==。例如：\r\n\r\n```javascript\r\n[1, 2, 3.14, \'Hello\', null, true];\r\n```\r\n\r\n上述数组包含6个元素。数组用`[]`表示，元素之间用`,`分隔。\r\n\r\n2. 另一种创建数组的方法是通过`Array()`函数实现：\r\n\r\n```javascript\r\nnew Array(1, 2, 3); // 创建了数组[1, 2, 3]\r\n```\r\n\r\n然而，出于代码的可读性考虑，==强烈建议直接使用`[]`==。\r\n\r\n数组的元素可以通过==索引==来访问。请注意，索引的起始值为`0`：\r\n\r\n```javascript\r\nvar arr = [1, 2, 3.14, \'Hello\', null, true];\r\narr[0]; // 返回索引为0的元素，即1\r\narr[5]; // 返回索引为5的元素，即true\r\narr[6]; // 索引超出了范围，返回undefined\r\n```\r\n\r\n### 对象\r\n\r\nJavaScript的对象是一组由==键-值==组成的无序集合，例如：\r\n\r\n```javascript\r\nvar person = {\r\n    name: \'Bob\',\r\n    age: 20,\r\n    tags: [\'js\', \'web\', \'mobile\'],\r\n    city: \'Beijing\',\r\n    hasCar: true,\r\n    zipcode: null\r\n};\r\n```\r\n\r\nJavaScript对象的==键都是字符串类型==，==值可以是任意数据类型==。\r\n\r\n上述`person`对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，`person`的`name`属性为`\'Bob\'`，`zipcode`属性为`null`。\r\n\r\n要==获取一个对象的属性==，我们用`对象变量.属性名`的方式：\r\n\r\n```javascript\r\nperson.name; // \'Bob\'\r\nperson.zipcode; // null\r\n```\r\n\r\n## 变量\r\n\r\n变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，==变量不仅可以是数字，还可以是任意数据类型==。\r\n\r\n变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=和`_`的组合，且==不能用数字开头==。变量名也==不能是JavaScript的关键字==，如`if`、`while`等。申明一个变量用`var`语句，比如：\r\n\r\n```javascript\r\nvar a; // 申明了变量a，此时a的值为undefined\r\nvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1\r\nvar s_007 = \'007\'; // s_007是一个字符串\r\nvar Answer = true; // Answer是一个布尔值true\r\nvar t = null; // t的值是null\r\n```\r\n\r\n变量名==也可以用中文==，但是，请不要给自己找麻烦。\r\n\r\n在JavaScript中，使用等号`=`对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是==要注意只能用`var`申明一次==，例如：\r\n\r\n```javascript\r\nvar a = 123; // a的值是整数123\r\na = \'ABC\'; // a变为字符串\r\n```\r\n\r\n这种变量本身类型不固定的语言称之为==动态语言==，与之对应的是==静态语言==。==静态语言在定义变量时必须指定变量类型==，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：\r\n\r\n```java\r\nint a = 123; // a是整数类型变量，类型用int申明\r\na = \"ABC\"; // 错误：不能把字符串赋给整型变量\r\n```\r\n\r\n和静态语言相比，动态语言更灵活，就是这个原因。\r\n\r\n请不要把赋值语句的等号等同于数学的等号。比如下面的代码：\r\n\r\n```javascript\r\nvar x = 10;\r\nx = x + 2;\r\n```\r\n\r\n如果从数学上理解`x = x + 2`那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式`x + 2`，得到结果`12`，再赋给变量`x`。由于`x`之前的值是`10`，重新赋值后，`x`的值变成`12`。\r\n\r\n要显示变量的内容，可以用`console.log(x)`，打开Chrome的控制台就可以看到结果。\r\n\r\n使用`console.log()`代替`alert()`的好处是==可以避免弹出烦人的对话框==。\r\n\r\n## 变量作用域\r\n\r\n变量作用域（Scope）是指变量在程序中可以访问的有效范围，也称为变量的可见性。\r\n\r\nJavaScript 变量可以分为全局变量和局部变量：==在函数体内使用 var 语句显式声明局部变量的习惯==\r\n\r\n- 全局变量：==变量在整个页面脚本中都是可见的，可以被自由访问==。\r\n- 局部变量：==变量仅能在声明的函数内部可见，函数外是不允许访问的==。变量类型\r\n\r\nJavaScript 是==弱类型语言==，对于变量类型的规范比较松散。具体表现如下：\r\n\r\n- 变量的类型分类不严谨、不明确，带来使用的随意性。\r\n- 声明变量时，不要求指定类型。\r\n- 使用过程不严格，可以根据需要自动转换变量类型。\r\n- 变量的转换和类型检查没有一套统一、规范的方法，导致开发效率低下。\r\n  由此带来的==优缺点==如下： \r\n\r\n- 优点：使用灵活，简化了代码编写。\r\n- 缺点：执行效率低，在开发大型应用时，程序性能会受到影响。\r\n\r\n## strict模式\r\n\r\nJavaScript在设计之初，为了方便初学者学习，并不强制要求用`var`申明变量。这个设计错误带来了严重的后果：==如果一个变量没有通过`var`申明就被使用，那么该变量就自动被申明为全局变量：==\r\n\r\n```javascript\r\ni = 10; // i现在是全局变量\r\n```\r\n\r\n在同一个页面的不同的JavaScript文件中，如果都不用`var`申明，恰好都使用了变量`i`，将造成变量`i`互相影响，产生难以调试的错误结果。\r\n\r\n使用`var`申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。\r\n\r\n为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，==强制通过`var`申明变量，未使用`var`申明变量就使用的，将导致运行错误。==\r\n\r\n启用strict模式的方法是在JavaScript代码的第一行写上：\r\n\r\n```javascript\r\n\'use strict\';\r\n\r\n// 如果浏览器支持strict模式，\r\n// 下面的代码将报ReferenceError错误:\r\nabc = \'Hello, world\';\r\nconsole.log(abc);\r\n```\r\n\r\n这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。\r\n\r\n ==全局模式==将 \"use strict\" 放在脚本文件的第一行，则整个脚本都将以严格模式运行。如果不在第一行，则整个脚本将以正常模式运行。\r\n\r\n ==局部模式==将 \"use strict\" 放在函数内首部，则整个函数将以严格模式运行。\r\n\r\n## 标识符\r\n\r\n**标识符（Identifier）**就是名称的专业术语。JavaScript 标识符包括变量名、函数名、参数名和属性名。\r\n\r\n合法的标识符应该注意以下强制规则：\r\n\r\n- 第一个字符必须是字母、下划线（_）或美元符号（$）。\r\n- 除了第一个字符外，其他位置可以使用 Unicode 字符。一般建议仅使用 ASCII 编码的字母，不建议使用双字节的字符。\r\n- 不能与 JavaScript 关键字、保留字重名。\r\n- 可以使用 Unicode 转义序列。例如，字符 a 可以使用“\\u0061”表示。\r\n\r\n在下面示例中，定义变量 a，使用 Unicode 转义序列表示变量名。\r\n\r\n```javascript\r\nvar \\u0061 = \"字符 a 的 Unicode 转义序列是 \\\\0061\";document.write(\\u0061);\r\n```\r\n\r\n\r\n使用转义序列不是很方便，一般常用转义序列表示特殊字符或名称，如 JavaScript 关键字、程序脚本等。\r\n\r\n## 关键字\r\n\r\n**关键字**就是 ECMA-262 规定的 JavaScript 语言内部使用的一组名称（或称为命令）。这些名称具有特定的用途，用户不能自定义同名的标识符。具体说明如表所示。\r\n\r\n\r\n\r\n| break                         | delete   | if         | this   | while |\r\n| ----------------------------- | -------- | ---------- | ------ | ----- |\r\n| case                          | do       | in         | throw  | with  |\r\n| catch                         | else     | instanceof | try    |       |\r\n| continue                      | finally  | new        | typeof |       |\r\n| debugger（ECMAScript 5 新增） | for      | return     | var    |       |\r\n| default                       | function | switch     | void   |       |\r\n\r\n## 保留字\r\n\r\n**保留字**就是 ECMA-262 规定的 JavaScript 语言内部预备使用的一组名称（或称为命令）。这些名称目前还没有具体的用途，是为 JavaScript 升级版本预留备用的，建议用户不要使用。具体说明如表所示。\r\n\r\n\r\n\r\n| abstract | double  | goto       | native    | static       |\r\n| -------- | ------- | ---------- | --------- | ------------ |\r\n| boolean  | enum    | implements | package   | super        |\r\n| byte     | export  | import     | private   | synchronized |\r\n| char     | extends | int        | protected | throws       |\r\n| class    | final   | interface  | public    | transient    |\r\n| const    | float   | long       | short     | volatile     |\r\n\r\n\r\nECMAScript 3 将 Java 所有关键字都列为保留字，而 ECMAScript 5 规定较为灵活。\r\n\r\n例如，在非严格模式下，仅规定 class、const、enums、export、extends、import、super 为保留字，其他 ECMAScript 3 保留字可以自由使用；在严格模式下，ECMAScript 5 变得更加谨慎，严格限制 implements、interface、let、package、private、protected、public、static、yield、eval（非保留字）、arguments（非保留字）的使用。\r\n\r\nJavaScript 预定义了很多全局变量和函数，用户也应该避免使用它们。具体说明如表所示。\r\n\r\n\r\n\r\n| arguments          | encodeURL          | Infinity | Number         | RegExp      |\r\n| ------------------ | ------------------ | -------- | -------------- | ----------- |\r\n| Array              | encodeURLComponent | isFinite | Object         | String      |\r\n| Boolean            | Error              | isNaN    | parseFloat     | SyntaxError |\r\n| Date               | eval               | JSON     | parseInt       | TypeError   |\r\n| decodeURL          | EvalError          | Math     | RangeError     | undefined   |\r\n| decodeURLComponent | Function           | NaN      | ReferenceError | URLError    |\r\n\r\n不同的 JavaScript 运行环境都会预定义一些全局变量和函数，上表列出的仅针对 Web 浏览器运行环境。","timestamp":1590329650947},{"name":"101-数据类型转换.md","path":"13-语言学习project/11-JavaScript/4-基础/101-数据类型转换.md","content":"## 一 转换为字符串\r\n\r\n常用值转换为字符串，如图所示。\r\n\r\n\r\n\r\n| 转换前    | 转换后      |\r\n| --------- | ----------- |\r\n| 1         | \"1\"         |\r\n| 0         | \"0\"         |\r\n| true      | \"true\"      |\r\n| false     | \"false\"     |\r\n| \"\"        | \"\"          |\r\n| undefined | \"undefined\" |\r\n| null      | \"null\"      |\r\n| NaN       | \"NaN\"       |\r\n| Infinity  | \"Infinity\"  |\r\n\r\n\r\n把==值转换为字符串==的常用方法有 2 种，具体说明如下。\r\n\r\n### 1. 使用加号运算符\r\n\r\n==当值与空字符串相加运算时，JavaScript 会自动把值转换为字符串。==\r\n\r\n1) 把数字转换为字符串，返回数字本身。\r\n\r\n```\r\nvar n = 123;n = n + \"\";console.log(typeof n); //返回类型为 string\r\n```\r\n\r\n2) 把布尔值转换为字符串，返回字符串 \"true\" 或 \"false\"。\r\n\r\n```\r\nvar b = true;b = b + \"\";console.log(b); //返回字符串\"true\"\r\n```\r\n\r\n3) 把数组转换为字符串，返回==数组元素列表，以逗号分隔==。如果是空数组，则返回空字符串。\r\n\r\n```\r\nvar a = [1,2,3];a = a + \"\";console.log(a); //返回字符串 \"1,2,3\"\r\n```\r\n\r\n4) 把函数转换为字符串，返回==函数的具体代码字符串==。\r\n\r\n```\r\nvar f = function(){return 1;};f = f + \"\";console.log(f);  //返回字符串 \"function (){return 1;}\"\r\n```\r\n\r\n① 如果是==内置类型函数，则只返回构造函数的基本结构==，省略函数的具体实现代码。而==自定义类型函数与普通函数一样，返回函数的具体实现代码字符串==。\r\n\r\n```\r\nd = Date + \"\";console.log(d);  //返回字符串 \"function Date () { [ native code ] } \"\r\n```\r\n\r\n② 如果是内置静态函数，则返回 [object Class] 格式的字符串表示。\r\n\r\n```\r\nm = Math +\"\";console.log(m);  //返回字符串 \"[object Math]\"\r\n```\r\n\r\n5) 如果把==对象实例转换为字符串==，则返回的字符串会根据不同类型或定义对象的方法和参数而不同。具体说明如下。\r\n\r\n① 对象直接量，则返回字符串为 \"[object object]\"\r\n\r\n```\r\nvar a = {  x :1}a = a + \"\";console.log(a);  //返回字符串 \"[object object]\"\r\n```\r\n\r\n② 如果是自定义类的对象实例，则返回字符串为 \"[object object]\"。\r\n\r\n```\r\nvar a =new function(){}();a = a + \"\";console.log(a);  //返回字符串 \"[object object]\"\r\n```\r\n\r\n③ 如果是内置对象实例，具体返回字符串将根据参数而定。\r\n\r\n正则表达式对象会返回匹配模式字符串，时间对象会返回当前`GMT`格式的时间字符串，数值对象会返回传递的参数值字符串或者0等。\r\n\r\n```\r\na = new RegExp(/^\\w$/) + \"\";console.log(a);  //返回字符串 \"/^\\w$/\"\r\n```\r\n\r\n\r\n加号运算符有两个计算功能：==数值求和、字符串连接==。但是==字符串连接操作的优先级要大于求和运算==。因此，在可能的情况下，即运算元的数据类型不一致时，加号运算符会尝试把数值运算元转换为字符串，再执行连接操作。\r\n\r\n但是==当多个加号运算符位于同一行时，这个问题就比较复杂==。例如：\r\n\r\n```JavaScript\r\nvar a = 1 + 1 + \"a\";\r\nvar b= \"a\" + 1 + 1;\r\nconsole.log(a);  //返回字符串 \"2a\"console.log(b);  //返回字符串\"a11\"\r\n```\r\n\r\n通过上面代码可以看到，加号运算符还会考虑运算的顺序。对于变量 a 来说，按照从左到右的运算顺序，加号运算符会执行求和运算，然后再执行连接操作。但是对于变量 b 来说，由于 \"a\" + 1 表达式运算将根据连接操作来执行，所以返回字符串 \"a1\"，然后再用这个字符串与数值 1 进行运算，再次执行连接操作，最后返回字符串 \"a11”，而不是字符串 \"a2”。\r\n\r\n如果要避免此类现象的发生，可以考虑==使用小括号运算符来改变表达式的运算顺序==。\r\n\r\n```JavaScript\r\nvar b = \"a\" + (1 + 1) ; //返回字符串 \"a2\"\r\n```\r\n\r\n### 2. 使用toString()方法\r\n\r\n当为简单的值调用 toString() 方法时，JavaScript 会自动把它们封装为对象，然后再调用 toString() 方法，获取对象的字符串表示。\r\n\r\n```JavaScript\r\nvar a = 123456;\r\na.toString();\r\nconsole.log(a);  //返回字符串“123456”\r\n```\r\n\r\n\r\n使用加号运算符转换字符串，实际上也是调用 toString() 方法来完成，只不过是 JavaScript 自动调用 toString() 方法实现的。\r\n\r\nJavaScript 能够根据运算环境自动转换变量的类型。在自动转换中，JavaScript 一般根据运算的类型环境，按需进行转换。例如，如果在执行字符串为字符串；如果在执行基本数学运算，则会尝试把字符串转换为数值；如果在逻辑运算环境中，则会尝试把值转换为布尔值等。\r\n\r\n## 转换为数字模式字符串\r\n\r\ntoString() 是 Object 类型的原型方法，Number 子类继承该方法后，重写了 toString()，允许传递一个整数参数，设置显示模式。数字默认为十进制显示模式，通过设置参数可以改变数字模式。\r\n\r\n1) 如果==省略参数==，则 toString() 方法会采用默认模式，直接把数字转换为数字字符串。\r\n\r\n```JavaScript\r\nvar a = 1.000;\r\nvar b = 0.0001;\r\nvar c = 1e-1;\r\nconsole.log(a.toString());  //返回字符串“1”\r\nconsole.log(b.toString());  //返回字符串“0.0001”\r\nconsole.log(c.toString());  //返回字符串“0.0001”\r\n```\r\n\r\ntoString() 方法能够直接输出整数和浮点数，保留小数位。小数位末尾的零会被清除。但是对于科学计数法，则会在条件许可的情况下把它转换为浮点数，否则就用科学计数法形式输出字符串。\r\n\r\n```JavaScript\r\nvar a = 1e-14;\r\nconsole.log(a.toString());  //返回字符串“1e-14”\r\n```\r\n\r\n在默认情况下，无论==数值采用什么模式表示，toString() 方法返回的都是十进制的数字字符串==。因此，对于八进制、二进制或十六进制的数字，toString() 方法都会先把它们转换为十进制数值之后再输出。\r\n\r\n```JavaScript\r\nvar a = 010;  //八进制数值 10\r\nvar b = 0x10;  //十六进制数值10\r\nconsole.log(a.toString());  //返回字符串“8”\r\nconsole.log(b.toString());  //返回字符串“16”\r\n```\r\n\r\n2) 如果==设置参数==，则 toString() 方法会根据参数把数值转换为对应进制的值之后，再输出为字符串表示。\r\n\r\n```JavaScript\r\nvar a = 10;  //十进制数值 10\r\nconsole.log(a.toString(2));  //返回二进制数字字符串“1010”\r\nconsole.log(a.toString(8));  //返回八进制数字字符串“12”\r\nconsole.log(a.toString(16));  //返回二进制数字字符串“a”\r\n```\r\n\r\n## 转换为小数格式字符串\r\n\r\n使用 toString() 方法把数值转换为字符串时，无法保留小数位。这对于货币格式化、科学计数等专业领域输出显示数字来说，无疑是不方便的。为此，JavaScript 提供了 3 个专用方法，具体说明如下。\r\n\r\n#### 1) toFixed()\r\n\r\ntoFixed() 能够把数值==转换为字符串，并显示小数点后的指定位数==。\r\n\r\n```JavaScript\r\nvar a = 10;\r\nconsole.log(a.toFixed(2));  //返回字符串“10.00”\r\nconsole.log(a.toFixed(4));  //返回字符串“10.0000”\r\n```\r\n\r\n#### 2) toExponential() ==保留小数个数==\r\n\r\ntoExponential() 方法==专门用来把数字转换为科学计数法形式的字符串==。\r\n\r\n```JavaScript\r\nvar a = 123456789;\r\nconsole.log(a.toExponential(2));  //返回字符串“1.23e+8”\r\nconsole.log(a.toExponential(4));  //返回字符串“1.2346e+8”\r\n```\r\n\r\ntoExponential() 方法的参数==指定了保留的小数位数。省略部分采用四舍五入==的方式进行处理。\r\n\r\n#### 3) toPrecision() ==保留有效数字个数==\r\n\r\ntoPrecision() 方法与 toExponential() 方法相似，但它可以==指定有效数字的位数==，而不是指定小数位数。\r\n\r\n```JavaScript\r\nvar a = 123456789;\r\nconsole.log(a.toPrecision(2));  //返回字符串“1.2e+8”\r\nconsole.log(a.toPrecision(4));  //返回字符串“1.235e+8”\r\n```\r\n\r\n## 转换为数字\r\n\r\n常用值转换为数字说明如下：\r\n\r\n| 1         | 1        |\r\n| --------- | -------- |\r\n| 0         | 0        |\r\n| true      | 1        |\r\n| false     | 0        |\r\n| \"\"        | 0        |\r\n| undefined | NaN      |\r\n| null      | 0        |\r\n| NaN       | NaN      |\r\n| Infinity  | Infinity |\r\n\r\n把值转换为数字的常用方法有 3 种，具体说明如下。\r\n\r\n#### 使用 parseInt()\r\n\r\nparseInt() 是一个全局方法，它==可以把值转换为整数。==转换的过程如下：\r\n\r\n- 先解析位置 0 处的字符，如果不是有效数字，则直接返回 NaN。\r\n- 如果位置 0 处的字符是数字，或者可以转换为有效数字，则继续解析位置 1 处的字符，如果不是有效数字，则直接返回位置 0 处的有效数字。\r\n- 以此类推，按照从左到右的顺序，逐个分析每个字符，直到发现非数字字符为止。\r\n- parseInt() 将把前面分析合法的数字字符全部转换为数值并返回。\r\n\r\n```JavaScript\r\nconsole.log(parseInt(\"123abc\"));  //返回数字123\r\nconsole.log(parseInt(\"1.73\"));   //返回数字1\r\nconsole.log(parseInt(\".123\"));   //返回值NaN\r\n```\r\n\r\n==浮点数中的点对于 parseInt() 来说属于非法字符，因此不会转换小数部分的值。==\r\n\r\n如果是以 0 开头的数字字符串，则 parseInt() 会把它作为八进制数字处理：先把它转换为八进制数值，然后再转换为十进制的数字返回。\r\n\r\n如果是以 0x 开头的数字字符串，则 parseInt() 会把它作为十六进制数字处理：先把它转换为十六进制数值，然后再转换为十进制的数字返回。\r\n\r\n```JavaScript\r\nvar d = 010;  //八进制数字字符串\r\nvar e = 0x10;  //十六进制数字字符串\r\nconsole.log(parseInt(d));  //返回十进制数字8\r\nconsole.log(parseInt(e));  //返回十进制数字16\r\n```\r\n\r\n==parseInt() 也支持基模式，==可以把二进制、八进制、十六进制等不同进制的数字字符串转换为整数。基模式由 parseInt() 函数的第二个参数指定。\r\n\r\n【实例1】下面代码把十六进制数字字符串“123abc”转换为十进制整数。\r\n\r\n```JavaScript\r\nvar a = \"123abc\"; \r\nconsole.log(parseInt(a,16));  //返回十进制整数1194684\r\n```\r\n\r\n【实例2】下面代码把二进制、八进制和十进制数字字符串转换为十进制的整数。\r\n\r\n```JavaScript\r\nconsole.log(parseInt(\"10\",2));  //把二进制数字 10 转换为十进制整数，为 2\r\nconsole.log(parseInt(\"10\",8));  //把八进制数字 10 转换为十进制整数，为 8\r\nconsole.log(parseInt(\"10\",10));  //把十进制数字 10 转换为十进制整数，为 10\r\n```\r\n\r\n【实例3】如果第一个参数是十进制的值，包含 0 前缀，为了避免被误解为八进制的数字，则应该指定第二个参数值为 10，即显示定义基模式，而不是采用默认基模式。\r\n\r\n```JavaScript\r\nconsole.log(parseInt(\"010\"));  //把默认基模式数字 010 转换为十进制整数为 10\r\nconsole.log(parseInt(\"010\",8));  //把八进制数字 010 转换为十进制整数为 8\r\nconsole.log(parseInt(\"010\",10));  //把十进制数字 010 转换为十进制整数为 10\r\n```\r\n\r\n#### 使用 parseFloat() 函数\r\n\r\nparseFloat() 也是一个全局方法，它可以把==值转换为浮点数==，即它能够识别第一个出现的小数点，而第二个小数点被视为非法。解析过程与 parseInt() 方法相同。\r\n\r\n```JavaScript\r\nconsole.log(parseFloat(\"1.234.5\"));  //返回数值 1.234\r\n```\r\n\r\n\r\nparseFloat() 的参数必须是==十进制形式的字符串==，而不能使用八进制或十六进制的数字字符串。同时，对于==数字前面的 0（八进制数字标识）==会忽略，==对于十六进制的数字将返回 0==。\r\n\r\n```JavaScript\r\nconsole.log(parseFloat(\"123\"));  //返回数值 123\r\nconsole.log(parseFloat(\"123abc\"));  //返回数值 123\r\nconsole.log(parseFloat(\"010\"));  //返回数值 10\r\nconsole.log(parseFloat(\"0x10\"));  //返回数值 0\r\nconsole.log(parseFloat(\"x10\"));  //返回数值 NaN\r\n```\r\n\r\n#### 使用乘号运算符\r\n\r\n如果变量乘以 1，则变量会被 JavaScript 自动转换为数值。乘以 1 之后，结果没有发生变化，但是值的类型被转换为数值。==如果值无法被缓缓为合法的数值，则返回 NaN==。\r\n\r\n```JavaScript\r\nvar a = 1;  //数值\r\nvar b = \"1\";  //数字字符串\r\nconsole.log(a + (b * 1));  //返回数值 2\r\n```\r\n\r\n## 转换为布尔值\r\n\r\n常用值转换为布尔值说明如下：\r\n\r\n| 1         | true  |\r\n| --------- | ----- |\r\n| 0         | false |\r\n| true      | true  |\r\n| false     | false |\r\n| \"\"        | false |\r\n| undefined | false |\r\n| null      | false |\r\n| NaN       | false |\r\n| Infinity  | true  |\r\n\r\n把值转换为布尔值的常用方法有 2 种，具体说明如下。\r\n\r\n#### 1. 使用双重逻辑非\r\n\r\n一个逻辑非运算符`!`可以把值转换为布尔值并取反，==两个逻辑非运算符就可以把值转换为正确的布尔值。==\r\n\r\n```JavaScript\r\nconsole.log(!!0);  //返回false\r\nconsole.log(!!1);  //返回true\r\nconsole.log(!!\"\");  //返回false\r\nconsole.log(!!NaN);  //返回false\r\nconsole.log(!!null);  //返回false\r\nconsole.log(!!undefined);  //返回false\r\nconsole.log(!![]);  //返回true\r\nconsole.log(!!{});  //返回true\r\nconsole.log(!!function(){});  //返回true\r\n```\r\n\r\n#### 2. 使用 Boolean() 函数\r\n\r\n使用 Boolean() 函数可以==强制把值转换为布尔值==。\r\n\r\n```JavaScript\r\nconsole.log(Boolean(0));  //返回false\r\nconsole.log(Boolean(1));  //返回true\r\n```\r\n\r\n## 转换为对象\r\n\r\n使用 new 命令调用 String，Number，Boolean 类型函数执行实例化操作，并把值“123”传进去，使用 new 运算符创建实例对象，简单值分别被封装为字符串型对象、数值型对象和布尔型对象。\r\n\r\n```JavaScript\r\nvar n = \"123\";\r\nconsole.log(typeof new String(n));  //返回Object\r\nconsole.log(typeof new Number(n));  //返回Object\r\nconsole.log(typeof new Boolean(n));  //返回Object\r\nconsole.log(Object.prototype.toString.call(new String(n)));  //返回 [object String]\r\nconsole.log(Object.prototype.toString.call(new Number(n)));  //返回 [object Number]\r\nconsole.log(Object.prototype.toString.call(new Boolean(n)));  //返回 [object Boolean]\r\n```\r\n\r\n## 转换为简单值\r\n\r\n#### 1. 在逻辑运算环境中\r\n\r\n在逻辑运算环境中，所有复合型数据对象转换为布尔值都为 true。\r\n\r\n下面代码创建 3 个不同类型的对象，然后参与逻辑与运算。因为不管其值是什么，凡事对象转换为布尔值都为 true，所以才看到不同的显示结果。\r\n\r\n```JavaScript\r\nvar b = new Boolean(false);  //封装false为对象\r\nvar n = new Number(0);  //封装数字0为对象\r\nvar s = new String(\"\");  //封装空字符串对象\r\nb && console.log(b);  //如果b为true，则显示 \"false\"\r\nn && console.log(n);  //如果n为true，则显示 \"0\"\r\ns && console.log(s);  //如果s为true，则显示\"\"\r\n```\r\n\r\n#### 2. 在数值运算环境中\r\n\r\n在数值运算环境中，对象会尝试调用 valueOf() 方法；如果不成功，则再调用 toString() 方法，获取一个值。然后尝试把该值转换为数字，如果成功，则取用该值参与运算；如果转换失败，则取用 NaN 参与运算。\r\n\r\n下面代码使用 Boolean 类型函数把布尔值 true 转换为布尔型对象，然后通过 b-0 数值运算，把布尔型对象转换为数字 1。\r\n\r\n```JavaScript\r\nvar b = new Boolean(true);  //把true封装为对象\r\nconsole.log(b.valueOf());  //测试该对象的值为true\r\nconsole.log(typeof(b.valueOf));  //测试值得类型为boolean\r\nvar n = b-0;  //投放到数值运算环境中\r\nconsole.log(n);  //返回值为1\r\nconsole.log(typeof n);  //测试类型，则为number\r\n```\r\n\r\n#### 3. 在字符串运算环境中\r\n\r\n在字符串运算环境中，对象会调用 toString() 方法，获取对象的字符串表示，以此作为转换的值。\r\n\r\n#### 4. 转换数组\r\n\r\n数组转换为简单值时，会调用 toString() 方法，获取一个字符串表示，然后根据具体运算环境，再把该字符串转换为对应类型的简单值。\r\n\r\n- 如果为空数组，则转换为空字符串。\r\n- 如果仅包含一个元素，则取该元素值。\r\n- 如果包含多个元素，则转换为多个元素的值组合的字符串，并以逗号分隔。\r\n\r\n#### 5. 转换对象\r\n\r\n当对象与数值进行加运算时，会尝试把对象转换为数值，然后参与求和运算。如果不能转换为有效数值，则执行字符串连接操作。\r\n\r\n```JavaScript\r\nvar a = new String(\"a\");  //字符串封装为对象\r\nvar b = new Boolean(true);  //布尔值封装为对象\r\nconsole.log(a+0);  //返回字符串\"a0\"\r\nconsole.log(b+0);  //返回数值1\r\n```\r\n\r\n\r\n当对象与字符串进行加运算时，则直接转换为字符串，执行连接操作。\r\n\r\n```JavaScript\r\nvar a = new String(1); \r\nvar b = new Boolean(true); \r\nconsole.log(a+\"\");  //返回字符串\"1\"\r\nconsole.log(b+\"\");  //返回字符串\"true\"\r\n```\r\n\r\n\r\n当对象与数值进行比较运算时，则尝试把对象转换为数值，然后参与比较运算。如果不能转换为有效数值，则执行字符串比较运算。\r\n\r\n```JavaScript\r\nvar a = new String(\"true\");  //无法转换为数值\r\nvar b = new Boolean(true);  //可以转换为数值\r\nconsole.log(a>0);  //返回false，以字符串形式进行比较\r\nconsole.log(b<0);  //返回true，以数值形式进行比较\r\n```\r\n\r\n当对象与字符串进行比较运算时，则直接转换为字符串，进行比较操作。\r\n\r\n对于 ==Date 对象来说==，加号运算符会先调用 toString() 方法进行转换。因为\r\n\r\n1. 当加号运算符作用于 Date 对象时，一般都是字符串连接操作。\r\n\r\n2. 当比较运算符作用于 Date 对象时，则会转换为数字，以便比较时间的先后。\r\n\r\n#### 6. 转换函数\r\n\r\n函数转换为简单值时，会调用 toString() 方法，获取字符串表示（对于普通函数，则返回的是函数代码本身）。然后根据不同运算环境，再把该字符串表示转换为对应类型的值。\r\n\r\n```JavaScript\r\nvar f = function(){return 5; };\r\nconsole.log(String(f));  //返回字符串function (){return 5; }\r\nconsole.log(Number(f));  //返回NaN\r\nconsole.log(Boolean(f));  //返回true\r\n```\r\n\r\n## 强制类型转换\r\n\r\nJavaScript 支持使用以下函数进行==强制类型转换。==\r\n\r\n- Boolean(value)：把参数值转换为布尔型值。\r\n- Number(value)：把参数值转换为数字。\r\n- String(value)：把参数值转换为字符串。\r\n\r\n\r\n在下面代码中，分别调用上述 3 个函数，把参数值强制转换为新的类型值。\r\n\r\n```JavaScript\r\nconsole.log(String(true));  //返回字符串\"true\"\r\nconsole.log(String(0));  //返回字符串\"0\"\r\nconsole.log(Number(\"1\"));  //返回数值1\r\nconsole.log(Number(true));  //返回数值1\r\nconsole.log(Number(\"a\"));  //返回NaN\r\nconsole.log(Boolean(1));  //返回true\r\nconsole.log(Boolean(\"\"));  //返回false\r\n```\r\n\r\n1) true 被强制转换为数值 1，false 被强制转换为数值 0，而使用 parseInt() 方法转换时，都返回 NaN。\r\n\r\n```JavaScript\r\nconsole.log(Number(true));  //返回1\r\nconsole.log(Number(false));  //返回0\r\nconsole.log(parseInt(true));  //返回NaN\r\nconsole.log(parseInt(false));  //返回NaN\r\n```\r\n\r\n2) 当值包括至少一个字符的字符串、非 0 数字或对象时，Boolean() 强制转换后都会返回 true。\r\n3) 如果值是空字符串、数字 0、undefined 或 null，Boolean() 强制转换后都会返回true。\r\n4) Number() 强制转换与 parseInt() 和 parseFloat() 方法的处理方式不同，==Number() 转换的是整体==，而不是局部值。\r\n\r\n```JavaScript\r\nconsole.log(Number(\"123abc\"));  //返回NaN\r\nconsole.log(Number(\"123\"));  //返回数值123\r\n```\r\n\r\n5) String() 能够把 null 和 undefined 强制转换为对应字符串，而调用 toString() 方法将引发错误。\r\n\r\n```JavaScript\r\nconsole.log(String(null));\r\nconsole.log(String(undefined));\r\nconsole.log(null.toString());\r\nconsole.log(undefined.toString());\r\n```\r\n\r\n\r\n在 JavaScript 中，使用强制类型转换非常有用，但是应该根据具体应用场景使用，以确保正确转换值。\r\n\r\n## 自动类型转换\r\n\r\nJavaScript 能够根据具体运算环境自动转换参与运算的值得类型。下面简单介绍常用值在不同运算环境中被自动转换的值列表。\r\n\r\n\r\n\r\n| 值（value）              | 字符串操作环境            | 数字运算环境                   | 逻辑运算环境 | 对象操作环境 |\r\n| ------------------------ | ------------------------- | ------------------------------ | ------------ | ------------ |\r\n| undefined                | \"undefined\"               | NaN                            | false        | Error        |\r\n| null                     | \"null\"                    | 0                              | false        | Error        |\r\n| 非空字符串               | 不转换                    | 字符串对应的数字值NaN          | true         | String       |\r\n| 空字符串                 | 不转换                    | 0                              | false        | String       |\r\n| 0                        | \"0\"                       | 不转换                         | false        | Number       |\r\n| NaN                      | \"NaN\"                     | 不转换                         | false        | Number       |\r\n| Infinity                 | \"Infinity\"                | 不转换                         | true         | Number       |\r\n| Number.POSITIVE_INFINITY | \"Infinity\"                | 不转换                         | true         | Number       |\r\n| Number.NEGATIVE_INFINITY | \"-Infinity\"               | 不转换                         | true         | Number       |\r\n| -Infinity                | \"-Infinity\"               | 不转换                         | true         | Number       |\r\n| Number.MAX_VALUE         | \"1.7976931348623157e+308\" | 不转换                         | true         | Number       |\r\n| Number.MIN_VALUE         | \"5e-324\"                  | 不转换                         | true         | Number       |\r\n| 其他所有数字             | \"数字的字符串值\"          | 不转换                         | true         | Number       |\r\n| true                     | \"true\"                    | 1                              | 不转换       | Boolean      |\r\n| false                    | \"false\"                   | 0                              | 不转换       | Boolean      |\r\n| 对象                     | toString()                | valueOf() 或 toString() 或 NaN | true         | 不转换       |","timestamp":1590329650947},{"name":"102-数组.md","path":"13-语言学习project/11-JavaScript/4-基础/102-数组.md","content":"#### 数组\r\n\r\n------\r\n\r\nJavaScript的`Array`可以包含任意数据类型，并通过索引来访问每个元素。\r\n\r\n要取得`Array`的长度，直接访问`length`属性：\r\n\r\n```JavaScript\r\nvar arr = [1, 2, 3.14, \'Hello\', null, true];\r\narr.length; // 6\r\n```\r\n\r\n*请注意*，直接给`Array`的`length`赋一个新的值会导致`Array`大小的变化：\r\n\r\n```JavaScript\r\nvar arr = [1, 2, 3];\r\narr.length; // 3\r\narr.length = 6;\r\narr; // arr变为[1, 2, 3, undefined, undefined, undefined]\r\narr.length = 2;\r\narr; // arr变为[1, 2]\r\n```\r\n\r\n`Array`可以通过索引把对应的元素修改为新的值，因此，对`Array`的索引进行赋值会直接修改这个`Array`：\r\n\r\n```JavaScript\r\nvar arr = [\'A\', \'B\', \'C\'];\r\narr[1] = 99;\r\narr; // arr现在变为[\'A\', 99, \'C\']\r\n```\r\n\r\n*请注意*，==如果通过索引赋值时，索引超过了范围，同样会引起`Array`大小的变化：==\r\n\r\n```JavaScript\r\nvar arr = [1, 2, 3];\r\narr[5] = \'x\';\r\narr; // arr变为[1, 2, 3, undefined, undefined, \'x\']\r\n```\r\n\r\n大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的`Array`却不会有任何错误。在编写代码时，==不建议直接修改`Array`的大小，访问索引时要确保索引不会越界。==\r\n\r\n### indexOf\r\n\r\n与String类似，`Array`也可以通过`indexOf()`来搜索一个指定的元素的位置：\r\n\r\n```JavaScript\r\nvar arr = [10, 20, \'30\', \'xyz\'];\r\narr.indexOf(10); // 元素10的索引为0\r\narr.indexOf(20); // 元素20的索引为1\r\narr.indexOf(30); // 元素30没有找到，返回-1\r\narr.indexOf(\'30\'); // 元素\'30\'的索引为2\r\n```\r\n\r\n注意了，数字`30`和字符串`\'30\'`是不同的元素。\r\n\r\n### slice\r\n\r\n`slice()`就是对应String的`substring()`版本，它截取`Array`的部分元素，然后返回一个新的`Array`：\r\n\r\n```JavaScript\r\nvar arr = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\'];\r\narr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [\'A\', \'B\', \'C\']\r\narr.slice(3); // 从索引3开始到结束: [\'D\', \'E\', \'F\', \'G\']\r\n```\r\n\r\n注意到`slice()`的起止参数==包括开始索引，不包括结束索引==。\r\n\r\n如果不给`slice()`传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个`Array`：\r\n\r\n```JavaScript\r\nvar arr = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\'];\r\nvar aCopy = arr.slice();\r\naCopy; // [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\']\r\naCopy === arr; // false\r\n```\r\n\r\n### push和pop\r\n\r\n`push()`向`Array`的末尾添加若干元素，`pop()`则把`Array`的最后一个元素删除掉：\r\n\r\n```JavaScript\r\nvar arr = [1, 2];\r\narr.push(\'A\', \'B\'); // 返回Array新的长度: 4\r\narr; // [1, 2, \'A\', \'B\']\r\narr.pop(); // pop()返回\'B\'\r\narr; // [1, 2, \'A\']\r\narr.pop(); arr.pop(); arr.pop(); // 连续pop 3次\r\narr; // []\r\narr.pop(); // 空数组继续pop不会报错，而是返回undefined\r\narr; // []\r\n```\r\n\r\n### unshift和shift\r\n\r\n如果要往`Array`的头部添加若干元素，使用`unshift()`方法，`shift()`方法则把`Array`的第一个元素删掉：\r\n\r\n```JavaScript\r\nvar arr = [1, 2];\r\narr.unshift(\'A\', \'B\'); // 返回Array新的长度: 4\r\narr; // [\'A\', \'B\', 1, 2]\r\narr.shift(); // \'A\'\r\narr; // [\'B\', 1, 2]\r\narr.shift(); arr.shift(); arr.shift(); // 连续shift 3次\r\narr; // []\r\narr.shift(); // 空数组继续shift不会报错，而是返回undefined\r\narr; // []\r\n```\r\n\r\n### sort\r\n\r\n`sort()`可以对当前`Array`进行排序，它会直接修改当前`Array`的元素位置，直接调用时，按照默认顺序排序：\r\n\r\n```JavaScript\r\nvar arr = [\'B\', \'C\', \'A\'];\r\narr.sort();\r\narr; // [\'A\', \'B\', \'C\']\r\n```\r\n\r\n能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。\r\n\r\n### reverse\r\n\r\n`reverse()`把整个`Array`的元素给掉个个，也就是反转：\r\n\r\n```JavaScript\r\nvar arr = [\'one\', \'two\', \'three\'];\r\narr.reverse(); \r\narr; // [\'three\', \'two\', \'one\']\r\n```\r\n\r\n### splice\r\n\r\n`splice()`方法是修改`Array`的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：\r\n\r\n```JavaScript\r\nvar arr = [\'Microsoft\', \'Apple\', \'Yahoo\', \'AOL\', \'Excite\', \'Oracle\'];\r\n// 从索引2开始删除3个元素,然后再添加两个元素:\r\narr.splice(2, 3, \'Google\', \'Facebook\'); // 返回删除的元素 [\'Yahoo\', \'AOL\', \'Excite\']\r\narr; // [\'Microsoft\', \'Apple\', \'Google\', \'Facebook\', \'Oracle\']\r\n// 只删除,不添加:\r\narr.splice(2, 2); // [\'Google\', \'Facebook\']\r\narr; // [\'Microsoft\', \'Apple\', \'Oracle\']\r\n// 只添加,不删除:\r\narr.splice(2, 0, \'Google\', \'Facebook\'); // 返回[],因为没有删除任何元素\r\narr; // [\'Microsoft\', \'Apple\', \'Google\', \'Facebook\', \'Oracle\']\r\n```\r\n\r\n### concat\r\n\r\n`concat()`方法把当前的`Array`和另一个`Array`连接起来，并返回一个新的`Array`：\r\n\r\n```JavaScript\r\nvar arr = [\'A\', \'B\', \'C\'];\r\nvar added = arr.concat([1, 2, 3]);\r\nadded; // [\'A\', \'B\', \'C\', 1, 2, 3]\r\narr; // [\'A\', \'B\', \'C\']\r\n```\r\n\r\n*请注意*，`concat()`方法并没有修改当前`Array`，而是返回了一个新的`Array`。\r\n\r\n实际上，`concat()`方法可以接收任意个元素和`Array`，并且自动把`Array`拆开，然后全部添加到新的`Array`里：\r\n\r\n```JavaScript\r\nvar arr = [\'A\', \'B\', \'C\'];\r\narr.concat(1, 2, [3, 4]); // [\'A\', \'B\', \'C\', 1, 2, 3, 4]\r\n```\r\n\r\n### join\r\n\r\n`join()`方法是一个非常实用的方法，它把当前`Array`的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：\r\n\r\n```JavaScript\r\nvar arr = [\'A\', \'B\', \'C\', 1, 2, 3];\r\narr.join(\'-\'); // \'A-B-C-1-2-3\'\r\n```\r\n\r\n如果`Array`的元素不是字符串，将自动转换为字符串后再连接。\r\n\r\n### 多维数组\r\n\r\n如果数组的某个元素又是一个`Array`，则可以形成多维数组，例如：\r\n\r\n```JavaScript\r\nvar arr = [[1, 2, 3], [400, 500, 600], \'-\'];\r\n```\r\n\r\n上述`Array`包含3个元素，其中头两个元素本身也是`Array`。","timestamp":1590329650947},{"name":"103-方法.md","path":"13-语言学习project/11-JavaScript/4-基础/103-方法.md","content":"#### 方法\r\n\r\n------\r\n\r\n在一个对象中绑定函数，称为这个对象的方法。\r\n\r\n在JavaScript中，对象的定义是这样的：\r\n\r\n```\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990\r\n};\r\n```\r\n\r\n但是，如果我们给`xiaoming`绑定一个函数，就可以做更多的事情。比如，写个`age()`方法，返回`xiaoming`的年龄：\r\n\r\n```JavaScript\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    age: function () {\r\n        var y = new Date().getFullYear();\r\n        return y - this.birth;\r\n    }\r\n};\r\n\r\nxiaoming.age; // function xiaoming.age()\r\nxiaoming.age(); // 今年调用是25,明年调用就变成26了\r\n```\r\n\r\n绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个`this`关键字，这个东东是什么？\r\n\r\n在一个方法内部，`this`是一个特殊变量，它始终指向当前对象，也就是`xiaoming`这个变量。所以，`this.birth`可以拿到`xiaoming`的`birth`属性。\r\n\r\n让我们拆开写：\r\n\r\n```JavaScript\r\nfunction getAge() {\r\n    var y = new Date().getFullYear();\r\n    return y - this.birth;\r\n}\r\n\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    age: getAge\r\n};\r\n\r\nxiaoming.age(); // 25, 正常结果\r\ngetAge(); // NaN\r\n```\r\n\r\n单独调用函数`getAge()`怎么返回了`NaN`？*请注意*，我们已经进入到了JavaScript的一个大坑里。\r\n\r\nJavaScript的函数内部如果调用了`this`，那么这个`this`到底指向谁？\r\n\r\n答案是，视情况而定！\r\n\r\n如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的`this`指向被调用的对象，也就是`xiaoming`，这是符合我们预期的。\r\n\r\n如果单独调用函数，比如`getAge()`，此时，该函数的`this`指向全局对象，也就是`window`。\r\n\r\n坑爹啊！\r\n\r\n更坑爹的是，如果这么写：\r\n\r\n```\r\nvar fn = xiaoming.age; // 先拿到xiaoming的age函数\r\nfn(); // NaN\r\n```\r\n\r\n==也是不行的！要保证`this`指向正确，必须用`obj.xxx()`的形式调用！==\r\n\r\n由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的`this`指向`undefined`，因此，在strict模式下，你会得到一个错误：\r\n\r\n```JavaScript\r\n\'use strict\';\r\n\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    age: function () {\r\n        var y = new Date().getFullYear();\r\n        return y - this.birth;\r\n    }\r\n};\r\n\r\nvar fn = xiaoming.age;\r\nfn(); // Uncaught TypeError: Cannot read property \'birth\' of undefined\r\n```\r\n\r\n这个决定只是让错误及时暴露出来，并没有解决`this`应该指向的正确位置。\r\n\r\n有些时候，喜欢重构的你把方法重构了一下：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    age: function () {\r\n        function getAgeFromBirth() {\r\n            var y = new Date().getFullYear();\r\n            return y - this.birth;\r\n        }\r\n        return getAgeFromBirth();\r\n    }\r\n};\r\n\r\nxiaoming.age(); // Uncaught TypeError: Cannot read property \'birth\' of undefined\r\n```\r\n\r\n结果又报错了！原因是`this`指针只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`又指向`undefined`了！（在非sJavaScripttrict模式下，它重新指向全局对象`window`！）\r\n\r\n修复的办法也不是没有，我们用一个`that`变量首先捕获`this`：\r\n\r\n```JavaScript\r\n\'use strict\';\r\n\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    age: function () {\r\n        var that = this; // 在方法内部一开始就捕获this\r\n        function getAgeFromBirth() {\r\n            var y = new Date().getFullYear();\r\n            return y - that.birth; // 用that而不是this\r\n        }\r\n        return getAgeFromBirth();\r\n    }\r\n};\r\n\r\nxiaoming.age(); // 25\r\n```\r\n\r\n用`var that = this;`，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。\r\n\r\n### apply\r\n\r\n虽然在一个独立的函数调用中，根据是否是strict模式，`this`指向`undefined`或`window`，不过，我们还是可以控制`this`的指向的！\r\n\r\n要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。\r\n\r\n用`apply`修复`getAge()`调用：\r\n\r\n```\r\nfunction getAge() {\r\n    var y = new Date().getFullYear();\r\n    return y - this.birth;\r\n}\r\n\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    age: getAge\r\n};\r\n\r\nxiaoming.age(); // 25\r\ngetAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空\r\n```\r\n\r\n另一个与`apply()`类似的方法是`call()`，唯一区别是：\r\n\r\n- `apply()`把参数打包成`Array`再传入；\r\n- `call()`把参数按顺序传入。\r\n\r\n比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：\r\n\r\n```\r\nMath.max.apply(null, [3, 5, 4]); // 5\r\nMath.max.call(null, 3, 5, 4); // 5\r\n```\r\n\r\n对普通函数调用，我们通常把`this`绑定为`null`。\r\n\r\n### 装饰器\r\n\r\n利用`apply()`，我们还可以动态改变函数的行为。\r\n\r\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。\r\n\r\n现在假定我们想统计一下代码一共调用了多少次`parseInt()`，可以把所有的调用都找出来，然后手动加上`count += 1`，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的`parseInt()`：\r\n\r\n`\'use strict\'; var count = 0; var oldParseInt = parseInt; // 保存原函数 window.parseInt = function () {    count += 1;    return oldParseInt.apply(null, arguments); // 调用原函数 }; ` Run","timestamp":1590329650947},{"name":"104-条件循环.md","path":"13-语言学习project/11-JavaScript/4-基础/104-条件循环.md","content":"#### 条件判断\r\n\r\n------\r\n\r\nJavaScript使用`if () { ... } else { ... }`来进行条件判断。==建议永远都要写上`{}`。==\r\n\r\n```JavaScript\r\nvar age = 20;\r\nif (age >= 18) {\r\n    alert(\'adult\');\r\n} else {\r\n    console.log(\'age < 18\');\r\n    alert(\'teenager\');\r\n}\r\n// 多行条件判断  如果还要更细致地判断条件，可以使用多个`if...else...`的组合：\r\nif (age >= 18) {\r\n    alert(\'adult\');\r\n} elseif (age >= 6) {\r\n    alert(\'teenager\');\r\n} else {\r\n    alert(\'kid\');\r\n}\r\n```\r\n\r\nJavaScript把`null`、`undefined`、`0`、`NaN`和空字符串`\'\'`视为`false`，其他值一概视为`true`，因此上述代码条件判断的结果是`true`。\r\n\r\n## 循环\r\n\r\n### for (i=1; i<=10000; i++)  已知循环的初始和结束条件时非常有用\r\n\r\n一种是==`for`循环==，通过初始条件、结束条件和递增条件来循环执行语句块：\r\n\r\n```JavaScript\r\nvar x = 0;\r\nvar i;\r\nfor (i=1; i<=10000; i++) {\r\n    x = x + i;\r\n}\r\nx; // 50005000\r\n//利用索引来遍历数组\r\nvar arr = [\'Apple\', \'Google\', \'Microsoft\'];\r\nvar i, x;\r\nfor (i=0; i<arr.length; i++) {\r\n    x = arr[i];\r\n    console.log(x);\r\n}\r\n//循环的==3个条件都是可以省略==的，如果没有退出循环的判断条件，就必须使用`break`语句退出循环，否则就是死循环：\r\nvar x = 0;\r\nfor (;;) { // 将无限循环下去\r\n    if (x > 100) {\r\n        break; // 通过if判断来退出循环\r\n    }\r\n    x ++;\r\n}\r\n```\r\n\r\n### for ... in\r\n\r\n`for`循环的一个变体是`for ... in`循环，它可以把一个对象的所有属性==依次循环出来==：\r\n\r\n```javascript\r\nvar o = {\r\n    name: \'Jack\',\r\n    age: 20,\r\n    city: \'Beijing\'\r\n};\r\nfor (var key in o) {\r\n    if (o.hasOwnProperty(key)) //要过滤掉==对象继承的属性==，用`hasOwnProperty()`来实现：\r\n    {\r\n        console.log(key); // \'name\', \'age\', \'city\'\r\n    }\r\n}\r\n\r\n//请注意*，`for ... in`对`Array`的循环得到的是==String==而不是`Number`。\r\nvar a = [\'A\', \'B\', \'C\'];\r\nfor (var i in a) {\r\n    console.log(i); // \'0\', \'1\', \'2\'\r\n    console.log(a[i]); // \'A\', \'B\', \'C\'\r\n}\r\n```\r\n\r\n### while\r\n\r\n`while`循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\r\n\r\n```javascript\r\nvar x = 0;\r\nvar n = 99;\r\nwhile (n > 0) {\r\n    x = x + n;\r\n    n = n - 2;\r\n}\r\nx; // 2500\r\n```\r\n\r\n### do ... while\r\n\r\n最后一种循环是`do { ... } while()`循环，它和`while`循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是==在每次循环完成的时候判断条件==：\r\n\r\n```javascript\r\nvar n = 0;\r\ndo {\r\n    n = n + 1;\r\n} while (n < 100);\r\nn; // 100\r\n```","timestamp":1590329650947},{"name":"105-空白符.md","path":"13-语言学习project/11-JavaScript/4-基础/105-空白符.md","content":"# JavaScript空白符（分隔符）\r\n\r\n分隔符（空白符）就是各种不可见字符的集合，如==空格（\\u0020）、水平制表符（\\u0009）、垂直制表符（\\u000B）、换页符（\\u000C）、不中断空白（\\u00A0）、字节序标记（\\uFEFF）、换行符（\\u000A）、 回车符（\\u000D）、行分隔符（\\u2028）、段分隔符（\\u2029）==等。\r\n\r\n在 [JavaScript](http://c.biancheng.net/js/) 中，==分隔符不被解析，主要用来分隔各种记号==，如标识符、关键字、直接量等信息。 在 [Java](http://c.biancheng.net/java/)Script 脚本中，常用分隔符来==格式化代码，以方便阅读==。\r\n\r\n#### 示例1\r\n\r\n对于下面一行代码：\r\n\r\n```JavaScript\r\nfunction toStr(a){return a.toString();}\r\n```\r\n\r\n\r\n可以使用分隔符格式化显示：\r\n\r\n```JavaScript\r\nfunction toStr(a){  return a.toString();}\r\n```\r\n\r\n\r\n一般 JavaScript 编辑器都会提供代码格式化的功能。\r\n\r\n分隔符使用时需要注意以下几点：\r\n1) 分隔符虽然无实际意义，但是在脚本中却不能缺少。如果在标识符与关键字之间不使用分隔符分隔，JavaScript 就会抛出异常。\r\n\r\n#### 示例2\r\n\r\n在下面代码中，把关键字 function 与标识符 toStr 连在一起，以及把关键字 return 与 toString 标识符连在一起都是错误的。\r\n\r\n```JavaScript\r\nfunctiontoStr(a){returna.toString();}  //错误写法function toStr(a){return a.toString();}  //正确写法\r\n```\r\n\r\n\r\n2) JavaScript 解析器一般采用最长行匹配原则，不恰当地换行显示一句代码，容易引发异常或错误。\r\n\r\n#### 示例3\r\n\r\n下面代码会返回意外的结果。\r\n\r\n```JavaScript\r\nfunction toStr(a){    return     a.toString();  //错误的换行}document.write(toStr(\"abc\"));  //实际返回 undefined,应该返回\"abc\"\r\n```\r\n\r\n\r\n这是因为 return 作为一条独立语句，JavaScript 解析器可以正确解析它，虽然它后面没有分号，解析器在正确解析的前提下会自动为其补加一个分号，以表示该句已经结束。这样换行显示的 a.toString()；就是下一句待执行的命令，而不是被返回的值。\r\n\r\n3) 不能在标识符、关键字等内部使用分隔符。\r\n\r\n#### 示例4\r\n\r\n在下面函数中使用空格把 toString() 分为两部分，JavaScript 会因无法识别而抛出异常。\r\n\r\n```JavaScript\r\nfunction toStr(a){  return a.to String();  //错误分隔符}\r\n```\r\n\r\n\r\n4) 在字符串或者正则表达式内，分隔符是有意义的，不能够随意省略或替换。\r\n\r\n#### 示例5\r\n\r\n在下面代码中，变量 a 和 b 被赋予相同的字符串，但是变量 b 中插入了空格，则比较结果是不相等的。\r\n\r\n```JavaScript\r\nvar a = \"空格\";\r\nvar b = \"空格 \";\r\ndocument.write((a==b));  //返回 false,说明不相同\r\n```","timestamp":1590329650947},{"name":"106-类型检测.md","path":"13-语言学习project/11-JavaScript/4-基础/106-类型检测.md","content":"# JS判断类型（typeof+constructor+toString）\r\n\r\n使用 ==typeof== 运算符可以判断基本数据类型，我们在《[JavaScript基本数据类型](http://c.biancheng.net/view/5430.html)》中已经进行了演示，这里不再赘述。\r\n\r\n但是 typeof 有很多局限性，所以本节再介绍两种更灵活的方法，以应对高级开发可能遇到的各种复杂情况。\r\n\r\n## 使用 constructor\r\n\r\nconstructor 是 Object 类型的原型属性，它能够返回当前对象的构造器（类型函数）。利用该属性，可以检测复合型数据的类型，如对象、数组和函数等。\r\n\r\n下面代码可以检测对象和数组的类型，以此可以过滤对象、数组。\r\n\r\n```JavaScript\r\nvar o = {};\r\nvar a =[];\r\nif (o.constructor == Object) document.write(\"o 是对象\");\r\nif (a.constructor == Array) document.write(\"a 是数组\");\r\n```\r\n\r\n\r\n结合 typeof 运算符和 constructor 原型属性，可以检测不同类型的数据。表中列举了常用类型数据的检测结果。\r\n\r\n| 值（value）                                          | typeof value（表达式返回值） | value.constructor（构造函数的属性值） |\r\n| ---------------------------------------------------- | ---------------------------- | ------------------------------------- |\r\n| var value = 1                                        | \"number\"                     | Number                                |\r\n| var value = \"a\"                                      | \"string\"                     | String                                |\r\n| var value = true                                     | \"boolean\"                    | Boolean                               |\r\n| var value = {}                                       | \"object\"                     | Object                                |\r\n| var value = new Object()                             | \"object\"                     | Object                                |\r\n| var value = []                                       | \"object\"                     | Object                                |\r\n| var value = new Array()                              | \"object\"                     | Object                                |\r\n| var value = function(){}                             | \"function\"                   | Function                              |\r\n| function className(){}; var value = new className(); | \"object\"                     | Object                                |\r\n\r\n#### 示例2\r\n\r\nundefined 和 null 没有 constructor 属性，不能够直接读取，否则会抛出异常。因此，一般应先检测值是否为 undefined 和 null 等特殊值，然后再调用 constructor 属性。\r\n\r\n```JavaScript\r\nvar value = undefined;console.log(value && value.constructor);  //返回 undefinedvar value = null;console.log(value && value.constructor);  //返回 null\r\n```\r\n\r\n\r\n数值直接量也不能直接读取 constructor 属性，应该先把它转换为对象再调用。\r\n\r\n```JavaScript\r\nconsole.log(10.construetor);  //抛出异常console.log((10).constructor);  //返回 Number 类型console.log(Number(10).constructor);  //返回 Number 类型\r\n```\r\n\r\n## 使用 toString\r\n\r\ntoString 是 Object 类型的原型方法，它能够返回当前对象的字符串表示。利用该属性，可以检测复合型数据的类型，如对象、数组、函数、正则表达式、错误对象、宿主对象、自定义类型对象等；也可以对值类型数据进行检测。\r\n\r\n下面示例简单演示 toString() 方法的使用。\r\n\r\n```JavaScript\r\nvar o = {}; //对象\r\nvar a = [1,2]; //数组\r\nvar f = function(){}; //函数\r\nconsole.log(o.toString()); //表示为 \"[object Object]\"\r\nconsole.log(a.toString()); //表示为 \"1,2\"\r\nconsole.log(f.toString()); //表示为 \"function (){}\"\r\n```\r\n\r\n\r\n测试发现，不同类型对象调用 toString() 方法时返回的字符串格式并不统一，这是因为不同类型的子类在继承 Object 的原型方法 toString，时重写了该方法。如果在对象上==调用 Object 的原型方法 toString()，就会返回统一格式的字符串表示==。例如：\r\n\r\n```JavaScript\r\nvar _toString = Object.prototype.toString;  //引用 Objget 的原型方法 toString ()\r\n//使用 apply 方法在对象上动态调用 Object 的原型方法 toString ()\r\nconsole.log(_toString.apply(o));  //表示为 \"[object Object]\"\r\nconsole.log(_toString.apply(a));  //表示为 \"[object Array]\"\r\nconsole.log(_toString.apply(f));  //表示为 \"[object Function]\"\r\n```\r\n\r\n重写 toString() 方法，利用其返回的数据类型的字符串表示，可以设计一种更安全、更强健的类型检测方法，而且用户可以扩展检测类型的范围，如==用户自定义类型、宿主类型==等。\r\n\r\n#### 设计思路\r\n\r\n首先，仔细分析不同类型对象的 toString() 方法返回值，会发现由 Object 的原型方法 toString() 直接返回的字符串格式如下：\r\n\r\n[object Class]\r\n\r\n其中，object 表示对象的基本类型，Class 表示对象的子类型，子类型的名称与该对象的构造函数名对应。例如，Object 对象的 Class 为 \"Object\"，Array 对象的 Class 为 \"Array\" , Function 对象的 Class 为 \"Function\", Date 对象的 Class 为 \"Date\"，Math 对象的 Class 为 \"Math\"，Error 对象（包括 Error 子类）的 Class 为 \"Error\" 等。\r\n\r\n宿主对象也有==预定义的 Class 值==，如 \"Window\" \"Document\" 和 \"Form\" 等。用户自定义对象的 Class 为 \"Object\"。用户自定义的类型，可以根据该格式自定义类型表示。\r\n\r\nClass 值提供的信息与 constructor 属性值都能够检测数据类型，但是 Class 值是以字符串的形式提供这些信息，这在开发环境中是非常有用的。而使用 typeof 运算符进行类型检测，由于其返回的字符串表示比较有限，无法准确分辨 Object、Function 和 Array 等类型。\r\n\r\n#### 实现代码\r\n\r\n下面是比较完整==的数据类型检测函数==。\r\n\r\n```JavaScript\r\n//强健的数据类型检测工具函数\r\n//参数：obj 表示待检测的值\r\n//返回值：返回字符串表示，格式与 typeof 运算符相同，\r\n//\"undefined\" \"number\" \"boolean\" \"string\" \"function\"\r\n//\"regexp\" \"array\" \"date\" \"error\" \"object\"或 \"null\"\r\nfunction typeOf(obj){\r\n  var _toString = Object.prototype.toString; //引用 Object 的原型方法 toString () //列奉所有可能的类型字符串表示\r\n  //模仿typeof运算符返回值，通过映射，统一字符串表示的值 \r\n  var _type ={\r\n    \"undefined\" : \"undefined\",\r\n    \"number\" : \"number\",\r\n    \"boolean\" : \"boolean\",\r\n    \"string\" : \"string\",\r\n    \"[object Function]\" : \"function0f\",\r\n    \"[object RegExp]\" : \"regexp\",\r\n    \"[object Array] \" : \"array\",\r\n    \"[object Date]\" : \"date\",\r\n    \"[object Error]\" : \"error\"\r\n    //在这里可以继续展开要检测的类型\r\n  }\r\n//把值转换为字符串表示，然后匹配 _type 对象中的键值对，最后处理特殊值 null\r\nreturn _type[typeof obj] || _type[_toString.call(obj)] || (obj ? \"object\" :\"null\");\r\n} \r\n```\r\n\r\n\r\n在上面检测函数中，先引用 Object 的原型方法 toString()，然后列举出所有可能存在的数据类型，把不同形式的字符串表示通过对象的键值对映射进行统一，模拟 typeof 运算符的返回值格式，设计所有类型返回的字符串表示都以小写的单个词来表示。接着使用 typeof 运算符或者 toString() 原型方法获取类型的字符串表示，再通过对象映射获得统一的字符串表示并返回。最后，单独处理特殊值 null，定义其返回值为\"null\"；对于不能映射的类型，则统一返回根类型表示\"object\"。\r\n\r\n#### 应用代码\r\n\r\n```JavaScript\r\nvar _abs = Math.abs;  //引用 Math 对象的 Abs 方法\r\nconsole.log(typeOf(_abs));  //返回字符串表示 \"function”\r\n  //说明该方法为一个 Function 类型\r\n```\r\n\r\n上述方法适用于 [JavaScript](http://c.biancheng.net/js/) 基本类型和内置对象，如果要==检测宿主对象和自定义类型==，则需要用户==添加 _type 对象==的键值对，以扩展类型检测的范围。","timestamp":1590329650947},{"name":"107-编码.md","path":"13-语言学习project/11-JavaScript/4-基础/107-编码.md","content":"# JS Unicode编码和解码（6种方法）\r\n\r\n\r\n\r\n[C语言中文网推出辅导班啦，包括「C语言辅导班、C++辅导班、算法/数据结构辅导班」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！](http://fudao.biancheng.net/)\r\n\r\n[JavaScript](http://c.biancheng.net/js/) 定义了 6 个全局方法用于 Unicode 字符串的编码和解码，说明如表所示。\r\n\r\n\r\n\r\n| 方法                   | 说明                                                 |\r\n| ---------------------- | ---------------------------------------------------- |\r\n| escape()               | 使用转义序列替换某些字符来对字符串进行编码           |\r\n| unescape()             | 对使用 escape() 编码的字符串进行解码                 |\r\n| encodeURI()            | 通过转义某些字符对 URI 进行编码                      |\r\n| decodeURI()            | 对使用 encodeURI() 方法编码的字符串进行解码          |\r\n| encodeURIComponent()   | 通过某些转义字符对 URI 的组件进行编码                |\r\n| deencodeURIComponent() | 对使用 encodeURIComponent() 方法编码的字符串进行解码 |\r\n\r\n## escape()和unescape()方法\r\n\r\nescape() 方法能够把 ASCII 之外的所有字符转换为 %xx 或 %uxxxx（x表示十六进制的数字）的转义序列。从 \\u000 到 \\u00ff 的 Unicode 字符由转义序列 %xx 替代，其他所有 Unicode 字符由 %uxxxx 序列替代。\r\n\r\n#### 示例1\r\n\r\n```\r\nvar s = \"JavaScript 中国\";s = escape(s);console.log(s);  //返回字符串“JavaScript%u4E2D%u56FD”\r\n```\r\n\r\n可以使用该方法对 Cookie 字符串进行编码，以避免与其他约定字符发生冲突，因为 Cookie 包含的标点符号是有限制的。\r\n\r\n与 escape() 方法对应，unescape() 方法能够对 escape() 编码的字符串进行解码。\r\n\r\n#### 示例2\r\n\r\n下面代码使用 unescape() 方法解码被 escape() 方法解码的字符串。\r\n\r\n```\r\nvar s = \"JavaScript 中国\";s = escape(s);  //Unicode编码console.log(s);  //返回字符串“JavaScript%u4E2D%u56FD”s = unescape(s);  //Unicode解码console.log(s);  //返回字符串“JavaScript 中国”\r\n```\r\n\r\n#### 示例3\r\n\r\n这种被解码的代码是不能够直接运行的，同学们可以使用 eval() 方法来执行它。\r\n\r\n```\r\nvar s = escape(\'console/log(\"JavaScript 中国\");\');  //编码脚本var s = unescape(s);  //解码脚本eval(s);  //执行被解码的脚本\r\n```\r\n\r\n## encodeURI() 和 decodeURI() 方法\r\n\r\nECMAScript v3.0 版本推荐使用 encodeURI() 和 encodeURIComponent() 方法代替 escape() 方法，使用 decodeURI() 和 decodeURIComponent() 方法代替 unescape() 方法。\r\n\r\n#### 示例4\r\n\r\nencodeURI() 方法能够把 URI 字符串进行转移处理。\r\n\r\n```\r\nvar s = \"JavaScript 中国\";s = encodeURI(s);console.log(s);  //返回字符串“JavaScript%E4%B8%AD%E5%9B%BD”\r\n```\r\n\r\nencodeURI() 方法与 escape() 方法的编码结果是不同的，但是它们都不会编码 ASCII 字符。\r\n\r\n相对而言，encodeURI() 方法更佳安全。它能够将字符转换为 UTF-8 编码字符，然后用十六进制的转义序列（形式为%xx）对生成的 1 字节、2 字节或 4 字节的字符进行编码。\r\n\r\n使用 decodeURI() 方法可以对 encodeURI() 方法的结果进行解码。\r\n\r\n#### 示例5\r\n\r\n下面代码演示了如何对 URL 字符串进行编码和解码操作。\r\n\r\n```\r\nvar s = \"JavaScript 中国\";s = encodeURI(s);  //URI编码console.log(s);  //返回字符串“JavaScript%E4%B8%AD%E5%9B%BD”s = decodeURI(s);  //URI解码console.log(s);  //返回字符串“JavaScript 中国”\r\n```\r\n\r\n## encodeURICompoent() 和 decodeURICompoent()\r\n\r\nencodeURICompoent() 与 encodeURI() 方法不同。它们的主要区别在于，encodeURICompoent() 方法假定参数是 URI 的一部分，例如，协议、主机名、路径或查询字符串。因此，它将转义用于分隔 URI 各个部分的标点符号。而 encodeURI() 方法仅把它们视为普通的 ASCII 字符，并没有转换。\r\n\r\n#### 示例6\r\n\r\n下面代码是 URL 字符串被 encodeURICompoent() 方法编码前后的比较。\r\n\r\n```\r\nvar s = \"c.biancheng.net/navi/search.asp?keyword=URI\";a = encodeURI(s);console.log(a);b = encodeURICompoent(s);console.log(b);\r\n```\r\n\r\n输出显示为：\r\nc.biancheng.net/navi/search.asp?keyword=URI\r\nc.biancheng.net%2Fnavi%2Fsearch.asp%3Fkeyword%3DURI\r\n\r\n第一行字符串是 encodeURI() 方法编码的结果，第二行字符串是 encodeURICompoent() 方法编码的结果。与 encodeURI() 方法一样，encodeURICompoent() 方法对于 ASCII 字符不编码，用于 分隔 URI 各种组件的标点符号，都由一个或多个十六进制的转义序列替换。\r\n\r\n使用 decodeURICompoent() 方法可以对 encodeURICompoent() 方法编码的结果进行解码。\r\n\r\n```\r\n纯文本复制\r\nvar s = \"c.biancheng.net/navi/search.asp?keyword=URI\";b = encodeURICompoent(s);b = decodeURICompoent(b);console.log(b);\r\n```\r\n\r\n# JS Base64编码和解码\r\n\r\n\r\n\r\n[C语言中文网推出辅导班啦，包括「C语言辅导班、C++辅导班、算法/数据结构辅导班」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！](http://fudao.biancheng.net/)\r\n\r\nBase64 是一种编码方式，可以将任意字符（包括二进制字符流）转成可打印字符。[JavaScript](http://c.biancheng.net/js/) 定义了两个与 Base64 相关的全局方法。\r\n\r\n- btoa()：字符串或二进制值转为 Base64 编码。\r\n- atob()：把 Base64 编码转为原来的字符。\r\n\r\n\r\nBase64 方法不能够操作非 ASCII 字符。\r\n\r\n#### 示例\r\n\r\n要将非 ASCII 码字符转为 Base64 编码，必须使用上一节介绍的方法把 Unicode 双字节字符串转换为 ASCII 字符表示，再使用这两个方法。\r\n\r\n```\r\nfunction b64Encode (str) {    return btoa(encodeURIComponent(str));}function b64Decode (str) {    return decodeURIComponent(atob(str));}var b = b64Encode(\'JavaScript 从入门到精通\');var a = b64Decode(b);console.log(b);  //返回SmF2YVNjcmlwdCVFNCVCQiU4RSVFNSU4NSVBNFOSU5NyVBOCVFNSU4OCVCMCVFNyVCMiVCRSVFOSU4MCU5QQ==console.log(a);  //返回“JavaScript 从入门到精通”\r\n```\r\n\r\n# JS在接收表单数据时过滤特殊字符\r\n\r\n\r\n\r\n[C语言中文网推出辅导班啦，包括「C语言辅导班、C++辅导班、算法/数据结构辅导班」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！](http://fudao.biancheng.net/)\r\n\r\n在接收表单数据时，经常需要检测特殊字符，过滤敏感词汇。本例为 String 扩展一个原型方法 filter()，用来检测字符串中是否包含指定的特殊字符。\r\n\r\n定义 filter() 的参数为任意长度和个数的特殊字符列表，检测的返回结果为布尔值。如果检测到任意指定的特殊字符，则返回 true，否则返回 false。\r\n\r\n```\r\n//检测特殊字符，蚕食为特殊字符列表，返回true表示存在，否则不存在String.prototype.filter = function () {    if (arguments.length < 1) throw new Error(\"缺少参数\");  //如果没有参数，则抛出异常    var a = [], _this = this;  //定义空数组，把字符串存储在内部变量中    for (var i = 0; i <arguments.length; i ++) {  //遍历参数，把参数列表转换为数组        a.push(arguments[i]);   //把每个参数值推入数组    }    var i = -1;  //初始化临时变量为-1    a.forEach(function(key) {  //迭代数组，检测字符串中是否包含特殊字符        if (i != -1) return true;  //如果临时变量不等于-1，提前返回true        i = _this.indexOf(key);  //检索到字符串下标位置    });    if(i == -1) {  //如果i等于-1，返回false，说明没有检测到特殊字符        return false;    } else {  //如果i不等于-1，返回true，说明检测到特殊字符        return true;    }}\r\n```\r\n\r\n\r\n下面应用 String 类型的扩展方法 check() 来检测字符串中是否包含特殊字符尖角号，以判断字符串中是否存在 HTML 标签。\r\n\r\n```\r\nvar s = \'<script language=\"javascript\" type=\"text/javascript\">\';  //定义字符串直接量var b = s.filter(\"<\",\">\");  //调用String扩展方法，检测字符串console.log(b);  //返回true，说明存在 \"<\"或\">\" ，即存在标签\r\n```\r\n\r\n由于 Array 的原型方法 forEach() 能够多层迭代数组，，所以可以以数组的形式传递参数。\r\n\r\n```\r\nvar s = \'<script language=\"javascript\" type=\"text/javascript\">\';var a = [\"<\", \">\", \"\\\"\",\"\\\'\",\"\\/\",\"\\;\",\"\\|\"];var b = s.check(a);console.log(b);\r\n```\r\n\r\n把特殊字符存储在数组中，这样更方便管理和引用。","timestamp":1590329650947},{"name":"108-转义字符.md","path":"13-语言学习project/11-JavaScript/4-基础/108-转义字符.md","content":"## 转义字符\r\n\r\n| 序列   | 代表字符                                                     |\r\n| ------ | ------------------------------------------------------------ |\r\n| \\0     | Null字符（\\u0000）                                           |\r\n| \\b     | 退格符（\\u0008）                                             |\r\n| \\t     | 水平制表符（\\u0009）                                         |\r\n| \\n     | 换行符（\\u000A）                                             |\r\n| \\v     | 垂直制表符（\\u000B）                                         |\r\n| \\f     | 换页符（\\u000C）                                             |\r\n| \\r     | 回车符（\\u000D）                                             |\r\n| \\\"     | 双引号（\\u0022）                                             |\r\n| \\\'     | 撇号或单引号（\\u0027）                                       |\r\n| \\\\     | 反斜杠（\\u005C）                                             |\r\n| \\xXX   | 由 2 位十六进制数值 XX 指定的 Latin-1 字符                   |\r\n| \\uXXXX | 由 4 位十六进制数值 XXXX 指定的 Unicode 字符                 |\r\n| \\XXX   | 由 1~3 位八进制数值（000 到 377）指定的 Latin-1 字符，可表示 256个 字符。如 \\251 表示版本符号。注意，ECMAScript 3.0 不支持，考虑到兼容性不建议使用。 |\r\n\r\n#### 提示：\r\n\r\n如果在一个正常字符前添加反斜杠，JavaScript 会忽略该反斜杠。例如：\r\n\r\n```\r\n纯文本复制\r\ndocument.write (\"子曰：\\\"学\\而\\不\\思\\则\\罔\\, \\思\\而\\不\\学\\则\\殆\\。\\\"\")\r\n```\r\n\r\n等价于：\r\n\r\n```\r\n纯文本复制\r\ndocument.write(\"子曰：\\\"学而不思则罔，思而不学则殆。\\\"\")\r\n```","timestamp":1590329650947},{"name":"109-运算符.md","path":"13-语言学习project/11-JavaScript/4-基础/109-运算符.md","content":"# JS赋值运算符详解\r\n\r\n\r\n\r\n[C语言中文网推出辅导班啦，包括「C语言辅导班、C++辅导班、算法/数据结构辅导班」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！](http://fudao.biancheng.net/)\r\n\r\n赋值运算符左侧的操作数必须是变量、对象属性或数组元素，也称为左值。例如，下面的写法是错误的，因为左侧的值是一个固定的值，不允许操作。\r\n\r\n```\r\n1 = 100;  //返回错误\r\n```\r\n\r\n\r\n赋值运算有以下两种形式：\r\n\r\n- 简单的赋值运算`=`：把等号右侧操作数的值直接复制给左侧的操作数，因此左侧操作数的值会发生变化。\r\n- 附加操作的赋值运算：赋值之前先对右侧操作数执行某种操作，然后把运算结果复制给左侧操作数。具体说明如表所示。\r\n\r\n\r\n\r\n| 赋值运算符 | 说明                     | 示例     | 等效于      |\r\n| ---------- | ------------------------ | -------- | ----------- |\r\n| +=         | 加法运算或连接操作并赋值 | a += b   | a = a + b   |\r\n| -=         | 减法运算并赋值           | a -= b   | a= a - b    |\r\n| *=         | 乘法运算并赋值           | a *= b   | a = a * b   |\r\n| /=         | 除法运算并赋值           | a /= b   | a = a / b   |\r\n| %=         | 取模运算并赋值           | a %= b   | a = a % b   |\r\n| <<=        | 左移位运算并赋值         | a <<= b  | a = a << b  |\r\n| >>=        | 右移位运算并赋值         | a >>= b  | a = a >> b  |\r\n| >>>=       | 无符号右移位运算并赋值位 | a >>>= b | a = a >>> b |\r\n| &=         | 位与运算并赋值           | a &= b   | a = a & b   |\r\n| \\|=        | 位或运算并赋值           | a \\|= b  | a = a \\|= b |\r\n| ^=         | 位异或运算并赋值         | a ^= b   | a = a ^ b   |\r\n\r\n#### 示例1\r\n\r\n使用赋值运算符设计复杂的连续赋值表达式。\r\n\r\n```\r\nvar a = b = c = d = e = f = 100;  //连续赋值//在条件语句的小括号内进行连续赋值for((a = b = 1;a < 5;a++) {console.log(a + \"\" + b)};)\r\n```\r\n\r\n赋值运算的结合性是从右向左，最右侧的赋值运算先执行，然后再向左赋值，以此类推，所以连续赋值运算不会引发异常。\r\n\r\n#### 示例2\r\n\r\n在下面表达式中，逻辑与左侧的操作数是一个赋值表达式，右侧的操作数也是一个赋值表达式。但是左侧赋的值是一个简单值，右侧是把一个函数赋值给变量b。\r\n\r\n```\r\nvar a;console.log(a = 6 && (b = function(){        return a;    })());\r\n```\r\n\r\n在逻辑与运算中，左侧的赋值并没有真正的复制给变量 a，当逻辑与运算执行右侧的表达式时，该表达式是把一个函数赋值给变量 b，然后利用小括号运算符调用这个函数，返回变量 a 的值，结果并没有返回变量 a 的值 6，而是 undefined。\r\n\r\n由于赋值运算作为表达式使用具有副作用，使用时要慎重，确保不会引发风险。对上面的表达式更安全的写法如下：\r\n\r\n```\r\nvar a = 6;  //定义并初始化变量ab = function () {  //定义函数对象b    return a;}console.log(a && b());  //逻辑与运算，根据a决定是否调用函数b\r\n```","timestamp":1590329650947},{"name":"110-高阶函数.md","path":"13-语言学习project/11-JavaScript/4-基础/110-高阶函数.md","content":"#### 高阶函数\r\n\r\n阅读: 3267348\r\n\r\n------\r\n\r\n高阶函数英文叫Higher-order function。那么什么是高阶函数？\r\n\r\nJavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\r\n\r\n一个最简单的高阶函数：\r\n\r\n```\r\nfunction add(x, y, f) {\r\n    return f(x) + f(y);\r\n}\r\n```\r\n\r\n当我们调用`add(-5, 6, Math.abs)`时，参数`x`，`y`和`f`分别接收`-5`，`6`和函数`Math.abs`，根据函数定义，我们可以推导计算过程为：\r\n\r\n```\r\nx = -5;\r\ny = 6;\r\nf = Math.abs;\r\nf(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;\r\nreturn 11;\r\n```\r\n\r\n用代码验证一下：\r\n\r\n`\'use strict\'; function add(x, y, f) {    return f(x) + f(y); } ` Run\r\n\r\n编写高阶函数，就是让==函数的参数能够接收别的函数==。","timestamp":1590329650947},{"name":"90-array.md","path":"13-语言学习project/11-JavaScript/4-基础/90-array.md","content":"#### Array\r\n\r\n阅读: 945091\r\n\r\n------\r\n\r\n对于数组，除了`map()`、`reduce`、`filter()`、`sort()`这些方法可以传入一个函数外，`Array`对象还提供了很多非常实用的高阶函数。\r\n\r\n### every\r\n\r\n`every()`方法可以判断数组的所有元素是否满足测试条件。\r\n\r\n例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n```\r\nvar arr = [\'Apple\', \'pear\', \'orange\'];\r\nconsole.log(arr.every(function (s) {\r\n    return s.length > 0;\r\n})); // true, 因为每个元素都满足s.length>0\r\n\r\nconsole.log(arr.every(function (s) {\r\n    return s.toLowerCase() === s;\r\n})); // false, 因为不是每个元素都全部是小写\r\n```\r\n\r\n\r\n\r\n### find\r\n\r\n`find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n```\r\nvar arr = [\'Apple\', \'pear\', \'orange\'];\r\nconsole.log(arr.find(function (s) {\r\n    return s.toLowerCase() === s;\r\n})); // \'pear\', 因为pear全部是小写\r\n\r\nconsole.log(arr.find(function (s) {\r\n    return s.toUpperCase() === s;\r\n})); // undefined, 因为没有全部是大写的元素\r\n```\r\n\r\n\r\n\r\n### findIndex\r\n\r\n`findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n```\r\nvar arr = [\'Apple\', \'pear\', \'orange\'];\r\nconsole.log(arr.findIndex(function (s) {\r\n    return s.toLowerCase() === s;\r\n})); // 1, 因为\'pear\'的索引是1\r\n\r\nconsole.log(arr.findIndex(function (s) {\r\n    return s.toUpperCase() === s;\r\n})); // -1\r\n\r\n```\r\n\r\n### forEach\r\n\r\n`forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n```\r\nvar arr = [\'Apple\', \'pear\', \'orange\'];\r\narr.forEach(console.log); // 依次打印每个元素\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"91-filter.md","path":"13-语言学习project/11-JavaScript/4-基础/91-filter.md","content":"#### filter\r\n\r\n阅读: 2114024\r\n\r\n------\r\n\r\nfilter也是一个常用的操作，它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。\r\n\r\n和`map()`类似，`Array`的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\r\n\r\n例如，在一个`Array`中，删掉偶数，只保留奇数，可以这么写：\r\n\r\n```\r\nvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\r\nvar r = arr.filter(function (x) {\r\n    return x % 2 !== 0;\r\n});\r\nr; // [1, 5, 9, 15]\r\n```\r\n\r\n把一个`Array`中的空字符串删掉，可以这么写：\r\n\r\n```\r\nvar arr = [\'A\', \'\', \'B\', null, undefined, \'C\', \'  \'];\r\nvar r = arr.filter(function (s) {\r\n    return s && s.trim(); // 注意：IE9以下的版本没有trim()方法\r\n});\r\nr; // [\'A\', \'B\', \'C\']\r\n```\r\n\r\n可见用`filter()`这个高阶函数，关键在于正确实现一个“筛选”函数。\r\n\r\n### 回调函数\r\n\r\n`filter()`接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示`Array`的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：\r\n\r\n```\r\nvar arr = [\'A\', \'B\', \'C\'];\r\nvar r = arr.filter(function (element, index, self) {\r\n    console.log(element); // 依次打印\'A\', \'B\', \'C\'\r\n    console.log(index); // 依次打印0, 1, 2\r\n    console.log(self); // self就是变量arr\r\n    return true;\r\n});\r\n```\r\n\r\n利用`filter`，可以巧妙地去除`Array`的重复元素：\r\n\r\n`\'use strict\'; var    r,    arr = [\'apple\', \'strawberry\', \'banana\', \'pear\', \'apple\', \'orange\', \'orange\', \'strawberry\']; ``console.log(r.toString()); ` Run\r\n\r\n去除重复元素依靠的是`indexOf`总是返回第一个元素的位置，后续的重复元素位置与`indexOf`返回的位置不相等，因此被`filter`滤掉了。\r\n\r\n### 练习\r\n\r\n请尝试用`filter()`筛选出素数：\r\n\r\n```\r\n\'use strict\'; function get_primes(arr) { ``} // 测试: var    x,    r,    arr = []; for (x = 1; x < 100; x++) {    arr.push(x); } r = get_primes(arr); if (r.toString() === [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97].toString()) {    console.log(\'测试通过!\'); } else {    console.log(\'测试失败: \' + r.toString()); }\r\n```","timestamp":1590329650947},{"name":"92-iterable.md","path":"13-语言学习project/11-JavaScript/4-基础/92-iterable.md","content":"#### iterable\r\n\r\n------\r\n\r\n遍历`Array`可以==采用下标循环==，遍历`Map`和`Set`就无法使用下标。为了统一集合类型，ES6标准引入了新的`iterable`类型，`Array`、`Map`和`Set`都属于`iterable`类型。\r\n\r\n具有`iterable`类型的集合可以通过新的`for ... of`循环来遍历。\r\n\r\n`for ... of`循环是ES6引入的新的语法，请测试你的浏览器是否支持：\r\n\r\n`\'use strict\'; var a = [1, 2, 3]; for (var x of a) { } console.log(\'你的浏览器支持for ... of\'); ` Run\r\n\r\n用`for ... of`循环遍历集合，用法如下：\r\n\r\n```JavaScript\r\nvar a = [\'A\', \'B\', \'C\'];\r\nvar s = new Set([\'A\', \'B\', \'C\']);\r\nvar m = new Map([[1, \'x\'], [2, \'y\'], [3, \'z\']]);\r\nfor (var x of a) { // 遍历Array\r\n    console.log(x);\r\n}\r\nfor (var x of s) { // 遍历Set\r\n    console.log(x);\r\n}\r\nfor (var x of m) { // 遍历Map\r\n    console.log(x[0] + \'=\' + x[1]);\r\n}\r\n```\r\n\r\n你可能会有疑问，`for ... of`循环和`for ... in`循环有何区别？\r\n\r\n`for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。\r\n\r\n当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：\r\n\r\n```JavaScript\r\nvar a = [\'A\', \'B\', \'C\'];\r\na.name = \'Hello\';\r\nfor (var x in a) {\r\n    console.log(x); // \'0\', \'1\', \'2\', \'name\'\r\n}\r\n```\r\n\r\n`for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。\r\n\r\n`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：\r\n\r\n```JavaScript\r\nvar a = [\'A\', \'B\', \'C\'];\r\na.name = \'Hello\';\r\nfor (var x of a) {\r\n    console.log(x); // \'A\', \'B\', \'C\'\r\n}\r\n```\r\n\r\n这就是为什么要引入新的`for ... of`循环。\r\n\r\n然而，更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：\r\n\r\n`\'use strict\'; var a = [\'A\', \'B\', \'C\']; ` Run\r\n\r\n*注意*，`forEach()`方法是ES5.1标准引入的，你需要测试浏览器是否支持。\r\n\r\n`Set`与`Array`类似，但`Set`没有索引，因此回调函数的前两个参数都是元素本身：\r\n\r\n```JavaScript\r\nvar s = new Set([\'A\', \'B\', \'C\']);\r\ns.forEach(function (element, sameElement, set) {\r\n    console.log(element);\r\n});\r\n```\r\n\r\n`Map`的回调函数参数依次为`value`、`key`和`map`本身：\r\n\r\n```JavaScript\r\nvar m = new Map([[1, \'x\'], [2, \'y\'], [3, \'z\']]);\r\nm.forEach(function (value, key, map) {\r\n    console.log(value);\r\n});\r\n```\r\n\r\n如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得`Array`的`element`：\r\n\r\n```JavaScript\r\nvar a = [\'A\', \'B\', \'C\'];\r\na.forEach(function (element) {\r\n    console.log(element);\r\n});\r\n```","timestamp":1590329650947},{"name":"93-JavaScript简介.md","path":"13-语言学习project/11-JavaScript/4-基础/93-JavaScript简介.md","content":"# JavaScript简介\r\n\r\n[JavaScript](http://c.biancheng.net/js/) 是面向 Web 的编程语言，获得了所有网页浏览器的支持，是目前使用最广泛的脚本编程语言之一，也是网页设计和 Web 应用必须掌握的基本工具。\r\n\r\n==1995年==，当时的Netscape 网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫==Brendan Eich==这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了==10天==时间。\r\n\r\n为什么起名叫JavaScript？原因是==当时Java语言非常红火，所以网景公司希望借Java的名气来推广==，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。\r\n\r\n==1996年==，微软在 Internet Explorer 3 中也加入了脚本编程功能。为了避免与 Netscape 的 JavaScript 产生纠纷，微软特意将其命名为 JScrip\r\n\r\n## ECMAScript\r\n\r\n为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。(那为什么不直接把JavaScript定为标准呢？因为==JavaScript是网景的注册商标==。)\r\n\r\nECMAScript第一版标准发布于==1997年==\r\n\r\n==目前 5 大主流浏览器都支持 ECMAScript 5==，具体说明如下：\r\n\r\n- Opera 11.60+\r\n- IE 9+\r\n- Firefox 4+\r\n- Safari 5.1+\r\n- Chrome 13+\r\n\r\n## JavaScript 构成\r\n\r\nECMAScript 是 JavaScript 的标准，但它并不等同于 JavaScript，也不是唯一被标准化的规范。\r\n\r\n实际上，一个完整的 JavaScript 实现由以下 3 个不同部分组成：\r\n\r\n- 核心（ECMAScript）：语言核心部分。\r\n- 文档对象模型（Document Object Model，DOM）：网页文档操作标准。\r\n- 浏览器对象模型（BOM）：客户端和浏览器窗口操作基础。\r\n\r\n==Web 浏览器==只是 ECMAScript 实现的宿主环境之一。宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供各种扩展功能。\r\n\r\n==文档对象模型==是 HTML 的应用程序编程接口（API）。DOM 把整个文档映射为一个树形节点结构，以方便 JavaScript 脚本快速访问和操作。\r\n\r\nIE3.0 和 Netscape Navigator 3.0 提供了一种新特性，即 ==BOM（浏览器对象模型）==。使用 BOM 可以对浏览器窗口进行访问和操作，如移动窗口、访问历史记录、动态导航等。与 DOM 不同，BOM 只是 JavaScript 的一个部分，并没有形成规范性标准，但是所有浏览器都默认支持。","timestamp":1590329650947},{"name":"94-Map+Set.md","path":"13-语言学习project/11-JavaScript/4-基础/94-Map+Set.md","content":"#### Map和Set\r\n\r\n------\r\n\r\nJavaScript的默认对象表示方式`{}`可以视为其他语言中的`Map`或`Dictionary`的数据结构，即一组键值对。\r\n\r\n但是JavaScript的对象有个小问题，就是==键必须是字符串==。但实际上Number或者其他数据类型作为键也是非常合理的。\r\n\r\n为了解决这个问题，==最新的ES6规范引入了新的数据类型==`Map`。\r\n\r\n要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：\r\n\r\n```javascript\r\n\'use strict\';\r\nvar m = new Map();\r\nvar s = new Set();\r\nconsole.log(\'你的浏览器支持Map和Set！\');\r\n```\r\n\r\n| name 对象 | 初始化                                                       | 获取值               | 添加值                                  | 删除值                              |\r\n| --------- | ------------------------------------------------------------ | -------------------- | --------------------------------------- | ----------------------------------- |\r\n| Map       | `var m = new Map([[\'Michael\', 95], [\'Bob\', 75], [\'Tracy\', 85]]);<br/>m.get(\'Michael\'); // 95 `| `m.get(\'Adam\'); // 67 `| `m.set(\'Adam\', 67); // 添加新的key-value `| `m.delete(\'Adam\'); // 删除key \'Adam\'` |\r\n| Set       | `var s1 = new Set(); // 空Set<br/>var s2 = new Set([1, 2, 3]); // 含1, 2, 3 `|                      | `s.add(4);  `                             |` s.delete(3);  `                      |\r\n\r\n### Map\r\n\r\n`Map`是一组键值对的结构，==具有极快的查找速度。==\r\n\r\n举个例子，假设要根据同学的名字查找对应的成绩，如果用`Array`实现，需要两个`Array`：\r\n\r\n```\r\nvar names = [\'Michael\', \'Bob\', \'Tracy\'];\r\nvar scores = [95, 75, 85];\r\n```\r\n\r\n给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：\r\n\r\n```javascript\r\nvar m = new Map([[\'Michael\', 95], [\'Bob\', 75], [\'Tracy\', 85]]);\r\nm.get(\'Michael\'); // 95\r\n```\r\n\r\n初始化`Map`需要一个==二维数组==，或者直接初始化一个空`Map`。`Map`具有以下方法：\r\n\r\n```javascript\r\nvar m = new Map(); // 空Map\r\nm.set(\'Adam\', 67); // 添加新的key-value\r\nm.set(\'Bob\', 59);\r\nm.has(\'Adam\'); // 是否存在key \'Adam\': true\r\nm.get(\'Adam\'); // 67\r\nm.delete(\'Adam\'); // 删除key \'Adam\'\r\nm.get(\'Adam\'); // undefined\r\n```\r\n\r\n由于一个key只能对应一个value，所以，==多次对一个key放入value，后面的值会把前面的值冲掉==：\r\n\r\n```javascript\r\nvar m = new Map();\r\nm.set(\'Adam\', 67);\r\nm.set(\'Adam\', 88);\r\nm.get(\'Adam\'); // 88\r\n```\r\n\r\n### Set\r\n\r\n`Set`和`Map`类似，也是一组key的集合，==但不存储value==。由于key不能重复，所以，在`Set`中，==没有重复的key==。\r\n\r\n要创建一个`Set`，需要提供一个`Array`作为输入，或者直接创建一个空`Set`：\r\n\r\n```javascript\r\nvar s1 = new Set(); // 空Set\r\nvar s2 = new Set([1, 2, 3]); // 含1, 2, 3\r\n```\r\n\r\n重复元素在`Set`中自动被过滤：\r\n\r\n```javascript\r\nvar s = new Set([1, 2, 3, 3, \'3\']);\r\ns; // Set {1, 2, 3, \"3\"}\r\n```\r\n\r\n注意数字`3`和字符串`\'3\'`是不同的元素。\r\n\r\n通过`add(key)`方法可以添加元素到`Set`中，可以重复添加，但不会有效果：\r\n\r\n```javascript\r\ns.add(4);\r\ns; // Set {1, 2, 3, 4}\r\ns.add(4);\r\ns; // 仍然是 Set {1, 2, 3, 4}\r\n```\r\n\r\n通过`delete(key)`方法可以删除元素：\r\n\r\n```javascript\r\nvar s = new Set([1, 2, 3]);\r\ns; // Set {1, 2, 3}\r\ns.delete(3);\r\ns; // Set {1, 2}\r\n```","timestamp":1590329650947},{"name":"95-map和reduce.md","path":"13-语言学习project/11-JavaScript/4-基础/95-map和reduce.md","content":"#### map/reduce\r\n\r\n阅读: 5128644\r\n\r\n------\r\n\r\n如果你读过Google的那篇大名鼎鼎的论文“[MapReduce: Simplified Data Processing on Large Clusters](http://research.google.com/archive/mapreduce.html)”，你就能大概明白map/reduce的概念。\r\n\r\n### map  做同样的处理\r\n\r\n举例说明，比如我们有一个函数f(x)=x2，要把==这个函数作用在一个数组==`[1, 2, 3, 4, 5, 6, 7, 8, 9]`上，就可以用`map`实现如下：\r\n\r\n![map](D:\\Typora_pic\\0.png)\r\n\r\n由于`map()`方法定义在JavaScript的`Array`中，我们调用`Array`的`map()`方法，传入我们自己的函数，就得到了一个新的`Array`作为结果：\r\n\r\n`\'use strict\'; function pow(x) {    return x * x; } ` Run\r\n\r\n注意：`map()`传入的参数是`pow`，即函数对象本身。\r\n\r\n你可能会想，不需要`map()`，写一个循环，也可以计算出结果：\r\n\r\n```\r\nvar f = function (x) {\r\n    return x * x;\r\n};\r\n\r\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\nvar result = [];\r\nfor (var i=0; i<arr.length; i++) {\r\n    result.push(f(arr[i]));\r\n}\r\n```\r\n\r\n的确可以，但是，从上面的循环代码，我们无法一眼看明白“把f(x)作用在Array的每一个元素并把结果生成一个新的Array”。\r\n\r\n所以，`map()`作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把`Array`的所有数字转为字符串：\r\n\r\n```\r\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\narr.map(String); // [\'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\']\r\n```\r\n\r\n只需要一行代码。\r\n\r\n### reduce 累加\r\n\r\n再看reduce的用法。Array的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\r\n\r\n```\r\n[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\r\n```\r\n\r\n比方说对一个`Array`求和，就可以用`reduce`实现：\r\n\r\n```\r\nvar arr = [1, 3, 5, 7, 9];\r\narr.reduce(function (x, y) {\r\n    return x + y;\r\n}); // 25\r\n```\r\n\r\n练习：利用`reduce()`求积：\r\n\r\n`\'use strict\'; function product(arr) { ``} // 测试: if (product([1, 2, 3, 4]) === 24 && product([0, 1, 2]) === 0 && product([99, 88, 77, 66]) === 44274384) {    console.log(\'测试通过!\'); } else {    console.log(\'测试失败!\'); } ` Run\r\n\r\n要把`[1, 3, 5, 7, 9]`变换成整数13579，`reduce()`也能派上用场：\r\n\r\n```\r\nvar arr = [1, 3, 5, 7, 9];\r\narr.reduce(function (x, y) {\r\n    return x * 10 + y;\r\n}); // 13579\r\n```\r\n\r\n如果我们继续改进这个例子，想办法把一个字符串`13579`先变成`Array`——`[1, 3, 5, 7, 9]`，再利用`reduce()`就可以写出一个把字符串转换为Number的函数。\r\n\r\n练习：不要使用JavaScript内置的`parseInt()`函数，利用map和reduce操作实现一个`string2int()`函数：\r\n\r\n`\'use strict\'; function string2int(s) { ``} // 测试: if (string2int(\'0\') === 0 && string2int(\'12345\') === 12345 && string2int(\'12300\') === 12300) {    if (string2int.toString().indexOf(\'parseInt\') !== -1) {        console.log(\'请勿使用parseInt()!\');    } else if (string2int.toString().indexOf(\'Number\') !== -1) {        console.log(\'请勿使用Number()!\');    } else {        console.log(\'测试通过!\');    } } else {    console.log(\'测试失败!\'); } ` Run\r\n\r\n### 练习\r\n\r\n请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：`[\'adam\', \'LISA\', \'barT\']`，输出：`[\'Adam\', \'Lisa\', \'Bart\']`。\r\n\r\n`\'use strict\'; function normalize(arr) { ``} // 测试: if (normalize([\'adam\', \'LISA\', \'barT\']).toString() === [\'Adam\', \'Lisa\', \'Bart\'].toString()) {    console.log(\'测试通过!\'); } else {    console.log(\'测试失败!\'); } ` Run\r\n\r\n小明希望利用`map()`把字符串变成整数，他写的代码很简洁：\r\n\r\n`\'use strict\'; var arr = [\'1\', \'2\', \'3\']; var r; ``console.log(r); ` Run\r\n\r\n结果竟然是`1, NaN, NaN`，小明百思不得其解，请帮他找到原因并修正代码。\r\n\r\n提示：参考[Array.prototype.map()的文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)。","timestamp":1590329650947},{"name":"96-sort.md","path":"13-语言学习project/11-JavaScript/4-基础/96-sort.md","content":"#### sort\r\n\r\n阅读: 1298399\r\n\r\n------\r\n\r\n### 排序算法\r\n\r\n排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`，如果认为`x > y`，则返回`1`，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。\r\n\r\nJavaScript的`Array`的`sort()`方法就是用于排序的，但是排序结果可能让你大吃一惊：\r\n\r\n```\r\n// 看上去正常的结果:\r\n[\'Google\', \'Apple\', \'Microsoft\'].sort(); // [\'Apple\', \'Google\', \'Microsoft\'];\r\n\r\n// apple排在了最后:\r\n[\'Google\', \'apple\', \'Microsoft\'].sort(); // [\'Google\', \'Microsoft\", \'apple\']\r\n\r\n// 无法理解的结果:\r\n[10, 20, 1, 2].sort(); // [1, 10, 2, 20]\r\n```\r\n\r\n第二个排序把`apple`排在了最后，是因为字符串根据ASCII码进行排序，而小写字母`a`的ASCII码在大写字母之后。\r\n\r\n第三个排序结果是什么鬼？简单的数字排序都能错？\r\n\r\n这是因为`Array`的`sort()`方法默认把所有元素先转换为String再排序，结果`\'10\'`排在了`\'2\'`的前面，因为字符`\'1\'`比字符`\'2\'`的ASCII码小。\r\n\r\n![douwo](D:\\Typora_pic\\l.png)\r\n\r\n如果不知道`sort()`方法的默认排序规则，直接对数字排序，绝对栽进坑里！\r\n\r\n幸运的是，`sort()`方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。\r\n\r\n要按数字大小排序，我们可以这么写：\r\n\r\n`\'use strict\'; var arr = [10, 20, 1, 2]; ` Run\r\n\r\n如果要倒序排序，我们可以把大的数放前面：\r\n\r\n```\r\nvar arr = [10, 20, 1, 2];\r\narr.sort(function (x, y) {\r\n    if (x < y) {\r\n        return 1;\r\n    }\r\n    if (x > y) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}); // [20, 10, 2, 1]\r\n```\r\n\r\n默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：\r\n\r\n```\r\nvar arr = [\'Google\', \'apple\', \'Microsoft\'];\r\narr.sort(function (s1, s2) {\r\n    x1 = s1.toUpperCase();\r\n    x2 = s2.toUpperCase();\r\n    if (x1 < x2) {\r\n        return -1;\r\n    }\r\n    if (x1 > x2) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}); // [\'apple\', \'Google\', \'Microsoft\']\r\n```\r\n\r\n忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。\r\n\r\n从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。\r\n\r\n最后友情提示，`sort()`方法会直接对`Array`进行修改，它返回的结果仍是当前`Array`：\r\n\r\n```\r\nvar a1 = [\'B\', \'A\', \'C\'];\r\nvar a2 = a1.sort();\r\na1; // [\'A\', \'B\', \'C\']\r\na2; // [\'A\', \'B\', \'C\']\r\na1 === a2; // true, a1和a2是同一对象\r\n```","timestamp":1590329650947},{"name":"97-变量作用域.md","path":"13-语言学习project/11-JavaScript/4-基础/97-变量作用域.md","content":"#### 变量作用域与解构赋值\r\n\r\n------\r\n\r\n在JavaScript中，用`var`申明的变量实际上是有作用域的。\r\n\r\n如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    var x = 1;\r\n    x = x + 1;\r\n}\r\n\r\nx = x + 2; // ReferenceError! 无法在函数体外引用变量x\r\n```\r\n\r\n如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    var x = 1;\r\n    x = x + 1;\r\n}\r\n\r\nfunction bar() {\r\n    var x = \'A\';\r\n    x = x + \'B\';\r\n}\r\n```\r\n\r\n由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    var x = 1;\r\n    function bar() {\r\n        var y = x + 1; // bar可以访问foo的变量x!\r\n    }\r\n    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!\r\n}\r\n```\r\n\r\n这说明JavaScript的函数在查找变量时从自身函数定义开始，==从“内”向“外”查找==。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。\r\n\r\n### 变量提升\r\n\r\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    var x = \'Hello, \' + y;\r\n    console.log(x);\r\n    var y = \'Bob\';\r\n}\r\n\r\nfoo();\r\n```\r\n\r\n虽然是strict模式，但语句`var x = \'Hello, \' + y;`并不报错，原因是变量`y`在稍后申明了。但是`console.log`显示`Hello, undefined`，说明变量`y`的值为`undefined`。这正是因为JavaScript引擎自动提升了变量`y`的声明，但不会提升变量`y`的赋值。\r\n\r\n对于上述`foo()`函数，JavaScript引擎看到的代码相当于：\r\n\r\n```\r\nfunction foo() {\r\n    var y; // 提升变量y的申明，此时y为undefined\r\n    var x = \'Hello, \' + y;\r\n    console.log(x);\r\n    y = \'Bob\';\r\n}\r\n```\r\n\r\n由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个`var`申明函数内部用到的所有变量：\r\n\r\n```javascript\r\nfunction foo() {\r\n    var\r\n        x = 1, // x初始化为1\r\n        y = x + 1, // y初始化为2\r\n        z, i; // z和i为undefined\r\n    // 其他语句:\r\n    for (i=0; i<100; i++) {\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n### 全局作用域\r\n\r\n不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象`window`，全局作用域的变量实际上被绑定到`window`的一个属性：\r\n\r\n```\r\n\'use strict\';\r\n\r\nvar course = \'Learn JavaScript\';\r\nalert(course); // \'Learn JavaScript\'\r\nalert(window.course); // \'Learn JavaScript\'\r\n```\r\n\r\n因此，直接访问全局变量`course`和访问`window.course`是完全一样的。\r\n\r\n你可能猜到了，由于函数定义有两种方式，以变量方式`var foo = function () {}`定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到`window`对象：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    alert(\'foo\');\r\n}\r\n\r\nfoo(); // 直接调用foo()\r\nwindow.foo(); // 通过window.foo()调用\r\n```\r\n\r\n进一步大胆地猜测，我们每次直接调用的`alert()`函数其实也是`window`的一个变量：\r\n\r\n`\'use strict\'; window.alert(\'调用window.alert()\'); // 把alert保存到另一个变量: var old_alert = window.alert; // 给alert赋一个新函数: window.alert = function () {} ``// 恢复alert: window.alert = old_alert; alert(\'又可以用alert()了!\'); ` Run\r\n\r\n这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报`ReferenceError`错误。\r\n\r\n### 名字空间\r\n\r\n全局变量会绑定到`window`上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。\r\n\r\n==减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中==。例如：\r\n\r\n```\r\n// 唯一的全局变量MYAPP:\r\nvar MYAPP = {};\r\n\r\n// 其他变量:\r\nMYAPP.name = \'myapp\';\r\nMYAPP.version = 1.0;\r\n\r\n// 其他函数:\r\nMYAPP.foo = function () {\r\n    return \'foo\';\r\n};\r\n```\r\n\r\n把自己的代码全部放入唯一的名字空间`MYAPP`中，会大大减少全局变量冲突的可能。\r\n\r\n许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。\r\n\r\n### 局部作用域\r\n\r\n由于JavaScript的变量作用域实际上是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：\r\n\r\n```javascript\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    for (var i=0; i<100; i++) {\r\n        //\r\n    }\r\n    i += 100; // 仍然可以引用变量i\r\n}\r\n```\r\n\r\n为了解决块级作用域，ES6引入了新的关键字`let`，用`let`替代`var`可以申明一个块级作用域的变量：\r\n\r\n```javascript\r\n\'use strict\';\r\n\r\nfunction foo() {\r\n    var sum = 0;\r\n    for (let i=0; i<100; i++) {\r\n        sum += i;\r\n    }\r\n    // SyntaxError:\r\n    i += 1;\r\n}\r\n```\r\n\r\n### 常量\r\n\r\n由于`var`和`let`申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：\r\n\r\n```javascript\r\nvar PI = 3.14;\r\n```\r\n\r\nES6标准引入了新的关键字`const`来定义常量，`const`与`let`都具有块级作用域：\r\n\r\n```javascript\r\n\'use strict\';\r\n\r\nconst PI = 3.14;\r\nPI = 3; // 某些浏览器不报错，但是无效果！\r\nPI; // 3.14\r\n```\r\n\r\n### 解构赋值\r\n\r\n从ES6开始，JavaScript引入了==解构赋值，可以同时对一组变量进行赋值==。\r\n\r\n什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量：\r\n\r\n```\r\nvar array = [\'hello\', \'JavaScript\', \'ES6\'];\r\nvar x = array[0];\r\nvar y = array[1];\r\nvar z = array[2];\r\n```\r\n\r\n现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值：\r\n\r\n```\r\nvar [x, y, z] = [\'hello\', \'JavaScript\', \'ES6\'];\r\n```\r\n\r\n注意，对数组元素进行解构赋值时，多个变量要用`[...]`括起来。\r\n\r\n如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意==嵌套层次和位置要保持一致==：\r\n\r\n```\r\nlet [x, [y, z]] = [\'hello\', [\'JavaScript\', \'ES6\']];\r\nx; // \'hello\'\r\ny; // \'JavaScript\'\r\nz; // \'ES6\'\r\n```\r\n\r\n解构赋值还可以==忽略某些元素==：\r\n\r\n```\r\nlet [, , z] = [\'hello\', \'JavaScript\', \'ES6\']; // 忽略前两个元素，只对z赋值第三个元素\r\nz; // \'ES6\'\r\n```\r\n\r\n如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：\r\n\r\n`\'use strict\'; var person = {    name: \'小明\',    age: 20,    gender: \'male\',    passport: \'G-12345678\',    school: \'No.4 middle school\' }; var {name, age, passport} = person; ` Run\r\n\r\n对一个对象进行解构赋值时，同样可以==直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的==：\r\n\r\n```javascript\r\nvar person = {\r\n    name: \'小明\',\r\n    age: 20,\r\n    gender: \'male\',\r\n    passport: \'G-12345678\',\r\n    school: \'No.4 middle school\',\r\n    address: {\r\n        city: \'Beijing\',\r\n        street: \'No.1 Road\',\r\n        zipcode: \'100001\'\r\n    }\r\n};\r\nvar {name, address: {city, zip}} = person;\r\nname; // \'小明\'\r\ncity; // \'Beijing\'\r\nzip; // undefined, 因为属性名是zipcode而不是zip\r\n// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:\r\naddress; // Uncaught ReferenceError: address is not defined\r\n```\r\n\r\n使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为`undefined`，这和引用一个不存在的属性获得`undefined`是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取：\r\n\r\n```javascript\r\nvar person = {\r\n    name: \'小明\',\r\n    age: 20,\r\n    gender: \'male\',\r\n    passport: \'G-12345678\',\r\n    school: \'No.4 middle school\'\r\n};\r\n\r\n// 把passport属性赋值给变量id:\r\nlet {name, passport:id} = person;\r\nname; // \'小明\'\r\nid; // \'G-12345678\'\r\n// 注意: passport不是变量，而是为了让变量id获得passport属性:\r\npassport; // Uncaught ReferenceError: passport is not defined\r\n```\r\n\r\n解构赋值还可以使用默认值，这样就避免了不存在的属性返回`undefined`的问题：\r\n\r\n```javascript\r\nvar person = {\r\n    name: \'小明\',\r\n    age: 20,\r\n    gender: \'male\',\r\n    passport: \'G-12345678\'\r\n};\r\n\r\n// 如果person对象没有single属性，默认赋值为true:\r\nvar {name, single=true} = person;\r\nname; // \'小明\'\r\nsingle; // true\r\n```\r\n\r\n有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：\r\n\r\n```javascript\r\n// 声明变量:\r\nvar x, y;\r\n// 解构赋值:\r\n{x, y} = { name: \'小明\', x: 100, y: 200};\r\n// 语法错误: Uncaught SyntaxError: Unexpected token =\r\n```\r\n\r\n这是因为JavaScript引擎把`{`开头的语句当作了块处理，于是`=`不再合法。==解决方法是用小括号括起来==：\r\n\r\n```\r\n({x, y} = { name: \'小明\', x: 100, y: 200});\r\n```\r\n\r\n### 使用场景\r\n\r\n解构赋值在很多时候可以大大简化代码。例如，交换两个变量`x`和`y`的值，可以这么写，不再需要临时变量：\r\n\r\n```javascript\r\nvar x=1, y=2;\r\n[x, y] = [y, x]\r\n```\r\n\r\n快速获取当前页面的域名和路径：\r\n\r\n```javascript\r\nvar {hostname:domain, pathname:path} = location;\r\n```\r\n\r\n如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个`Date`对象：\r\n\r\n```javascript\r\nfunction buildDate({year, month, day, hour=0, minute=0, second=0}) {\r\n    return new Date(year + \'-\' + month + \'-\' + day + \' \' + hour + \':\' + minute + \':\' + second);\r\n}\r\n```\r\n\r\n它的方便之处在于传入的对象只需要`year`、`month`和`day`这三个属性：\r\n\r\n```javascript\r\nbuildDate({ year: 2017, month: 1, day: 1 });\r\n// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)\r\n```\r\n\r\n也可以传入`hour`、`minute`和`second`属性：\r\n\r\n```javascript\r\nbuildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });\r\n// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)\r\n```\r\n\r\n\r\n\r\n使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。","timestamp":1590329650947},{"name":"98-对象.md","path":"13-语言学习project/11-JavaScript/4-基础/98-对象.md","content":"#### 对象\r\n\r\n------\r\n\r\nJavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。\r\n\r\nJavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：\r\n\r\n```\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    school: \'No.1 Middle School\',\r\n    height: 1.70,\r\n    weight: 65,\r\n    score: null\r\n};\r\n```\r\n\r\nJavaScript用一个`{...}`表示一个对象，键值对以`xxx: xxx`形式申明，用`,`隔开。注意，最后一个键值对不需要在末尾加`,`，如果加了，有的浏览器（如低版本的IE）将报错。\r\n\r\n上述对象申明了一个`name`属性，值是`\'小明\'`，`birth`属性，值是`1990`，以及其他一些属性。最后，把这个对象赋值给变量`xiaoming`后，就可以通过变量`xiaoming`来获取小明的属性了：\r\n\r\n```\r\nxiaoming.name; // \'小明\'\r\nxiaoming.birth; // 1990\r\n```\r\n\r\n访问属性是通过`.`操作符完成的，但这要求==属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用`\'\'`括起来：==\r\n\r\n```\r\nvar xiaohong = {\r\n    name: \'小红\',\r\n    \'middle-school\': \'No.1 Middle School\'\r\n};\r\n```\r\n\r\n`xiaohong`的属性名`middle-school`不是一个有效的变量，==就需要用`\'\'`括起来。访问这个属性也无法使用`.`操作符，必须用`[\'xxx\']`来访问：==\r\n\r\n```\r\nxiaohong[\'middle-school\']; // \'No.1 Middle School\'\r\nxiaohong[\'name\']; // \'小红\'\r\nxiaohong.name; // \'小红\'\r\n```\r\n\r\n也可以用`xiaohong[\'name\']`来访问`xiaohong`的`name`属性，不过`xiaohong.name`的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过`object.prop`的形式访问一个属性了。\r\n\r\n实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。\r\n\r\n==如果访问一个不存在的属性会返回==什么呢？JavaScript规定，访问不存在的属性不报错，而是返回`undefined`：\r\n\r\n`\'use strict\'; var xiaoming = {    name: \'小明\' }; ` Run\r\n\r\n由于JavaScript的对象是动态类型，你可以==自由地给一个对象添加或删除属性==：\r\n\r\n```JavaScript\r\nvar xiaoming = {\r\n    name: \'小明\'\r\n};\r\nxiaoming.age; // undefined\r\nxiaoming.age = 18; // 新增一个age属性\r\nxiaoming.age; // 18\r\ndelete xiaoming.age; // 删除age属性\r\nxiaoming.age; // undefined\r\ndelete xiaoming[\'name\']; // 删除name属性\r\nxiaoming.name; // undefined\r\ndelete xiaoming.school; // 删除一个不存在的school属性也不会报错\r\n```\r\n\r\n如果我们要检测`xiaoming`是否拥有某一属性，==可以用`in`操作符==：\r\n\r\n```JavaScript\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    birth: 1990,\r\n    school: \'No.1 Middle School\',\r\n    height: 1.70,\r\n    weight: 65,\r\n    score: null\r\n};\r\n\'name\' in xiaoming; // true\r\n\'grade\' in xiaoming; // false\r\n```\r\n\r\n不过要小心，如果`in`判断一个属性存在，这个属性不一定是`xiaoming`的，==它可能是`xiaoming`继承得到的：==\r\n\r\n```\r\n\'toString\' in xiaoming; // true\r\n```\r\n\r\n因为`toString`定义在`object`对象中，而所有对象最终都会在原型链上指向`object`，所以`xiaoming`也拥有`toString`属性。\r\n\r\n要判断一个属性是否是`xiaoming`自身拥有的==，而不是继承得到的，可以用`hasOwnProperty()`方法==：\r\n\r\n```JavaScript\r\nvar xiaoming = {\r\n    name: \'小明\'\r\n};\r\nxiaoming.hasOwnProperty(\'name\'); // true\r\nxiaoming.hasOwnProperty(\'toString\'); // false\r\n```","timestamp":1590329650947},{"name":"99-快速入门.md","path":"13-语言学习project/11-JavaScript/4-基础/99-快速入门.md","content":"## 使用和加载方式\r\n\r\n1. JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到==head==中：\r\n\r\n```html\r\n<html>\r\n<head>\r\n  <script>\r\n    alert(\'Hello, world\');\r\n  </script>\r\n</head>\r\n<body>\r\n  ...\r\n</body>\r\n</html>\r\n```\r\n\r\n2. 第二种方法是把JavaScript代码放到一个单独的`.js`文件，然后在HTML中通过``引入这个文件：\r\n\r\n```html\r\n<html>\r\n<head>\r\n  <script src=\"/static/js/abc.js\"></script>\r\n</head>\r\n<body>\r\n  ...\r\n</body>\r\n</html>\r\n```\r\n\r\n把JavaScript代码放入一个单独的`.js`文件中更==利于维护==代码，并且==多个页面可以各自引用同一份==`.js`文件。\r\n\r\n可以在同一个页面中引入多个`.js`文件，还可以在页面中多次编写` js代码... `，浏览器按照==顺序依次执行==。\r\n\r\n##  JS文件延迟和异步加载：defer和async属性\r\n\r\n—般情况下，在文档的 <head> 标签中包含 [Java](http://c.biancheng.net/java/)Script 脚本，或者导入的 JavaScript 文件。这意味着==必须等到全部 JavaScript 代码都被加载、解析和执行完以后，才能继续解析==后面的 HTML 部分。如果==加载的 JavaScript 文件很大==， HTML 文档解析就容易==出现延迟==。\r\n\r\n为了避免这个问题，在开发 Web 应用程序时，建议把导入 JavaScript 文件的操作==放在 <body> 后面==，让浏览器先 将网页内容解析并呈现出来后，再去加载 JavaScript 文件，以便==加快网页响应速度。==\r\n\r\n### defer 延迟执行 JavaScript 文件\r\n\r\n<script> 标签有一个布尔型属性 defer，设置该属性能够将 JavaScript 文件延迟到页面解析完毕后再运行。\r\n示例\r\n\r\n```html\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <script type=\"text/javascript\" defer src=\"test.js\"></script>\r\n</head>\r\n<body>\r\n    <h1>网页标题</h1>\r\n    <p>正文内容</p>\r\n</body>\r\n</html>\r\n```\r\n\r\n<font color=red>注意：defer 属性适用于外部 JavaScript 文件，不适用于 <script>签包含的 JavaScript 脚本</font>\r\n\r\n## async异步加载JavaScript文件\r\n\r\n现在可以为 <script> 标签设置 **async** 属性，让浏览器异步加载 JavaScript 文件，即在加载 JavaScript 文件时，浏览器不会暂停，而是继续解析。这样能节省时间，提升响应速度。\r\n\r\n```html\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <script type=\"text/javascript\" async src=\"test.js\"></script>\r\n</head>\r\n<body>\r\n    <h1>网页标题</h1>\r\n    <p>正文内容</p>\r\n</body>\r\n</html>\r\n```\r\n\r\n<font color=red>为 <script> 标签设置 async 属性，然后在浏览器中预览，则会看到网页标题和段落文本同步，或者==先显示出来，然后同步弹出提示文本==。如果不设置 async 属性，则先弹出提示文本，然后才开始解析并显示网页标题和段落文本</font>\r\n\r\n==async 是 HTML5 新增的布尔型属性，通过设置 async 属性，就不用考虑 <script> 标签的放置位置，用户可以根据习惯继续把很多大型 JavaScript 库文件放在 <head> 标签内==\r\n\r\n## 基本语法\r\n\r\n```javascript\r\n//赋值语句：\r\nvar x = 1;\r\n\r\n//一个字符串，但仍然可以视为一个完整的语句：\r\n\'Hello, world\';\r\n\r\n//包含两个语句，每个语句用;表示语句结束：\r\nvar x = 1; var y = 2; // 不建议一行写多个语句!\r\n\r\n//语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{...}中的所有语句：\r\nif (2 > 1) {\r\n    x = 1;\r\n    y = 2;\r\n    z = 3;\r\n}\r\n\r\n//注意花括号{...}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，\r\n//{...}还可以嵌套，形成层级结构：\r\n//JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。\r\n//遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。\r\nif (2 > 1) {\r\n    x = 1;\r\n    y = 2;\r\n    z = 3;\r\n    if (x < y) {\r\n        z = 4;\r\n    }\r\n    if (x > y) {\r\n        z = 5;\r\n    }\r\n}\r\n\r\n// 这是一行注释\r\nalert(\'hello\'); // 这也是注释\r\n\r\n//块注释是用/*...*/把多行字符包裹起来，把一大“块”视为一个注释：\r\n/* 从这里开始是块注释\r\n仍然是注释\r\n仍然是注释\r\n注释结束 */\r\n```\r\n\r\n### 代码块\r\n\r\n如果在一个 JavaScript 代码块中调用后面代码块中声明的变量或函数，就会提示语法错误。例如，当 JavaScript 解释器执行下面代码时就会提示语法错误，显示变量 a 未定义。\r\n\r\n```JavaScript\r\n<script>    \r\n    //JavaScript 代码块 1    \r\n    alert(a);\r\n</script>\r\n<script>    \r\n    //JavaScript 代码块 2    \r\n    var a = 1;\r\n</script>\r\n```\r\n\r\n\r\n如果把两块代码放在一起，就不会出现上述错误。合并代码如下：\r\n\r\n```JavaScript\r\n<script>    //JavaScript 代码块    alert(a);    var a = 1;</script>\r\n```\r\n\r\n==温馨提示==JavaScript 是按块执行的，但是不同块都属于同一个作用域（全局作用域），下面块中的代码可以访问上面块中的变量。因此，如果把上面示例中两个代码块的顺序调换一下，就不会出现语法错误。\r\n\r\n```JavaScript\r\n<script>    //JavaScript 代码块 2    var a = 1;</script><script>    //JavaScript 代码块 1    alert(a);</script>\r\n```\r\n\r\n### JavaScript字符编码\r\n\r\n[JavaScript](http://c.biancheng.net/js/) 遵循 Unicode 字符编码规则。Unicode 字符集中每个字符使用 2 个字节来表示，这意味着用户可以使用中文来命名 [Java](http://c.biancheng.net/java/)Script 变量。\r\n\r\nUnicode 是 Latin-1 字符集的超集，编码数目达到百万级；Latin-1是 ASCII 字符集的扩展，包含 256 个拉丁字母； ASCII 字符集包含 128 个基本字符，即常用英文字母和符号。\r\n\r\n注意：在 JavaScrip t第 1、2 版本中，仅支持 ASCII 字符编码，Unicode 字符只能出现在注释或者引号包含的字符串中。考虑到 JavaScript 版本的兼容性以及开发习惯，不建议使用双字节的中文字符命名变量或函数名。\r\n\r\n由于 JavaScript 脚本一般都嵌入在网页中，并最终由浏览器来解释，因此在考虑到 JavaScript 字符编码的同时， 还要兼顾 HTML 文档的字符编码，以及浏览器支持的编码。一般建议保持 HTML 文档的字符编码与 JavaScript 字符编码一致，以免出现乱码\r\n\r\n# JavaScript中的几个重要概念\r\n\r\n[JavaScript](http://c.biancheng.net/js/) 遵循 ECMA-262 规范，目前其最新版是 ECMAScript 2018，而获得所有主流浏览器完全支持的则是 ECMAScript 5。以ECMAScript 5版本为基础，兼顾 ECMAScript 6 版本 中获得较大支持的新特性进行介绍。\r\n\r\n## 基本词法\r\n\r\n[Java](http://c.biancheng.net/java/)Script 语法就是==指构成合法的 JavaScript 程序的所有规则和特征的集合==，包括词法和句法。简单描述如下：\r\n\r\n- 词法定义了 JavaScript的基本名词规范，包括==字符编码、命名规则、标识符、关键字、注释规则、 运算符和分隔符==等。\r\n- 句法定义了 JavaScript的基本运算逻辑和程序结构，包括==短语、句子和代码段的基本规则，如表达式、语句和程序结构==等。\r\n\r\n## 区分大小写\r\n\r\nJavaScript ==严格区分大小写==。为了避免输入混乱和语法错误，建议==采用小写字符==编写代码。在以下特殊情况下可以使用大写形式：\r\n\r\n\r\n\r\n```javascript\r\n//1) ==构造函数的首字母建议大写==。构造函数不同于普通函数。下面示例调用预定义的构造函数 Date()，创建一个时间对象，然后把时间对象转换为字符串显示出来。\r\nd = new Date();  //获取当前日期和时间\r\ndocument.write(d.toString());  // 显示日期\r\n//2) 如果标识符由多个单词组成，可以考虑使用骆驼命名法——除首个单词外，后面单词的首字母大写。例如\r\ntypeOf();\r\nprintEmployeePaychecks();\r\n```\r\n\r\n## 直接量\r\n\r\n直接量（Literal）就是具体的值，即能够直接参与运算或显示的值，==字符串、数值、布尔值、正则表达式、特殊值、对象、数组和函数==。\r\n\r\n```javascript\r\n//空字符串直接量\r\n1  //数值直接量\r\ntrue  //布尔值直接量\r\n/a/g  //正则表达式直接量\r\nnull  //特殊值直接量\r\n{}  //空对象直接量\r\n[]  //空数组直接量\r\nfunction(){}  //空函数直接量，也就是函数表达式\r\n```\r\n\r\n## 转义序列\r\n\r\n转义序列就是字符的一种表示方式（映射）。由于各种原因，很多字符==无法直接在代码中输入或输出，只能通过转义序列间接==表示。\r\n\r\n- Unicode 转义序列方法：\\u + 4位十六进制数字。\r\n- Latin-1 转义序列方法：\\x + 2位十六进制数字。\r\n\r\n对于字符“©” , Unicode 转义为 \\u00A9，ASCII 转义为 \\xA9。\r\n\r\n```javascript\r\ndocument.write(\"\\xa9\");  //显示字符©\r\ndocument.write(\"\\u00a9\");  //显示字符©\r\n```","timestamp":1590329650947},{"name":"111-ajax.md","path":"13-语言学习project/11-JavaScript/5-浏览器/111-ajax.md","content":"#### AJAX\r\n\r\n阅读: 6562545\r\n\r\n------\r\n\r\nAJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。\r\n\r\n如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。\r\n\r\n这就是Web的运作原理：一次HTTP请求对应一个页面。\r\n\r\n如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。\r\n\r\n最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。\r\n\r\n用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。\r\n\r\n在现代浏览器上写AJAX主要依靠`XMLHttpRequest`对象：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n对于低版本的IE，需要换一个`ActiveXObject`对象：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n如果你想把标准写法和IE写法混在一起，可以这么写：\r\n\r\n```\r\nvar request;\r\nif (window.XMLHttpRequest) {\r\n    request = new XMLHttpRequest();\r\n} else {\r\n    request = new ActiveXObject(\'Microsoft.XMLHTTP\');\r\n}\r\n```\r\n\r\n通过检测`window`对象是否有`XMLHttpRequest`属性来确定浏览器是否支持标准的`XMLHttpRequest`。注意，*不要*根据浏览器的`navigator.userAgent`来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。\r\n\r\n当创建了`XMLHttpRequest`对象后，要先设置`onreadystatechange`的回调函数。在回调函数中，通常我们只需通过`readyState === 4`判断请求是否完成，如果已完成，再根据`status === 200`判断是否是一个成功的响应。\r\n\r\n`XMLHttpRequest`对象的`open()`方法有3个参数，第一个参数指定是`GET`还是`POST`，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是`true`，所以不用写。\r\n\r\n*注意*，千万不要把第三个参数指定为`false`，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。\r\n\r\n最后调用`send()`方法才真正发送请求。`GET`请求不需要参数，`POST`请求需要把body部分以字符串或者`FormData`对象传进去。\r\n\r\n### 安全限制\r\n\r\n上面代码的URL使用的是相对路径。如果你把它改为`\'http://www.sina.com.cn/\'`，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。\r\n\r\n这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。\r\n\r\n完全一致的意思是，域名要相同（`www.example.com`和`example.com`不同），协议要相同（`http`和`https`不同），端口号要相同（默认是`:80`端口，它和`:8080`就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。\r\n\r\n那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：\r\n\r\n一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。\r\n\r\n二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：\r\n\r\n```\r\n\'/proxy?url=http://www.sina.com.cn\'\r\n```\r\n\r\n代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。\r\n\r\n第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：\r\n\r\n```\r\n<html>\r\n<head>\r\n    <script src=\"http://example.com/abc.js\"></script>\r\n    ...\r\n</head>\r\n<body>\r\n...\r\n</body>\r\n</html>\r\n```\r\n\r\nJSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下：\r\n\r\n```\r\nfoo(\'data\');\r\n```\r\n\r\n这样一来，我们如果在页面中先准备好`foo()`函数，然后给页面动态加一个``节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。\r\n\r\n以163的股票查询URL为例，对于URL：http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回：\r\n\r\n```\r\nrefreshPrice({\"0000001\":{\"code\": \"0000001\", ... });\r\n```\r\n\r\n因此我们需要首先在页面中准备好回调函数：\r\n\r\n```\r\nfunction refreshPrice(data) {\r\n    var p = document.getElementById(\'test-jsonp\');\r\n    p.innerHTML = \'当前价格：\' +\r\n        data[\'0000001\'].name +\': \' + \r\n        data[\'0000001\'].price + \'；\' +\r\n        data[\'1399001\'].name + \': \' +\r\n        data[\'1399001\'].price;\r\n}\r\n```\r\n\r\n当前价格：\r\n\r\n刷新\r\n\r\n最后用`getPrice()`函数触发：\r\n\r\n```\r\nfunction getPrice() {\r\n    var\r\n        js = document.createElement(\'script\'),\r\n        head = document.getElementsByTagName(\'head\')[0];\r\n    js.src = \'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice\';\r\n    head.appendChild(js);\r\n}\r\n```\r\n\r\n就完成了跨域加载数据。\r\n\r\n### CORS\r\n\r\n如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。\r\n\r\nCORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。\r\n\r\n了解CORS前，我们先搞明白概念：\r\n\r\nOrigin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查`Access-Control-Allow-Origin`是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。\r\n\r\n用一个图来表示就是：\r\n\r\n![js-cors](D:\\Typora_pic\\l-1585993343556.png)\r\n\r\n假设本域是`my.com`，外域是`sina.com`，只要响应头`Access-Control-Allow-Origin`为`http://my.com`，或者是`*`，本次请求就可以成功。\r\n\r\n可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的`Access-Control-Allow-Origin`，决定权始终在对方手中。\r\n\r\n上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限`application/x-www-form-urlencoded`、`multipart/form-data`和`text/plain`），并且不能出现任何自定义头（例如，`X-Custom: 12345`），通常能满足90%的需求。\r\n\r\n无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：\r\n\r\n```\r\n/* CSS */\r\n@font-face {\r\n  font-family: \'FontAwesome\';\r\n  src: url(\'http://cdn.com/fonts/fontawesome.ttf\') format(\'truetype\');\r\n}\r\n```\r\n\r\n如果该CDN服务商未正确设置`Access-Control-Allow-Origin`，那么浏览器无法加载字体资源。\r\n\r\n对于PUT、DELETE以及其他类型如`application/json`的POST请求，在发送AJAX请求之前，浏览器会先发送一个`OPTIONS`请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：\r\n\r\n```\r\nOPTIONS /path/to/resource HTTP/1.1\r\nHost: bar.com\r\nOrigin: http://my.com\r\nAccess-Control-Request-Method: POST\r\n```\r\n\r\n服务器必须响应并明确指出允许的Method：\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: http://my.com\r\nAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONS\r\nAccess-Control-Max-Age: 86400\r\n```\r\n\r\n浏览器确认服务器响应的`Access-Control-Allow-Methods`头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。\r\n\r\n由于以`POST`、`PUT`方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理`POST`和`PUT`请求，服务器端必须正确响应`OPTIONS`请求。\r\n\r\n需要深入了解CORS的童鞋请移步[W3C文档](http://www.w3.org/TR/cors/)。\r\n\r\n#### [这个判断的意义是什么？](https://www.liaoxuefeng.com/discuss/1023622307115840/1320976553869346)\r\n\r\n[shadowTy](https://www.liaoxuefeng.com/user/1299632156049442) created at December 17, 2019 5:38 PM, Last updated at December 25, 2019 6:53 PM\r\n\r\n> 通常我们只需通过`readyState === 4`判断请求是否完成\r\n\r\n回调函数不是请求完成才执行吗？那为什么还要有这个判断？\r\n\r\n- [![img](D:\\Typora_pic\\5b6bc387ly8fupjljwhbwj20yi0yidhu.jpg)](https://www.liaoxuefeng.com/user/1313160663400482)\r\n\r\n  [MoliySDev](https://www.liaoxuefeng.com/user/1313160663400482)\r\n\r\n  Created at December 25, 2019 6:53 PM\r\n\r\n  readyState是AJAX的状态\r\n\r\n  0 - (未初始化)还没有调用send()方法\r\n\r\n  1 - (载入)已调用send()方法，正在发送请求\r\n\r\n  2 - (载入完成)send()方法执行完成，\r\n\r\n  3 - (交互)正在解析响应内容\r\n\r\n  4 - (完成)响应内容解析完成，可以在客户端调用了\r\n\r\n  上面源自百度\r\n\r\n  status是请求之后服务端的HTTPCode,两个东西不一样","timestamp":1590329650947},{"name":"112-Canvas.md","path":"13-语言学习project/11-JavaScript/5-浏览器/112-Canvas.md","content":"#### Canvas\r\n\r\n阅读: 2314426\r\n\r\n------\r\n\r\nCanvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。\r\n\r\n没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。\r\n\r\n一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：\r\n\r\n```\r\n<canvas id=\"test-canvas\" width=\"300\" height=\"200\"></canvas>\r\n```\r\n\r\n由于浏览器对HTML5标准支持不一致，所以，通常在``内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略``内部的HTML，如果浏览器不支持Canvas，它将显示``内部的HTML：\r\n\r\n```\r\n<canvas id=\"test-stock\" width=\"300\" height=\"200\">\r\n    <p>Current Price: 25.51</p>\r\n</canvas>\r\n```\r\n\r\n在使用Canvas前，用`canvas.getContext`来测试浏览器是否支持Canvas：\r\n\r\n```\r\n<!-- HTML代码 -->\r\n<canvas id=\"test-canvas\" width=\"200\" heigth=\"100\">\r\n    <p>你的浏览器不支持Canvas</p>\r\n</canvas>\r\n```\r\n\r\n`\'use strict\'; ` Run\r\n\r\n`getContext(\'2d\')`方法让我们拿到一个`CanvasRenderingContext2D`对象，所有的绘图操作都需要通过这个对象完成。\r\n\r\n```\r\nvar ctx = canvas.getContext(\'2d\');\r\n```\r\n\r\n如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：\r\n\r\n```\r\ngl = canvas.getContext(\"webgl\");\r\n```\r\n\r\n本节我们只专注于绘制2D图形。\r\n\r\n### 绘制形状\r\n\r\n我们可以在Canvas上绘制各种形状。在绘制前，我们需要先了解一下Canvas的坐标系统：\r\n\r\n![canvas-xy](D:\\Typora_pic\\l-1586007959225.png)\r\n\r\nCanvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。\r\n\r\n`CanvasRenderingContext2D`对象有若干方法来绘制图形：\r\n\r\n`\'use strict\'; var    canvas = document.getElementById(\'test-shape-canvas\'),    ctx = canvas.getContext(\'2d\'); ` Run\r\n\r\n### 绘制文本\r\n\r\n绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：\r\n\r\n`\'use strict\'; var    canvas = document.getElementById(\'test-text-canvas\'),    ctx = canvas.getContext(\'2d\'); ` Run\r\n\r\nCanvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：\r\n\r\n- 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；\r\n- 尽量使用整数坐标而不是浮点数；\r\n- 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；\r\n- 背景图片如果不变可以直接用``标签并放到最底层。\r\n\r\n### 练习\r\n\r\n请根据从163获取的JSON数据绘制最近30个交易日的K线图，数据已处理为包含一组对象的数组：\r\n\r\n`\'use strict\'; window.loadStockData = function (r) {    var        NUMS = 30,        data = r.data;    if (data.length > NUMS) {        data = data.slice(data.length - NUMS);    }    data = data.map(function (x) {        return {            date: x[0],            open: x[1],            close: x[2],            high: x[3],            low: x[4],            vol: x[5],            change: x[6]        };    });    window.drawStock(data); } window.drawStock = function (data) { ``}; // 加载最近30个交易日的K线图数据: var js = document.createElement(\'script\'); js.src = \'http://img1.money.126.net/data/hs/kline/day/history/2015/0000001.json?callback=loadStockData&t=\' + Date.now(); document.getElementsByTagName(\'head\')[0].appendChild(js); ` Run\r\n\r\n\r\n\r\n[下载为图片](https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576#0)","timestamp":1590329650947},{"name":"113-DOM.md","path":"13-语言学习project/11-JavaScript/5-浏览器/113-DOM.md","content":"#### 操作DOM\r\n\r\n阅读: 1856776\r\n\r\n------\r\n\r\n由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。\r\n\r\n始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：\r\n\r\n- 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；\r\n- 遍历：遍历该DOM节点下的子节点，以便进行进一步操作；\r\n- 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；\r\n- 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。\r\n\r\n在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是`document.getElementById()`和`document.getElementsByTagName()`，以及CSS选择器`document.getElementsByClassName()`。\r\n\r\n由于ID在HTML文档中是唯一的，所以`document.getElementById()`可以直接定位唯一的一个DOM节点。`document.getElementsByTagName()`和`document.getElementsByClassName()`总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。\r\n\r\n例如：\r\n\r\n```\r\n// 返回ID为\'test\'的节点：\r\nvar test = document.getElementById(\'test\');\r\n\r\n// 先定位ID为\'test-table\'的节点，再返回其内部所有tr节点：\r\nvar trs = document.getElementById(\'test-table\').getElementsByTagName(\'tr\');\r\n\r\n// 先定位ID为\'test-div\'的节点，再返回其内部所有class包含red的节点：\r\nvar reds = document.getElementById(\'test-div\').getElementsByClassName(\'red\');\r\n\r\n// 获取节点test下的所有直属子节点:\r\nvar cs = test.children;\r\n\r\n// 获取节点test下第一个、最后一个子节点：\r\nvar first = test.firstElementChild;\r\nvar last = test.lastElementChild;\r\n```\r\n\r\n第二种方法是使用`querySelector()`和`querySelectorAll()`，需要了解selector语法，然后使用条件来获取节点，更加方便：\r\n\r\n```\r\n// 通过querySelector获取ID为q1的节点：\r\nvar q1 = document.querySelector(\'#q1\');\r\n\r\n// 通过querySelectorAll获取q1节点内的符合条件的所有节点：\r\nvar ps = q1.querySelectorAll(\'div.highlighted > p\');\r\n```\r\n\r\n注意：低版本的IE<8不支持`querySelector`和`querySelectorAll`。IE8仅有限支持。\r\n\r\n严格地讲，我们这里的DOM节点是指`Element`，但是DOM节点实际上是`Node`，在HTML中，`Node`包括`Element`、`Comment`、`CDATA_SECTION`等很多种，以及根节点`Document`类型，但是，绝大多数时候我们只关心`Element`，也就是实际控制页面结构的`Node`，其他类型的`Node`忽略即可。根节点`Document`已经自动绑定为全局变量`document`。\r\n\r\n### 练习\r\n\r\n如下的HTML结构：\r\n\r\nJavaScript\r\n\r\nJava\r\n\r\nPython\r\n\r\nRuby\r\n\r\nSwift\r\n\r\nScheme\r\n\r\nHaskell\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-div\">\r\n<div class=\"c-red\">\r\n    <p id=\"test-p\">JavaScript</p>\r\n    <p>Java</p>\r\n  </div>\r\n  <div class=\"c-red c-green\">\r\n    <p>Python</p>\r\n    <p>Ruby</p>\r\n    <p>Swift</p>\r\n  </div>\r\n  <div class=\"c-green\">\r\n    <p>Scheme</p>\r\n    <p>Haskell</p>\r\n  </div>\r\n</div>\r\n```\r\n\r\n请选择出指定条件的节点：\r\n\r\n```\r\n\'use strict\'; ``// 测试: if (!js || js.innerText !== \'JavaScript\') {    alert(\'选择JavaScript失败!\'); } else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== \'Python\' || arr[1].innerText !== \'Ruby\' || arr[2].innerText !== \'Swift\') {    console.log(\'选择Python,Ruby,Swift失败!\'); } else if (!haskell || haskell.innerText !== \'Haskell\') {    console.log(\'选择Haskell失败!\'); } else {    console.log(\'测试通过!\'); } \r\n```\r\n\r\n#### 更新DOM\r\n\r\n阅读: 1094136\r\n\r\n------\r\n\r\n拿到一个DOM节点后，我们可以对它进行更新。\r\n\r\n可以直接修改节点的文本，方法有两种：\r\n\r\n一种是修改`innerHTML`属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：\r\n\r\n```\r\n// 获取<p id=\"p-id\">...</p>\r\nvar p = document.getElementById(\'p-id\');\r\n// 设置文本为abc:\r\np.innerHTML = \'ABC\'; // <p id=\"p-id\">ABC</p>\r\n// 设置HTML:\r\np.innerHTML = \'ABC <span style=\"color:red\">RED</span> XYZ\';\r\n// <p>...</p>的内部结构已修改\r\n```\r\n\r\n用`innerHTML`时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。\r\n\r\n第二种是修改`innerText`或`textContent`属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签：\r\n\r\n```\r\n// 获取<p id=\"p-id\">...</p>\r\nvar p = document.getElementById(\'p-id\');\r\n// 设置文本:\r\np.innerText = \'<script>alert(\"Hi\")</script>\';\r\n// HTML被自动编码，无法设置一个<script>节点:\r\n// <p id=\"p-id\">&lt;script&gt;alert(\"Hi\")&lt;/script&gt;</p>\r\n```\r\n\r\n两者的区别在于读取属性时，`innerText`不返回隐藏元素的文本，而`textContent`返回所有文本。另外注意IE<9不支持`textContent`。\r\n\r\n修改CSS也是经常需要的操作。DOM节点的`style`属性对应所有的CSS，可以直接获取或设置。因为CSS允许`font-size`这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名`fontSize`：\r\n\r\n```\r\n// 获取<p id=\"p-id\">...</p>\r\nvar p = document.getElementById(\'p-id\');\r\n// 设置CSS:\r\np.style.color = \'#ff0000\';\r\np.style.fontSize = \'20px\';\r\np.style.paddingTop = \'2em\';\r\n```\r\n\r\n### 练习\r\n\r\n有如下的HTML结构：\r\n\r\njavascript\r\n\r\nJava\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"test-div\">\r\n  <p id=\"test-js\">javascript</p>\r\n  <p>Java</p>\r\n</div>\r\n```\r\n\r\n请尝试获取指定节点并修改：\r\n\r\n`\'use strict\'; ``// 测试: if (js && js.parentNode && js.parentNode.id === \'test-div\' && js.id === \'test-js\') {    if (js.innerText === \'JavaScript\') {        if (js.style && js.style.fontWeight === \'bold\' && (js.style.color === \'red\' || js.style.color === \'#ff0000\' || js.style.color === \'#f00\' || js.style.color === \'rgb(255, 0, 0)\')) {            console.log(\'测试通过!\');        } else {            console.log(\'CSS样式测试失败!\');        }    } else {        console.log(\'文本测试失败!\');    } } else {    console.log(\'节点测试失败!\'); } ` Run\r\n\r\n#### 插入DOM\r\n\r\n阅读: 786307\r\n\r\n------\r\n\r\n当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？\r\n\r\n如果这个DOM节点是空的，例如，``，那么，直接使用`innerHTML = \'child\'`就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。\r\n\r\n如果这个DOM节点不是空的，那就不能这么做，因为`innerHTML`会直接替换掉原来的所有子节点。\r\n\r\n有两个办法可以插入新的节点。一个是使用`appendChild`，把一个子节点添加到父节点的最后一个子节点。例如：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<p id=\"js\">JavaScript</p>\r\n<div id=\"list\">\r\n    <p id=\"java\">Java</p>\r\n    <p id=\"python\">Python</p>\r\n    <p id=\"scheme\">Scheme</p>\r\n</div>\r\n```\r\n\r\n把`JavaScript`添加到``的最后一项：\r\n\r\n```\r\nvar\r\n    js = document.getElementById(\'js\'),\r\n    list = document.getElementById(\'list\');\r\nlist.appendChild(js);\r\n```\r\n\r\n现在，HTML结构变成了这样：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"list\">\r\n    <p id=\"java\">Java</p>\r\n    <p id=\"python\">Python</p>\r\n    <p id=\"scheme\">Scheme</p>\r\n    <p id=\"js\">JavaScript</p>\r\n</div>\r\n```\r\n\r\n因为我们插入的`js`节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。\r\n\r\n更多的时候我们会从零创建一个新的节点，然后插入到指定位置：\r\n\r\n```\r\nvar\r\n    list = document.getElementById(\'list\'),\r\n    haskell = document.createElement(\'p\');\r\nhaskell.id = \'haskell\';\r\nhaskell.innerText = \'Haskell\';\r\nlist.appendChild(haskell);\r\n```\r\n\r\n这样我们就动态添加了一个新的节点：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"list\">\r\n    <p id=\"java\">Java</p>\r\n    <p id=\"python\">Python</p>\r\n    <p id=\"scheme\">Scheme</p>\r\n    <p id=\"haskell\">Haskell</p>\r\n</div>\r\n```\r\n\r\n动态创建一个节点然后添加到DOM树中，可以实现很多功能。举个例子，下面的代码动态创建了一个``节点，然后把它添加到``节点的末尾，这样就动态地给文档添加了新的CSS定义：\r\n\r\n```\r\nvar d = document.createElement(\'style\');\r\nd.setAttribute(\'type\', \'text/css\');\r\nd.innerHTML = \'p { color: red }\';\r\ndocument.getElementsByTagName(\'head\')[0].appendChild(d);\r\n```\r\n\r\n可以在Chrome的控制台执行上述代码，观察页面样式的变化。\r\n\r\n### insertBefore\r\n\r\n如果我们要把子节点插入到指定的位置怎么办？可以使用`parentElement.insertBefore(newElement, referenceElement);`，子节点会插入到`referenceElement`之前。\r\n\r\n还是以上面的HTML为例，假定我们要把`Haskell`插入到`Python`之前：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"list\">\r\n    <p id=\"java\">Java</p>\r\n    <p id=\"python\">Python</p>\r\n    <p id=\"scheme\">Scheme</p>\r\n</div>\r\n```\r\n\r\n可以这么写：\r\n\r\n```\r\nvar\r\n    list = document.getElementById(\'list\'),\r\n    ref = document.getElementById(\'python\'),\r\n    haskell = document.createElement(\'p\');\r\nhaskell.id = \'haskell\';\r\nhaskell.innerText = \'Haskell\';\r\nlist.insertBefore(haskell, ref);\r\n```\r\n\r\n新的HTML结构如下：\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<div id=\"list\">\r\n    <p id=\"java\">Java</p>\r\n    <p id=\"haskell\">Haskell</p>\r\n    <p id=\"python\">Python</p>\r\n    <p id=\"scheme\">Scheme</p>\r\n</div>\r\n```\r\n\r\n可见，使用`insertBefore`重点是要拿到一个“参考子节点”的引用。很多时候，需要循环一个父节点的所有子节点，可以通过迭代`children`属性实现：\r\n\r\n```\r\nvar\r\n    i, c,\r\n    list = document.getElementById(\'list\');\r\nfor (i = 0; i < list.children.length; i++) {\r\n    c = list.children[i]; // 拿到第i个子节点\r\n}\r\n```\r\n\r\n### 练习\r\n\r\n对于一个已有的HTML结构：\r\n\r\n1. Scheme\r\n2. JavaScript\r\n3. Python\r\n4. Ruby\r\n5. Haskell\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<ol id=\"test-list\">\r\n    <li class=\"lang\">Scheme</li>\r\n    <li class=\"lang\">JavaScript</li>\r\n    <li class=\"lang\">Python</li>\r\n    <li class=\"lang\">Ruby</li>\r\n    <li class=\"lang\">Haskell</li>\r\n</ol>\r\n```\r\n\r\n按字符串顺序重新排序DOM节点：\r\n\r\n```\r\n// sort list:\r\nvar children_arr = [...document.getElementById(\'test-list\').children]\r\nconsole.log(children_arr );\r\nvar sorted = children_arr.map(x=>x.innerText).sort();\r\nconsole.log(sorted  )\r\nchildren_arr.map((x,i)=>{x.innerText=sorted [i];})\r\n```\r\n\r\n`\'use strict\'; ``// 测试: ;(function () {    var        arr, i,        t = document.getElementById(\'test-list\');    if (t && t.children && t.children.length === 5) {        arr = [];        for (i=0; i\r\n\r\n#### 删除DOM\r\n\r\n阅读: 554444\r\n\r\n------\r\n\r\n删除一个DOM节点就比插入要容易得多。\r\n\r\n要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的`removeChild`把自己删掉：\r\n\r\n```\r\n// 拿到待删除节点:\r\nvar self = document.getElementById(\'to-be-removed\');\r\n// 拿到父节点:\r\nvar parent = self.parentElement;\r\n// 删除:\r\nvar removed = parent.removeChild(self);\r\nremoved === self; // true\r\n```\r\n\r\n注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。\r\n\r\n当你遍历一个父节点的子节点并进行删除操作时，要注意，`children`属性是一个只读属性，并且它在子节点变化时会实时更新。\r\n\r\n例如，对于如下HTML结构：\r\n\r\n```\r\n<div id=\"parent\">\r\n    <p>First</p>\r\n    <p>Second</p>\r\n</div>\r\n```\r\n\r\n当我们用如下代码删除子节点时：\r\n\r\n```\r\nvar parent = document.getElementById(\'parent\');\r\nparent.removeChild(parent.children[0]);\r\nparent.removeChild(parent.children[1]); // <-- 浏览器报错\r\n```\r\n\r\n浏览器报错：`parent.children[1]`不是一个有效的节点。原因就在于，当`First`节点被删除后，`parent.children`的节点数量已经从2变为了1，索引`[1]`已经不存在了。\r\n\r\n因此，删除多个节点时，要注意`children`属性时刻都在变化。\r\n\r\n### 练习\r\n\r\n- JavaScript\r\n- Swift\r\n- HTML\r\n- ANSI C\r\n- CSS\r\n- DirectX\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<ul id=\"test-list\">\r\n    <li>JavaScript</li>\r\n    <li>Swift</li>\r\n    <li>HTML</li>\r\n    <li>ANSI C</li>\r\n    <li>CSS</li>\r\n    <li>DirectX</li>\r\n</ul>\r\n```\r\n\r\n把与Web开发技术不相关的节点删掉：\r\n\r\n```\r\n// TODO\r\nvar parent = document.querySelector(\'#test-list\');\r\nvar children = [...parent.children].forEach(e => {\r\n\tif (!/javascript|html|css/.test(e.innerText.toLowerCase())) {\r\n        parent.removeChild(e);\r\n\t}\r\n});\r\n```\r\n\r\n`\'use strict\'; ``// 测试: ;(function () {    var        arr, i,        t = document.getElementById(\'test-list\');    if (t && t.children && t.children.length === 3) {        arr = [];        for (i = 0; i < t.children.length; i ++) {            arr.push(t.children[i].innerText);        }        if (arr.toString() === [\'JavaScript\', \'HTML\', \'CSS\'].toString()) {            console.log(\'测试通过!\');        }        else {            console.log(\'测试失败: \' + arr.toString());        }    }    else {        console.log(\'测试失败!\');    } })(); ` Run","timestamp":1590329650947},{"name":"114-Promise.md","path":"13-语言学习project/11-JavaScript/5-浏览器/114-Promise.md","content":"#### Promise\r\n\r\n阅读: 101107225\r\n\r\n------\r\n\r\n在JavaScript的世界中，所有代码都是单线程执行的。\r\n\r\n由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：\r\n\r\n```\r\nfunction callback() {\r\n    console.log(\'Done\');\r\n}\r\nconsole.log(\'before setTimeout()\');\r\nsetTimeout(callback, 1000); // 1秒钟后调用callback函数\r\nconsole.log(\'after setTimeout()\');\r\n```\r\n\r\n观察上述代码执行，在Chrome的控制台输出可以看到：\r\n\r\n```\r\nbefore setTimeout()\r\nafter setTimeout()\r\n(等待1秒后)\r\nDone\r\n```\r\n\r\n可见，异步操作会在将来的某个时间点触发一个函数调用。\r\n\r\nAJAX就是典型的异步操作。以上一节的代码为例：\r\n\r\n```\r\nrequest.onreadystatechange = function () {\r\n    if (request.readyState === 4) {\r\n        if (request.status === 200) {\r\n            return success(request.responseText);\r\n        } else {\r\n            return fail(request.status);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n把回调函数`success(request.responseText)`和`fail(request.status)`写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。\r\n\r\n有没有更好的写法？比如写成这样：\r\n\r\n```\r\nvar ajax = ajaxGet(\'http://...\');\r\najax.ifSuccess(success)\r\n    .ifFail(fail);\r\n```\r\n\r\n这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用`success`函数或`fail`函数。\r\n\r\n古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。\r\n\r\nPromise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：\r\n\r\n`\'use strict\'; new Promise(function () {}); ` Run\r\n\r\n我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：\r\n\r\n```\r\nfunction test(resolve, reject) {\r\n    var timeOut = Math.random() * 2;\r\n    log(\'set timeout to: \' + timeOut + \' seconds.\');\r\n    setTimeout(function () {\r\n        if (timeOut < 1) {\r\n            log(\'call resolve()...\');\r\n            resolve(\'200 OK\');\r\n        }\r\n        else {\r\n            log(\'call reject()...\');\r\n            reject(\'timeout in \' + timeOut + \' seconds.\');\r\n        }\r\n    }, timeOut * 1000);\r\n}\r\n```\r\n\r\n这个`test()`函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用`resolve(\'200 OK\')`，如果执行失败，我们将调用`reject(\'timeout in \' + timeOut + \' seconds.\')`。可以看出，`test()`函数只关心自身的逻辑，并不关心具体的`resolve`和`reject`将如何处理结果。\r\n\r\n有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果：\r\n\r\n```\r\nvar p1 = new Promise(test);\r\nvar p2 = p1.then(function (result) {\r\n    console.log(\'成功：\' + result);\r\n});\r\nvar p3 = p2.catch(function (reason) {\r\n    console.log(\'失败：\' + reason);\r\n});\r\n```\r\n\r\n变量`p1`是一个Promise对象，它负责执行`test`函数。由于`test`函数在内部是异步执行的，当`test`函数执行成功时，我们告诉Promise对象：\r\n\r\n```\r\n// 如果成功，执行这个函数：\r\np1.then(function (result) {\r\n    console.log(\'成功：\' + result);\r\n});\r\n```\r\n\r\n当`test`函数执行失败时，我们告诉Promise对象：\r\n\r\n```\r\np2.catch(function (reason) {\r\n    console.log(\'失败：\' + reason);\r\n});\r\n```\r\n\r\nPromise对象可以串联起来，所以上述代码可以简化为：\r\n\r\n```\r\nnew Promise(test).then(function (result) {\r\n    console.log(\'成功：\' + result);\r\n}).catch(function (reason) {\r\n    console.log(\'失败：\' + reason);\r\n});\r\n```\r\n\r\n实际测试一下，看看Promise是如何异步执行的：\r\n\r\n`\'use strict\'; // 清除log: var logging = document.getElementById(\'test-promise-log\'); while (logging.children.length > 1) {    logging.removeChild(logging.children[logging.children.length - 1]); } // 输出log到页面: function log(s) {    var p = document.createElement(\'p\');    p.innerHTML = s;    logging.appendChild(p); } ` Run\r\n\r\nLog:\r\n\r\n可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：\r\n\r\n![promise](D:\\Typora_pic\\l-1585994638019.png)\r\n\r\nPromise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。\r\n\r\n要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：\r\n\r\n```\r\njob1.then(job2).then(job3).catch(handleError);\r\n```\r\n\r\n其中，`job1`、`job2`和`job3`都是Promise对象。\r\n\r\n下面的例子演示了如何串行执行一系列需要异步计算获得结果的任务：\r\n\r\n`\'use strict\'; var logging = document.getElementById(\'test-promise2-log\'); while (logging.children.length > 1) {    logging.removeChild(logging.children[logging.children.length - 1]); } function log(s) {    var p = document.createElement(\'p\');    p.innerHTML = s;    logging.appendChild(p); } ` Run\r\n\r\nLog:\r\n\r\n`setTimeout`可以看成一个模拟网络等异步执行的函数。现在，我们把上一节的AJAX异步执行函数转换为Promise对象，看看用Promise如何简化异步处理：\r\n\r\n`\'use strict\'; // ajax函数将返回Promise对象: function ajax(method, url, data) {    var request = new XMLHttpRequest();    return new Promise(function (resolve, reject) {        request.onreadystatechange = function () {            if (request.readyState === 4) {                if (request.status === 200) {                    resolve(request.responseText);                } else {                    reject(request.status);                }            }        };        request.open(method, url);        request.send(data);    }); } ` Run\r\n\r\nResult:\r\n\r\n除了串行执行若干异步任务外，Promise还可以并行执行异步任务。\r\n\r\n试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用`Promise.all()`实现如下：\r\n\r\n```\r\nvar p1 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 500, \'P1\');\r\n});\r\nvar p2 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 600, \'P2\');\r\n});\r\n// 同时执行p1和p2，并在它们都完成后执行then:\r\nPromise.all([p1, p2]).then(function (results) {\r\n    console.log(results); // 获得一个Array: [\'P1\', \'P2\']\r\n});\r\n```\r\n\r\n有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用`Promise.race()`实现：\r\n\r\n```\r\nvar p1 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 500, \'P1\');\r\n});\r\nvar p2 = new Promise(function (resolve, reject) {\r\n    setTimeout(resolve, 600, \'P2\');\r\n});\r\nPromise.race([p1, p2]).then(function (result) {\r\n    console.log(result); // \'P1\'\r\n});\r\n```\r\n\r\n由于`p1`执行较快，Promise的`then()`将获得结果`\'P1\'`。`p2`仍在继续执行，但执行结果将被丢弃。\r\n\r\n如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。","timestamp":1590329650947},{"name":"115-操作文件按.md","path":"13-语言学习project/11-JavaScript/5-浏览器/115-操作文件按.md","content":"#### 操作文件\r\n\r\n阅读: 1030731\r\n\r\n------\r\n\r\n在HTML表单中，可以上传文件的唯一控件就是``。\r\n\r\n*注意*：当一个表单包含``时，表单的`enctype`必须指定为`multipart/form-data`，`method`必须指定为`post`，浏览器才能正确编码并以`multipart/form-data`格式发送表单的数据。\r\n\r\n出于安全考虑，浏览器只允许用户点击``来选择本地文件，用JavaScript对``的`value`赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径：\r\n\r\n\r\n\r\n待上传文件:\r\n\r\n通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：\r\n\r\n```\r\nvar f = document.getElementById(\'test-file-upload\');\r\nvar filename = f.value; // \'C:\\fakepath\\test.png\'\r\nif (!filename || !(filename.endsWith(\'.jpg\') || filename.endsWith(\'.png\') || filename.endsWith(\'.gif\'))) {\r\n    alert(\'Can only upload image file.\');\r\n    return false;\r\n}\r\n```\r\n\r\n### File API\r\n\r\n由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。\r\n\r\n随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。\r\n\r\nHTML5的File API提供了`File`和`FileReader`两个主要对象，可以获得文件信息并读取文件。\r\n\r\n下面的例子演示了如何读取用户选取的图片文件，并在一个``中预览图像：\r\n\r\n图片预览：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n```\r\nvar\r\n    fileInput = document.getElementById(\'test-image-file\'),\r\n    info = document.getElementById(\'test-file-info\'),\r\n    preview = document.getElementById(\'test-image-preview\');\r\n// 监听change事件:\r\nfileInput.addEventListener(\'change\', function () {\r\n    // 清除背景图片:\r\n    preview.style.backgroundImage = \'\';\r\n    // 检查文件是否选择:\r\n    if (!fileInput.value) {\r\n        info.innerHTML = \'没有选择文件\';\r\n        return;\r\n    }\r\n    // 获取File引用:\r\n    var file = fileInput.files[0];\r\n    // 获取File信息:\r\n    info.innerHTML = \'文件: \' + file.name + \'<br>\' +\r\n                     \'大小: \' + file.size + \'<br>\' +\r\n                     \'修改: \' + file.lastModifiedDate;\r\n    if (file.type !== \'image/jpeg\' && file.type !== \'image/png\' && file.type !== \'image/gif\') {\r\n        alert(\'不是有效的图片文件!\');\r\n        return;\r\n    }\r\n    // 读取文件:\r\n    var reader = new FileReader();\r\n    reader.onload = function(e) {\r\n        var\r\n            data = e.target.result; // \'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...\'            \r\n        preview.style.backgroundImage = \'url(\' + data + \')\';\r\n    };\r\n    // 以DataURL的形式读取文件:\r\n    reader.readAsDataURL(file);\r\n});\r\n```\r\n\r\n上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于`data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...`，常用于设置图像。如果需要服务器端处理，把字符串`base64,`后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。\r\n\r\n### 回调\r\n\r\n上面的代码还演示了JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。\r\n\r\n你可能会问，单线程模式执行的JavaScript，如何处理多任务？\r\n\r\n在JavaScript中，执行多任务实际上都是异步调用，比如上面的代码：\r\n\r\n```\r\nreader.readAsDataURL(file);\r\n```\r\n\r\n就会发起一个异步操作来读取文件内容。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：\r\n\r\n```\r\nreader.onload = function(e) {\r\n    // 当文件读取完成后，自动调用此函数:\r\n};\r\n```\r\n\r\n当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。","timestamp":1590329650947},{"name":"116-浏览器对象.md","path":"13-语言学习project/11-JavaScript/5-浏览器/116-浏览器对象.md","content":"#### 浏览器\r\n\r\n阅读: 2739854\r\n\r\n------\r\n\r\n由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。\r\n\r\n目前主流的浏览器分这么几种：\r\n\r\n- IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；\r\n- Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；\r\n- Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6；\r\n- Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；\r\n- 移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。\r\n\r\n其他浏览器如Opera等由于市场份额太小就被自动忽略了。\r\n\r\n另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。\r\n\r\n不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。\r\n\r\n在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。\r\n\r\n#### 浏览器对象\r\n\r\n阅读: 3435443\r\n\r\n------\r\n\r\nJavaScript可以获取浏览器提供的很多对象，并进行操作。\r\n\r\n### window\r\n\r\n`window`对象不但充当全局作用域，而且表示浏览器窗口。\r\n\r\n`window`对象有`innerWidth`和`innerHeight`属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。\r\n\r\n兼容性：IE<=8不支持。\r\n\r\n```\r\n\'use strict\';\r\n```\r\n\r\n Run\r\n\r\nwindow inner size: 1517 x 736\r\n\r\n对应的，还有一个`outerWidth`和`outerHeight`属性，可以获取浏览器窗口的整个宽高。\r\n\r\n### navigator\r\n\r\n`navigator`对象表示浏览器的信息，最常用的属性包括：\r\n\r\n- navigator.appName：浏览器名称；\r\n- navigator.appVersion：浏览器版本；\r\n- navigator.language：浏览器设置的语言；\r\n- navigator.platform：操作系统类型；\r\n- navigator.userAgent：浏览器设定的`User-Agent`字符串。\r\n\r\n`\'use strict\'; ` Run\r\n\r\n*请注意*，`navigator`的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用`if`判断浏览器版本，例如：\r\n\r\n```\r\nvar width;\r\nif (getIEVersion(navigator.userAgent) < 9) {\r\n    width = document.body.clientWidth;\r\n} else {\r\n    width = window.innerWidth;\r\n}\r\n```\r\n\r\n但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回`undefined`的特性，直接用短路运算符`||`计算：\r\n\r\n```\r\nvar width = window.innerWidth || document.body.clientWidth;\r\n```\r\n\r\n### screen\r\n\r\n`screen`对象表示屏幕的信息，常用的属性有：\r\n\r\n- screen.width：屏幕宽度，以像素为单位；\r\n- screen.height：屏幕高度，以像素为单位；\r\n- screen.colorDepth：返回颜色位数，如8、16、24。\r\n\r\n`\'use strict\'; ` Run\r\n\r\n### location\r\n\r\n`location`对象表示当前页面的URL信息。例如，一个完整的URL：\r\n\r\n```\r\nhttp://www.example.com:8080/path/index.html?a=1&b=2#TOP\r\n```\r\n\r\n可以用`location.href`获取。要获得URL各个部分的值，可以这么写：\r\n\r\n```\r\nlocation.protocol; // \'http\'\r\nlocation.host; // \'www.example.com\'\r\nlocation.port; // \'8080\'\r\nlocation.pathname; // \'/path/index.html\'\r\nlocation.search; // \'?a=1&b=2\'\r\nlocation.hash; // \'TOP\'\r\n```\r\n\r\n要加载一个新页面，可以调用`location.assign()`。如果要重新加载当前页面，调用`location.reload()`方法非常方便。\r\n\r\n`\'use strict\'; ` Run\r\n\r\n### document\r\n\r\n`document`对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，`document`对象就是整个DOM树的根节点。\r\n\r\n`document`的`title`属性是从HTML文档中的`xxx`读取的，但是可以动态改变：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n请观察浏览器窗口标题的变化。\r\n\r\n要查找DOM树的某个节点，需要从`document`对象开始查找。最常用的查找是根据ID和Tag Name。\r\n\r\n我们先准备HTML数据：\r\n\r\n```\r\n<dl id=\"drink-menu\" style=\"border:solid 1px #ccc;padding:6px;\">\r\n    <dt>摩卡</dt>\r\n    <dd>热摩卡咖啡</dd>\r\n    <dt>酸奶</dt>\r\n    <dd>北京老酸奶</dd>\r\n    <dt>果汁</dt>\r\n    <dd>鲜榨苹果汁</dd>\r\n</dl>\r\n```\r\n\r\n用`document`对象提供的`getElementById()`和`getElementsByTagName()`可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n- 摩卡\r\n\r\n  热摩卡咖啡\r\n\r\n- 酸奶\r\n\r\n  北京老酸奶\r\n\r\n- 果汁\r\n\r\n  鲜榨苹果汁\r\n\r\n`document`对象还有一个`cookie`属性，可以获取当前页面的Cookie。\r\n\r\nCookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如`user=ABC123XYZ(加密的字符串)...`，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。\r\n\r\nCookie还可以存储网站的一些设置，例如，页面显示的语言等等。\r\n\r\nJavaScript可以通过`document.cookie`读取到当前页面的Cookie：\r\n\r\n```\r\ndocument.cookie; // \'v=123; remember=true; prefer=zh\'\r\n```\r\n\r\n由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：\r\n\r\n```\r\n<!-- 当前页面在wwwexample.com -->\r\n<html>\r\n    <head>\r\n        <script src=\"http://www.foo.com/jquery.js\"></script>\r\n    </head>\r\n    ...\r\n</html>\r\n```\r\n\r\n如果引入的第三方的JavaScript中存在恶意代码，则`www.foo.com`网站将直接获取到`www.example.com`网站的用户登录信息。\r\n\r\n为了解决这个问题，服务器在设置Cookie时可以使用`httpOnly`，设定了`httpOnly`的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持`httpOnly`选项，IE从IE6 SP1开始支持。\r\n\r\n为了确保安全，服务器端在设置Cookie时，应该始终坚持使用`httpOnly`。\r\n\r\n### history\r\n\r\n`history`对象保存了浏览器的历史记录，JavaScript可以调用`history`对象的`back()`或`forward ()`，相当于用户点击了浏览器的“后退”或“前进”按钮。\r\n\r\n这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用`history.back()`可能会让用户感到非常愤怒。\r\n\r\n新手开始设计Web页面时喜欢在登录页登录成功时调用`history.back()`，试图回到登录前的页面。这是一种错误的方法。\r\n\r\n任何情况，你都不应该使用`history`这个对象了。","timestamp":1590329650947},{"name":"117-表单.md","path":"13-语言学习project/11-JavaScript/5-浏览器/117-表单.md","content":"#### 操作表单\r\n\r\n阅读: 1867205\r\n\r\n------\r\n\r\n用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。\r\n\r\n不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。\r\n\r\nHTML表单的输入控件主要有以下几种：\r\n\r\n- 文本框，对应的``，用于输入文本；\r\n- 口令框，对应的``，用于输入口令；\r\n- 单选框，对应的``，用于选择一项；\r\n- 复选框，对应的``，用于选择多项；\r\n- 下拉框，对应的``，用于选择一项；\r\n- 隐藏文本，对应的``，用户不可见，但表单提交时会把隐藏文本发送到服务器。\r\n\r\n### 获取值\r\n\r\n如果我们获得了一个``节点的引用，就可以直接调用`value`获得对应的用户输入值：\r\n\r\n```\r\n// <input type=\"text\" id=\"email\">\r\nvar input = document.getElementById(\'email\');\r\ninput.value; // \'用户输入的值\'\r\n```\r\n\r\n这种方式可以应用于`text`、`password`、`hidden`以及`select`。但是，对于单选框和复选框，`value`属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用`checked`判断：\r\n\r\n```\r\n// <label><input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"> Monday</label>\r\n// <label><input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"> Tuesday</label>\r\nvar mon = document.getElementById(\'monday\');\r\nvar tue = document.getElementById(\'tuesday\');\r\nmon.value; // \'1\'\r\ntue.value; // \'2\'\r\nmon.checked; // true或者false\r\ntue.checked; // true或者false\r\n```\r\n\r\n### 设置值\r\n\r\n设置值和获取值类似，对于`text`、`password`、`hidden`以及`select`，直接设置`value`就可以：\r\n\r\n```\r\n// <input type=\"text\" id=\"email\">\r\nvar input = document.getElementById(\'email\');\r\ninput.value = \'test@example.com\'; // 文本框的内容已更新\r\n```\r\n\r\n对于单选框和复选框，设置`checked`为`true`或`false`即可。\r\n\r\n### HTML5控件\r\n\r\nHTML5新增了大量标准控件，常用的包括`date`、`datetime`、`datetime-local`、`color`等，它们都使用``标签：\r\n\r\n```\r\n<input type=\"date\" value=\"2015-07-01\">\r\n<input type=\"datetime-local\" value=\"2015-07-01T02:03:04\">\r\n<input type=\"color\" value=\"#ff0000\">\r\n```\r\n\r\n不支持HTML5的浏览器无法识别新的控件，会把它们当做`type=\"text\"`来显示。支持HTML5的浏览器将获得格式化的字符串。例如，`type=\"date\"`类型的`input`的`value`将保证是一个有效的`YYYY-MM-DD`格式的日期，或者空字符串。\r\n\r\n### 提交表单\r\n\r\n最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。\r\n\r\n方式一是通过``元素的`submit()`方法提交一个表单，例如，响应一个``的`click`事件，在JavaScript代码中提交表单：\r\n\r\n```\r\n<!-- HTML -->\r\n<form id=\"test-form\">\r\n    <input type=\"text\" name=\"test\">\r\n    <button type=\"button\" onclick=\"doSubmitForm()\">Submit</button>\r\n</form>\r\n\r\n<script>\r\nfunction doSubmitForm() {\r\n    var form = document.getElementById(\'test-form\');\r\n    // 可以在此修改form的input...\r\n    // 提交form:\r\n    form.submit();\r\n}\r\n</script>\r\n```\r\n\r\n这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击``时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应``本身的`onsubmit`事件，在提交form时作修改：\r\n\r\n```\r\n<!-- HTML -->\r\n<form id=\"test-form\" onsubmit=\"return checkForm()\">\r\n    <input type=\"text\" name=\"test\">\r\n    <button type=\"submit\">Submit</button>\r\n</form>\r\n\r\n<script>\r\nfunction checkForm() {\r\n    var form = document.getElementById(\'test-form\');\r\n    // 可以在此修改form的input...\r\n    // 继续下一步:\r\n    return true;\r\n}\r\n</script>\r\n```\r\n\r\n注意要`return true`来告诉浏览器继续提交，如果`return false`，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。\r\n\r\n在检查和修改``时，要充分利用``来传递数据。\r\n\r\n例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改``：\r\n\r\n```\r\n<!-- HTML -->\r\n<form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\">\r\n    <input type=\"text\" id=\"username\" name=\"username\">\r\n    <input type=\"password\" id=\"password\" name=\"password\">\r\n    <button type=\"submit\">Submit</button>\r\n</form>\r\n\r\n<script>\r\nfunction checkForm() {\r\n    var pwd = document.getElementById(\'password\');\r\n    // 把用户输入的明文变为MD5:\r\n    pwd.value = toMD5(pwd.value);\r\n    // 继续下一步:\r\n    return true;\r\n}\r\n</script>\r\n```\r\n\r\n这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个`*`变成32个`*`（因为MD5有32个字符）。\r\n\r\n要想不改变用户的输入，可以利用``实现：\r\n\r\n```\r\n<!-- HTML -->\r\n<form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\">\r\n    <input type=\"text\" id=\"username\" name=\"username\">\r\n    <input type=\"password\" id=\"input-password\">\r\n    <input type=\"hidden\" id=\"md5-password\" name=\"password\">\r\n    <button type=\"submit\">Submit</button>\r\n</form>\r\n\r\n<script>\r\nfunction checkForm() {\r\n    var input_pwd = document.getElementById(\'input-password\');\r\n    var md5_pwd = document.getElementById(\'md5-password\');\r\n    // 把用户输入的明文变为MD5:\r\n    md5_pwd.value = toMD5(input_pwd.value);\r\n    // 继续下一步:\r\n    return true;\r\n}\r\n</script>\r\n```\r\n\r\n注意到`id`为`md5-password`的``标记了`name=\"password\"`，而用户输入的`id`为`input-password`的``没有`name`属性。没有`name`属性的``的数据不会被提交。\r\n\r\n### 练习\r\n\r\n利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单：\r\n\r\n- 用户名必须是3-10位英文字母或数字；\r\n- 口令必须是6-20位；\r\n- 两次输入口令必须一致。\r\n\r\n```\r\n<!-- HTML结构 -->\r\n<form id=\"test-register\" action=\"#\" target=\"_blank\" onsubmit=\"return checkRegisterForm()\">\r\n    <p id=\"test-error\" style=\"color:red\"></p>\r\n    <p>\r\n        用户名: <input type=\"text\" id=\"username\" name=\"username\">\r\n    </p>\r\n    <p>\r\n        口令: <input type=\"password\" id=\"password\" name=\"password\">\r\n    </p>\r\n    <p>\r\n        重复口令: <input type=\"password\" id=\"password-2\">\r\n    </p>\r\n    <p>\r\n        <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n    </p>\r\n</form>\r\n```\r\n\r\n\r\n\r\n用户名: \r\n\r\n口令: \r\n\r\n重复口令: \r\n\r\n提交 重置\r\n\r\n`\'use strict\'; var checkRegisterForm = function () { `\r\n\r\n```\r\n  var \r\n        re1 = /^\\w{3,10}$/;\r\n        re2 = /^.{6,20}$/;\r\n        user = document.getElementById(\'username\');\r\n        pwd = document.getElementById(\'password\');\r\n        pwd2 = document.getElementById(\'password-2\');\r\n    if ( re1.test(user.value) && re2.test(pwd.value) && pwd.value === pwd2.value ) {\r\n        return true;\r\n    } else { \r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n ```// 测试: ;(function () {    window.testFormHandler = checkRegisterForm;    var form = document.getElementById(\'test-register\');    if (form.dispatchEvent) {        var event = new Event(\'submit\', {    \t\tbubbles: true,    \t\tcancelable: true  \t\t});        form.dispatchEvent(event);    } else {        form.fireEvent(\'onsubmit\');    } })(); ` Run","timestamp":1590329650947},{"name":"118-异步错误处理.md","path":"13-语言学习project/11-JavaScript/6-错误/118-异步错误处理.md","content":"#### 异步错误处理\r\n\r\n------\r\n\r\n编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。\r\n\r\n例如，`setTimeout()`函数可以传入回调函数，并在指定若干毫秒后执行：\r\n\r\n```\r\nfunction printTime() {\r\n    console.log(\'It is time!\');\r\n}\r\n\r\nsetTimeout(printTime, 1000);\r\nconsole.log(\'done\');\r\n```\r\n\r\n上面的代码会先打印`done`，1秒后才会打印`It is time!`。\r\n\r\n如果`printTime()`函数内部发生了错误，我们试图用try包裹`setTimeout()`是无效的：\r\n\r\n`\'use strict\'; ``// 直接运行，看是否会alert ` Run\r\n\r\n原因就在于调用`setTimeout()`函数时，传入的`printTime`函数并未立刻执行！紧接着，JavaScript引擎会继续执行`console.log(\'done\');`语句，而此时并没有错误发生。直到1秒钟后，执行`printTime`函数时才发生错误，但此时除了在`printTime`函数内部捕获错误外，外层代码并无法捕获。\r\n\r\n所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。\r\n\r\n类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。\r\n\r\n例如，针对以下的表单：\r\n\r\n```\r\n<form>\r\n    <input id=\"x\"> + <input id=\"y\">\r\n    <button id=\"calc\" type=\"button\">计算</button>\r\n</form>\r\n```\r\n\r\n \\+ 计算\r\n\r\n我们用下面的代码给button绑定click事件：\r\n\r\n`\'use strict\'; var $btn = $(\'#calc\'); // 取消已绑定的事件: $btn.off(\'click\'); ` Run\r\n\r\n但是，用户输入错误时，处理函数并未捕获到错误。请修复错误处理代码。\r\n\r\n```JavaScript\r\n$btn.click(function () {\r\n    try {\r\n        var\r\n            x = parseFloat($(\'#x\').val()),\r\n            y = parseFloat($(\'#y\').val()),\r\n            r;\r\n        if (isNaN(x) || isNaN(y)) {\r\n            throw new Error(\'输入有误\');\r\n        }\r\n        r = x + y;\r\n        alert(\'计算结果：\' + r);\r\n    } catch (e) {\r\n        alert(\'输入有误！\');\r\n    }\r\n});\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"119-错误处理.md","path":"13-语言学习project/11-JavaScript/6-错误/119-错误处理.md","content":"#### 错误处理\r\n\r\n------\r\n\r\n在执行JavaScript代码的时候，有些情况下会发生错误。\r\n\r\n错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如：\r\n\r\n```\r\nvar s = null;\r\nvar len = s.length; // TypeError：null变量没有length属性\r\n```\r\n\r\n对于这种错误，要修复程序。\r\n\r\n一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。\r\n\r\n对于这种错误，我们需要处理它，并可能需要给用户反馈。\r\n\r\n错误处理是程序设计时必须要考虑的问题。对于C这样贴近系统底层的语言，错误是通过错误码返回的：\r\n\r\n```\r\nint fd = open(\"/path/to/file\", O_RDONLY);\r\nif (fd == -1) {\r\n    printf(\"Error when open file!\");\r\n} else {\r\n    // TODO\r\n}\r\n```\r\n\r\n通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的`open()`函数约定返回`-1`表示错误。\r\n\r\n显然，这种用错误码表示错误在编写程序时十分不便。\r\n\r\n因此，高级语言通常都提供了更抽象的错误处理逻辑try ... catch ... finally，JavaScript也不例外。\r\n\r\n### try ... catch ... finally\r\n\r\n使用try ... catch ... finally处理错误时，我们编写的代码如下：\r\n\r\n`\'use strict\'; ``// 直接运行 ` Run\r\n\r\n运行后可以发现，输出提示类似“出错了：TypeError: Cannot read property \'length\' of null”。\r\n\r\n我们来分析一下使用try ... catch ... finally的执行流程。\r\n\r\n当代码块被`try { ... }`包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到`catch`块。`catch (e) { ... }`包裹的代码就是错误处理代码，变量`e`表示捕获到的错误。最后，无论有没有错误，`finally`一定会被执行。\r\n\r\n所以，有错误发生时，执行流程像这样：\r\n\r\n1. 先执行`try { ... }`的代码；\r\n2. 执行到出错的语句时，后续语句不再继续执行，转而执行`catch (e) { ... }`代码；\r\n3. 最后执行`finally { ... }`代码。\r\n\r\n而没有错误发生时，执行流程像这样：\r\n\r\n1. 先执行`try { ... }`的代码；\r\n2. 因为没有出错，`catch (e) { ... }`代码不会被执行；\r\n3. 最后执行`finally { ... }`代码。\r\n\r\n最后请注意，`catch`和`finally`可以不必都出现。也就是说，`try`语句一共有三种形式：\r\n\r\n完整的try ... catch ... finally：\r\n\r\n```\r\ntry {\r\n    ...\r\n} catch (e) {\r\n    ...\r\n} finally {\r\n    ...\r\n}\r\n```\r\n\r\n只有try ... catch，没有finally：\r\n\r\n```\r\ntry {\r\n    ...\r\n} catch (e) {\r\n    ...\r\n}\r\n```\r\n\r\n只有try ... finally，没有catch：\r\n\r\n```\r\ntry {\r\n    ...\r\n} finally {\r\n    ...\r\n}\r\n```\r\n\r\n### 错误类型\r\n\r\nJavaScript有一个标准的`Error`对象表示错误，还有从`Error`派生的`TypeError`、`ReferenceError`等错误对象。我们在处理错误时，可以通过`catch(e)`捕获的变量`e`访问错误对象：\r\n\r\n```\r\ntry {\r\n    ...\r\n} catch (e) {\r\n    if (e instanceof TypeError) {\r\n        alert(\'Type error!\');\r\n    } else if (e instanceof Error) {\r\n        alert(e.message);\r\n    } else {\r\n        alert(\'Error: \' + e);\r\n    }\r\n}\r\n```\r\n\r\n使用变量`e`是一个习惯用法，也可以以其他变量名命名，如`catch(ex)`。\r\n\r\n### 抛出错误\r\n\r\n程序也可以主动抛出一个错误，让执行流程直接跳转到`catch`块。抛出错误使用`throw`语句。\r\n\r\n例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用`parseInt()`转换为整数。当用户输入不合法的时候，我们就抛出错误：\r\n\r\n`\'use strict\'; ``// 直接运行 ` Run\r\n\r\n实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。\r\n\r\n最后，当我们用catch捕获错误时，一定要编写错误处理语句：\r\n\r\n```\r\nvar n = 0, s;\r\ntry {\r\n    n = s.length;\r\n} catch (e) {\r\n    console.log(e);\r\n}\r\nconsole.log(n);\r\n```\r\n\r\n哪怕仅仅把错误打印出来，也不要什么也不干：\r\n\r\n```\r\nvar n = 0, s;\r\ntry {\r\n    n = s.length;\r\n} catch (e) {\r\n}\r\nconsole.log(n);\r\n```\r\n\r\n因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。\r\n\r\n处理错误时，请不要简单粗暴地用`alert()`把错误显示给用户。教程的代码使用`alert()`是为了便于演示。\r\n\r\n#### 错误传播\r\n\r\n------\r\n\r\n如果代码发生了错误，又没有被try ... catch捕获，那么，程序执行流程会跳转到哪呢？\r\n\r\n```\r\nfunction getLength(s) {\r\n    return s.length;\r\n}\r\n\r\nfunction printLength() {\r\n    console.log(getLength(\'abc\')); // 3\r\n    console.log(getLength(null)); // Error!\r\n}\r\n\r\nprintLength();\r\n```\r\n\r\n如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。\r\n\r\n所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽：\r\n\r\n`\'use strict\'; ``// 直接运行，观察控制台输出 ` Run\r\n\r\n```JavaScript\r\nfunction main(s) {\r\n    console.log(\'BEGIN main()\');\r\n    try {\r\n        foo(s);\r\n    } catch (e) {\r\n        console.log(\'出错了：\' + e);\r\n    }\r\n    console.log(\'END main()\');\r\n}\r\n\r\nfunction foo(s) {\r\n    console.log(\'BEGIN foo()\');\r\n    bar(s);\r\n    console.log(\'END foo()\');\r\n}\r\n\r\nfunction bar(s) {\r\n    console.log(\'BEGIN bar()\');\r\n    console.log(\'length = \' + s.length);\r\n    console.log(\'END bar()\');\r\n}\r\n\r\nmain(null);\r\n\r\n```\r\n\r\n当`bar()`函数传入参数`null`时，代码会报错，错误会向上抛给调用方`foo()`函数，`foo()`函数没有try ... catch语句，所以错误继续向上抛给调用方`main()`函数，`main()`函数有try ... catch语句，所以错误最终在`main()`函数被处理了。\r\n\r\n至于在哪些地方捕获错误比较合适，需要视情况而定。","timestamp":1590329650947},{"name":"67-generater.md","path":"13-语言学习project/11-JavaScript/67-generater.md","content":"#### generator\r\n\r\n------\r\n\r\ngenerator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。\r\n\r\nES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。如果你对Python还不熟，赶快恶补[Python教程](http://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128)！。\r\n\r\n我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：\r\n\r\n```\r\nfunction foo(x) {\r\n    return x + x;\r\n}\r\n\r\nvar r = foo(1); // 调用foo函数\r\n```\r\n\r\n函数在执行过程中，如果没有遇到`return`语句（函数末尾如果没有`return`，就是隐含的`return undefined;`），控制权无法交回被调用的代码。\r\n\r\ngenerator跟函数很像，定义如下：\r\n\r\n```\r\nfunction* foo(x) {\r\n    yield x + 1;\r\n    yield x + 2;\r\n    return x + 3;\r\n}\r\n```\r\n\r\ngenerator和函数不同的是，generator由`function*`定义（注意多出的`*`号），并且，除了`return`语句，还可以用`yield`返回多次。\r\n\r\n大多数同学立刻就晕了，generator就是能够返回多次的“函数”？返回多次有啥用？\r\n\r\n还是举个栗子吧。\r\n\r\n我们以一个著名的斐波那契数列为例，它由`0`，`1`开头：\r\n\r\n```\r\n0 1 1 2 3 5 8 13 21 34 ...\r\n```\r\n\r\n要编写一个产生斐波那契数列的函数，可以这么写：\r\n\r\n```\r\nfunction fib(max) {\r\n    var\r\n        t,\r\n        a = 0,\r\n        b = 1,\r\n        arr = [0, 1];\r\n    while (arr.length < max) {\r\n        [a, b] = [b, a + b];\r\n        arr.push(b);\r\n    }\r\n    return arr;\r\n}\r\n\r\n// 测试:\r\nfib(5); // [0, 1, 1, 2, 3]\r\nfib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\r\n```\r\n\r\n函数只能返回一次，所以必须返回一个`Array`。但是，如果换成generator，就可以一次返回一个数，不断返回多次。用generator改写如下：\r\n\r\n```\r\nfunction* fib(max) {\r\n    var\r\n        t,\r\n        a = 0,\r\n        b = 1,\r\n        n = 0;\r\n    while (n < max) {\r\n        yield a;\r\n        [a, b] = [b, a + b];\r\n        n ++;\r\n    }\r\n    return;\r\n}\r\n```\r\n\r\n直接调用试试：\r\n\r\n```\r\nfib(5); // fib {[[GeneratorStatus]]: \"suspended\", [[GeneratorReceiver]]: Window}\r\n```\r\n\r\n直接调用一个generator和调用函数不一样，`fib(5)`仅仅是创建了一个generator对象，还没有去执行它。\r\n\r\n调用generator对象有两个方法，一是不断地调用generator对象的`next()`方法：\r\n\r\n```\r\nvar f = fib(5);\r\nf.next(); // {value: 0, done: false}\r\nf.next(); // {value: 1, done: false}\r\nf.next(); // {value: 1, done: false}\r\nf.next(); // {value: 2, done: false}\r\nf.next(); // {value: 3, done: false}\r\nf.next(); // {value: undefined, done: true}\r\n```\r\n\r\n`next()`方法会执行generator的代码，然后，每次遇到`yield x;`就返回一个对象`{value: x, done: true/false}`，然后“暂停”。返回的`value`就是`yield`的返回值，`done`表示这个generator是否已经执行结束了。如果`done`为`true`，则`value`就是`return`的返回值。\r\n\r\n当执行到`done`为`true`时，这个generator对象就已经全部执行完毕，不要再继续调用`next()`了。\r\n\r\n第二个方法是直接用`for ... of`循环迭代generator对象，这种方式不需要我们自己判断`done`：\r\n\r\n`\'use strict\' function* fib(max) {    var        t,        a = 0,        b = 1,        n = 0;    while (n < max) {        yield a;        [a, b] = [b, a + b];        n ++;    }    return; } ` Run\r\n\r\ngenerator和普通函数相比，有什么用？\r\n\r\n因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。例如，用一个对象来保存状态，得这么写：\r\n\r\n```\r\nvar fib = {\r\n    a: 0,\r\n    b: 1,\r\n    n: 0,\r\n    max: 5,\r\n    next: function () {\r\n        var\r\n            r = this.a,\r\n            t = this.a + this.b;\r\n        this.a = this.b;\r\n        this.b = t;\r\n        if (this.n < this.max) {\r\n            this.n ++;\r\n            return r;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n用对象的属性来保存状态，相当繁琐。\r\n\r\ngenerator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个好处要等到后面学了AJAX以后才能体会到。\r\n\r\n没有generator之前的黑暗时代，用AJAX时需要这么写代码：\r\n\r\n```\r\najax(\'http://url-1\', data1, function (err, result) {\r\n    if (err) {\r\n        return handle(err);\r\n    }\r\n    ajax(\'http://url-2\', data2, function (err, result) {\r\n        if (err) {\r\n            return handle(err);\r\n        }\r\n        ajax(\'http://url-3\', data3, function (err, result) {\r\n            if (err) {\r\n                return handle(err);\r\n            }\r\n            return success(result);\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n回调越多，代码越难看。\r\n\r\n有了generator的美好时代，用AJAX时可以这么写：\r\n\r\n```\r\ntry {\r\n    r1 = yield ajax(\'http://url-1\', data1);\r\n    r2 = yield ajax(\'http://url-2\', data2);\r\n    r3 = yield ajax(\'http://url-3\', data3);\r\n    success(r3);\r\n}\r\ncatch (err) {\r\n    handle(err);\r\n}\r\n```\r\n\r\n看上去是同步的代码，实际执行是异步的。\r\n\r\n### 练习\r\n\r\n要生成一个自增的ID，可以编写一个`next_id()`函数：\r\n\r\n```\r\nvar current_id = 0;\r\n\r\nfunction next_id() {\r\n    current_id ++;\r\n    return current_id;\r\n}\r\n```\r\n\r\n由于函数无法保存状态，故需要一个全局变量`current_id`来保存数字。\r\n\r\n不用闭包，试用generator改写：\r\n\r\n`\'use strict\'; function* next_id() { ``} // 测试: var    x,    pass = true,    g = next_id(); for (x = 1; x < 100; x ++) {    if (g.next().value !== x) {        pass = false;        console.log(\'测试失败!\');        break;    } } if (pass) {    console.log(\'测试通过!\'); } ` Run\r\n\r\n### 读后有收获可以支付宝请作者喝咖啡，读后有疑问请加微信群讨论：","timestamp":1590329650947},{"name":"68-加密和解密算法.md","path":"13-语言学习project/11-JavaScript/68-加密和解密算法.md","content":"# JS自己实现字符串加密和解密算法\r\n\r\n\r\n\r\n[C语言中文网推出辅导班啦，包括「C语言辅导班、C++辅导班、算法/数据结构辅导班」，全部都是一对一教学：一对一辅导 + 一对一答疑 + 布置作业 + 项目实践 + 永久学习。QQ在线，随时响应！](http://fudao.biancheng.net/)\r\n\r\n字符串加密和解密的关键是算法设计，字符串经过复杂的编码处理，返回一组看似杂乱无章的字符串。对于常人来说，输入的字符串是可以阅读的信息，但是被函数打乱或编码之后显示的字符串就会变成无意义的信息。想要把这些垃圾信息变成可用信息，还需要使用相反的算法把它们逆转回来。\r\n\r\n如果把字符串中的“中”字进行自定义加密。可以考虑利用 charCodeAt() 方法获取该字符的 Unicode 编码。\r\n\r\n```\r\nvar s = \"中\";var b = s.charCodeAt(0);  //返回值20013\r\n```\r\n\r\n然后以 36 为倍数不断取余数。\r\n\r\n```JavaScript\r\nb1 = b % 36;  //返回值33，求余数\r\nb = (b - b1) / 36;  //返回值555，求倍数\r\nb2 = b % 36;  //返回值15，求余数\r\nb = (b - b2) / 36;  //返回值15，求倍数\r\nb3 = b % 36;  //返回值15，求余数\r\n```\r\n\r\n那么不断求得的余数，可以通过下面公式反算出原编码值。\r\n\r\n```\r\nvar m = b3 * 36 * 36 + b2 * 36 + b1;  //返回值20013，反求字符“中”的编码值\r\n```\r\n\r\n有了这种算法，就可以实现字符与加密数值之间的相互转换。\r\n\r\n定义一串密钥：\r\n\r\n```\r\nvar key = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n```\r\n\r\n把余数定位到与密钥中某个下标值相等的字符上，这样就实现了加密效果。反过来，如果知道某个字符在密钥中的下标值，然后反算出被加密字符的 Unicode 编码值，最后就可以逆推出被加密字符的原信息。\r\n\r\n本例设定密钥是以 36 个不同的数值和字母组成的字符串。不同的密钥，加密解密的结果是不同的，加密结果以密钥中的字符作为基本元素。\r\n\r\n加密字符串：\r\n\r\n```JavaScript\r\nvar toCode = function (str) {  //加密字符串\r\n    //定义密钥，36个字母和数字\r\n    var key = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    var 1 = key.length;  //获取密钥的长度\r\n    var a = key.split(\"\");  //把密钥字符串转换为字符数组\r\n    var s = \"\",b, b1, b2, b3;  //定义临时变量\r\n    for (var i = 0; i <str.length; i ++) {  //遍历字符串\r\n        b = str.charCodeAt(i);  //逐个提取每个字符，并获取Unicode编码值\r\n        b1 = b % 1;  //求Unicode编码值得余数\r\n        b = (b - b1) / 1;  //求最大倍数\r\n        b2 = b % 1;  //求最大倍数的于是\r\n        b = (b - b2) / 1;  //求最大倍数\r\n        b3 = b % 1;  //求最大倍数的余数\r\n        s += a[b3] + a[b2] + a[b1];  //根据余数值映射到密钥中对应下标位置的字符\r\n    }\r\n    return s;  //返回这些映射的字符\r\n} \r\n```\r\n\r\n解密字符串：\r\n\r\n```JavaScript\r\nvar fromCode = function (str) {\r\n    //定义密钥，36个字母和数字\r\n    var key = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    var 1 = key.length;  //获取密钥的长度\r\n    var b, b1, b2, b3, d = 0, s;  //定义临时变量\r\n    s = new Array(Math.floor(str.length / 3));  //计算加密字符串包含的字符数，并定义数组\r\n    b = s.length;  //获取数组的长度\r\n    for (var i = 0; i < b; i ++) {  //以数组的长度循环次数，遍历加密字符串\r\n        b1 = key.indexOf(str.charAt(d));  //截取周期内第一个字符串，计算在密钥中的下标值\r\n        d ++;\r\n        b2 = key.indexOf(str.charAt(d));  //截取周期内第二个字符串，计算在密钥中的下标值\r\n        d ++;\r\n        b3 = key.indexOf(str.charAt(d));  //截取周期内第三个字符串，计算在密钥中的下标值\r\n        d ++;\r\n        s[i] = b1 * 1 * 1 + b2 * 1 + b3  //利用下标值，反推被加密字符的Unicode编码值\r\n    }\r\n    b = eval(\"String.fromCharCode(\" + s.join(\',\') + \")\");用fromCharCode()算出字符串\r\n    return b ;  //返回被解密的字符串\r\n}\r\n```\r\n\r\n#### 应用代码\r\n\r\n```JavaScript\r\nvar s = \"JavaScript 中国\";  //字符串直接量\r\ns = toCode(s);  //加密字符串\r\nconsole.log(s);\r\n//返回“02Y02P03A02 P03702R03602X034038FFXH6L”\r\ns = fromCode(s);  //解密被加密的字符串\r\nconsole.log(s);  //返回字符串“JavaScript 中国”\r\n```","timestamp":1590329650947},{"name":"69-标准对象.md","path":"13-语言学习project/11-JavaScript/69-标准对象.md","content":"#### 标准对象\r\n\r\n------\r\n\r\n在JavaScript的世界里，一切都是对象。\r\n\r\n但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用`typeof`操作符获取对象的类型，它总是返回一个字符串：\r\n\r\n```\r\ntypeof 123; // \'number\'\r\ntypeof NaN; // \'number\'\r\ntypeof \'str\'; // \'string\'\r\ntypeof true; // \'boolean\'\r\ntypeof undefined; // \'undefined\'\r\ntypeof Math.abs; // \'function\'\r\ntypeof null; // \'object\'\r\ntypeof []; // \'object\'\r\ntypeof {}; // \'object\'\r\n```\r\n\r\n可见，`number`、`string`、`boolean`、`function`和`undefined`有别于其他类型。特别注意`null`的类型是`object`，`Array`的类型也是`object`，如果我们用`typeof`将无法区分出`null`、`Array`和通常意义上的object——`{}`。\r\n\r\n### 包装对象\r\n\r\n除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚`int`和`Integer`这种暧昧关系。\r\n\r\n`number`、`boolean`和`string`都有包装对象。没错，在JavaScript中，字符串也区分`string`类型和它的包装类型。包装对象用`new`创建：\r\n\r\n```\r\nvar n = new Number(123); // 123,生成了新的包装类型\r\nvar b = new Boolean(true); // true,生成了新的包装类型\r\nvar s = new String(\'str\'); // \'str\',生成了新的包装类型\r\n```\r\n\r\n虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为`object`了！所以，包装对象和原始值用`===`比较会返回`false`：\r\n\r\n```\r\ntypeof new Number(123); // \'object\'\r\nnew Number(123) === 123; // false\r\n\r\ntypeof new Boolean(true); // \'object\'\r\nnew Boolean(true) === true; // false\r\n\r\ntypeof new String(\'str\'); // \'object\'\r\nnew String(\'str\') === \'str\'; // false\r\n```\r\n\r\n所以*闲的蛋疼也不要使用包装对象*！尤其是针对`string`类型！！！\r\n\r\n如果我们在使用`Number`、`Boolean`和`String`时，没有写`new`会发生什么情况？\r\n\r\n此时，`Number()`、`Boolean`和`String()`被当做普通函数，把任何类型的数据转换为`number`、`boolean`和`string`类型（注意不是其包装类型）：\r\n\r\n```\r\nvar n = Number(\'123\'); // 123，相当于parseInt()或parseFloat()\r\ntypeof n; // \'number\'\r\n\r\nvar b = Boolean(\'true\'); // true\r\ntypeof b; // \'boolean\'\r\n\r\nvar b2 = Boolean(\'false\'); // true! \'false\'字符串转换结果为true！因为它是非空字符串！\r\nvar b3 = Boolean(\'\'); // false\r\n\r\nvar s = String(123.45); // \'123.45\'\r\ntypeof s; // \'string\'\r\n```\r\n\r\n是不是感觉头大了？这就是JavaScript特有的催眠魅力！\r\n\r\n总结一下，有这么几条规则需要遵守：\r\n\r\n- 不要使用`new Number()`、`new Boolean()`、`new String()`创建包装对象；\r\n- 用`parseInt()`或`parseFloat()`来转换任意类型到`number`；\r\n- 用`String()`来转换任意类型到`string`，或者直接调用某个对象的`toString()`方法；\r\n- 通常不必把任意类型转换为`boolean`再判断，因为可以直接写`if (myVar) {...}`；\r\n- `typeof`操作符可以判断出`number`、`boolean`、`string`、`function`和`undefined`；\r\n- 判断`Array`要使用`Array.isArray(arr)`；\r\n- 判断`null`请使用`myVar === null`；\r\n- 判断某个全局变量是否存在用`typeof window.myVar === \'undefined\'`；\r\n- 函数内部判断某个变量是否存在用`typeof myVar === \'undefined\'`。\r\n\r\n最后有细心的同学指出，任何对象都有`toString()`方法吗？`null`和`undefined`就没有！确实如此，这两个特殊值要除外，虽然`null`还伪装成了`object`类型。\r\n\r\n更细心的同学指出，`number`对象调用`toString()`报SyntaxError：\r\n\r\n```\r\n123.toString(); // SyntaxError\r\n```\r\n\r\n==遇到这种情况，要特殊处理一下：==\r\n\r\n```\r\n123..toString(); // \'123\', 注意是两个点！\r\n(123).toString(); // \'123\'\r\n```\r\n\r\n不要问为什么，这就是JavaScript代码的乐趣！\r\n\r\n#### Date\r\n\r\n阅读: 2016314\r\n\r\n------\r\n\r\n在JavaScript中，`Date`对象用来表示日期和时间。\r\n\r\n要获取系统当前时间，用：\r\n\r\n```\r\nvar now = new Date();\r\nnow; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\r\nnow.getFullYear(); // 2015, 年份\r\nnow.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月\r\nnow.getDate(); // 24, 表示24号\r\nnow.getDay(); // 3, 表示星期三\r\nnow.getHours(); // 19, 24小时制\r\nnow.getMinutes(); // 49, 分钟\r\nnow.getSeconds(); // 22, 秒\r\nnow.getMilliseconds(); // 875, 毫秒数\r\nnow.getTime(); // 1435146562875, 以number形式表示的时间戳\r\n```\r\n\r\n注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。\r\n\r\n如果要创建一个指定日期和时间的`Date`对象，可以用：\r\n\r\n```\r\nvar d = new Date(2015, 5, 19, 20, 15, 30, 123);\r\nd; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)\r\n```\r\n\r\n你可能观察到了一个*非常非常坑爹*的地方，就是JavaScript的月份范围用整数表示是0~11，`0`表示一月，`1`表示二月……，==所以要表示6月，我们传入的是`5`！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。==\r\n\r\n ==JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月==。\r\n\r\n第二种创建一个指定日期和时间的方法是解析一个符合[ISO 8601](http://www.w3.org/TR/NOTE-datetime)格式的字符串：\r\n\r\n```\r\nvar d = Date.parse(\'2015-06-24T19:49:22.875+08:00\');\r\nd; // 1435146562875\r\n```\r\n\r\n但它返回的不是`Date`对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个`Date`：\r\n\r\n```\r\nvar d = new Date(1435146562875);\r\nd; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)\r\nd.getMonth(); // 5\r\n```\r\n\r\n 使用Date.parse()时传入的字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0~11。\r\n\r\n### 时区\r\n\r\n`Date`对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间：\r\n\r\n```\r\nvar d = new Date(1435146562875);\r\nd.toLocaleString(); // \'2015/6/24 下午7:49:22\'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关\r\nd.toUTCString(); // \'Wed, 24 Jun 2015 11:49:22 GMT\'，UTC时间，与本地时间相差8小时\r\n```\r\n\r\n那么在JavaScript中如何进行时区转换呢？实际上，只要我们传递的是一个`number`类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。\r\n\r\n时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。\r\n\r\n所以，==我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。==\r\n\r\n要获取当前时间戳，可以用：\r\n\r\n```\r\nif (Date.now) {\r\n    console.log(Date.now()); // 老版本IE没有now()方法\r\n} else {\r\n    console.log(new Date().getTime());\r\n}\r\n//1585983695468\r\n```\r\n\r\n#### RegExp\r\n\r\n------\r\n\r\n字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取`@`前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。\r\n\r\n正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。\r\n\r\n所以我们判断一个字符串是否是合法的Email的方法是：\r\n\r\n1. 创建一个匹配Email的正则表达式；\r\n2. 用该正则表达式去匹配用户的输入来判断是否合法。\r\n\r\n因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。\r\n\r\n在正则表达式中，如果直接给出字符，就是精确匹配。用`\\d`可以匹配一个数字，`\\w`可以匹配一个字母或数字，所以：\r\n\r\n- `\'00\\d\'`可以匹配`\'007\'`，但无法匹配`\'00A\'`；\r\n- `\'\\d\\d\\d\'`可以匹配`\'010\'`；\r\n- `\'\\w\\w\'`可以匹配`\'js\'`；\r\n\r\n`.`可以匹配任意字符，所以：\r\n\r\n- `\'js.\'`可以匹配`\'jsp\'`、`\'jss\'`、`\'js!\'`等等。\r\n\r\n要匹配变长的字符，在正则表达式中，用`*`表示任意个字符（包括0个），用`+`表示至少一个字符，用`?`表示0个或1个字符，用`{n}`表示n个字符，用`{n,m}`表示n-m个字符：\r\n\r\n来看一个复杂的例子：`\\d{3}\\s+\\d{3,8}`。\r\n\r\n我们来从左到右解读一下：\r\n\r\n1. `\\d{3}`表示匹配3个数字，例如`\'010\'`；\r\n2. `\\s`可以匹配一个空格（也包括Tab等空白符），所以`\\s+`表示至少有一个空格，例如匹配`\' \'`，`\'\\t\\t\'`等；\r\n3. `\\d{3,8}`表示3-8个数字，例如`\'1234567\'`。\r\n\r\n综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。\r\n\r\n如果要匹配`\'010-12345\'`这样的号码呢？由于`\'-\'`是特殊字符，在正则表达式中，要用`\'\\\'`转义，所以，上面的正则是`\\d{3}\\-\\d{3,8}`。\r\n\r\n但是，仍然无法匹配`\'010 - 12345\'`，因为带有空格。所以我们需要更复杂的匹配方式。\r\n\r\n### 进阶\r\n\r\n要做更精确地匹配，可以用`[]`表示范围，比如：\r\n\r\n- `[0-9a-zA-Z\\_]`可以匹配一个数字、字母或者下划线；\r\n- `[0-9a-zA-Z\\_]+`可以匹配至少由一个数字、字母或者下划线组成的字符串，比如`\'a100\'`，`\'0_Z\'`，`\'js2015\'`等等；\r\n- `[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*`可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；\r\n- `[a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}`更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。\r\n\r\n`A|B`可以匹配A或B，所以`(J|j)ava(S|s)cript`可以匹配`\'JavaScript\'`、`\'Javascript\'`、`\'javaScript\'`或者`\'javascript\'`。\r\n\r\n`^`表示行的开头，`^\\d`表示必须以数字开头。\r\n\r\n`if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=表示行的结束，`\\dif(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=表示必须以数字结束。\r\n\r\n你可能注意到了，`js`也可以匹配`\'jsp\'`，但是加上`^jsif(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=就变成了整行匹配，就只能匹配`\'js\'`了。\r\n\r\n### RegExp\r\n\r\n有了准备知识，我们就可以在JavaScript中使用正则表达式了。\r\n\r\nJavaScript有两种方式创建一个正则表达式：\r\n\r\n第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp(\'正则表达式\')`创建一个RegExp对象。\r\n\r\n两种写法是一样的：\r\n\r\n```\r\nvar re1 = /ABC\\-001/;\r\nvar re2 = new RegExp(\'ABC\\\\-001\');\r\n\r\nre1; // /ABC\\-001/\r\nre2; // /ABC\\-001/\r\n```\r\n\r\n注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个`\\\\`实际上是一个`\\`。\r\n\r\n先看看如何判断正则表达式是否匹配：\r\n\r\n```\r\nvar re = /^\\d{3}\\-\\d{3,8}$/;\r\nre.test(\'010-12345\'); // true\r\nre.test(\'010-1234x\'); // false\r\nre.test(\'010 12345\'); // false\r\n```\r\n\r\nRegExp对象的`test()`方法用于测试给定的字符串是否符合条件。\r\n\r\n### 切分字符串\r\n\r\n用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：\r\n\r\n```\r\n\'a b   c\'.split(\' \'); // [\'a\', \'b\', \'\', \'\', \'c\']\r\n```\r\n\r\n嗯，无法识别连续的空格，用正则表达式试试：\r\n\r\n```\r\n\'a b   c\'.split(/\\s+/); // [\'a\', \'b\', \'c\']\r\n```\r\n\r\n无论多少个空格都可以正常分割。加入`,`试试：\r\n\r\n```\r\n\'a,b, c  d\'.split(/[\\s\\,]+/); // [\'a\', \'b\', \'c\', \'d\']\r\n```\r\n\r\n再加入`;`试试：\r\n\r\n```\r\n\'a,b;; c  d\'.split(/[\\s\\,\\;]+/); // [\'a\', \'b\', \'c\', \'d\']\r\n```\r\n\r\n如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。\r\n\r\n### 分组\r\n\r\n除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。比如：\r\n\r\n`^(\\d{3})-(\\d{3,8})if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m13']=分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：\r\n\r\n```\r\nvar re = /^(\\d{3})-(\\d{3,8})$/;\r\nre.exec(\'010-12345\'); // [\'010-12345\', \'010\', \'12345\']\r\nre.exec(\'010 12345\'); // null\r\n```\r\n\r\n如果正则表达式中定义了组，就可以在`RegExp`对象上用`exec()`方法提取出子串来。\r\n\r\n`exec()`方法在匹配成功后，会返回一个`Array`，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。\r\n\r\n`exec()`方法在匹配失败时返回`null`。\r\n\r\n提取子串非常有用。来看一个更凶残的例子：\r\n\r\n```\r\nvar re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;\r\nre.exec(\'19:05:30\'); // [\'19:05:30\', \'19\', \'05\', \'30\']\r\n```\r\n\r\n这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：\r\n\r\n```\r\nvar re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;\r\n```\r\n\r\n对于`\'2-30\'`，`\'4-31\'`这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。\r\n\r\n### 贪婪匹配\r\n\r\n需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的`0`：\r\n\r\n```\r\nvar re = /^(\\d+)(0*)$/;\r\nre.exec(\'102300\'); // [\'102300\', \'102300\', \'\']\r\n```\r\n\r\n由于`\\d+`采用贪婪匹配，直接把后面的`0`全部匹配了，结果`0*`只能匹配空字符串了。\r\n\r\n必须让`\\d+`采用非贪婪匹配（也就是尽可能少匹配），才能把后面的`0`匹配出来，加个`?`就可以让`\\d+`采用非贪婪匹配：\r\n\r\n```\r\nvar re = /^(\\d+?)(0*)$/;\r\nre.exec(\'102300\'); // [\'102300\', \'1023\', \'00\']\r\n```\r\n\r\n### 全局搜索\r\n\r\nJavaScript的正则表达式还有几个特殊的标志，最常用的是`g`，表示全局匹配：\r\n\r\n```\r\nvar r1 = /test/g;\r\n// 等价于:\r\nvar r2 = new RegExp(\'test\', \'g\');\r\n```\r\n\r\n全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：\r\n\r\n```\r\nvar s = \'JavaScript, VBScript, JScript and ECMAScript\';\r\nvar re=/[a-zA-Z]+Script/g;\r\n\r\n// 使用全局匹配:\r\nre.exec(s); // [\'JavaScript\']\r\nre.lastIndex; // 10\r\n\r\nre.exec(s); // [\'VBScript\']\r\nre.lastIndex; // 20\r\n\r\nre.exec(s); // [\'JScript\']\r\nre.lastIndex; // 29\r\n\r\nre.exec(s); // [\'ECMAScript\']\r\nre.lastIndex; // 44\r\n\r\nre.exec(s); // null，直到结束仍没有匹配到\r\n```\r\n\r\n全局匹配类似搜索，因此不能使用`/^...$/`，那样只会最多匹配一次。\r\n\r\n正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。\r\n\r\n### 小结\r\n\r\n正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。\r\n\r\n### 练习\r\n\r\n请尝试写一个验证Email地址的正则表达式。版本一应该可以验证出类似的Email：\r\n\r\n`\'use strict\'; ``// 测试: var    i,    success = true,    should_pass = [\'someone@gmail.com\', \'bill.gates@microsoft.com\', \'tom@voyager.org\', \'bob2015@163.com\'],    should_fail = [\'test#gmail.com\', \'bill@microsoft\', \'bill%gates@ms.com\', \'@voyager.org\']; for (i = 0; i < should_pass.length; i++) {    if (!re.test(should_pass[i])) {        console.log(\'测试失败: \' + should_pass[i]);        success = false;        break;    } } for (i = 0; i < should_fail.length; i++) {    if (re.test(should_fail[i])) {        console.log(\'测试失败: \' + should_fail[i]);        success = false;        break;    } } if (success) {    console.log(\'测试通过!\'); } ` Run\r\n\r\n版本二可以验证并提取出带名字的Email地址：\r\n\r\n`\'use strict\'; ``// 测试: var r = re.exec(\' tom@voyager.org\'); if (r === null || r.toString() !== [\' tom@voyager.org\', \'Tom Paris\', \'tom@voyager.org\'].toString()) {    console.log(\'测试失败!\'); } else {    console.log(\'测试成功!\'); } ` Run\r\n\r\n#### JSON\r\n\r\n阅读: 4106942\r\n\r\n------\r\n\r\nJSON是JavaScript Object Notation的缩写，它是一种数据交换格式。\r\n\r\n在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。\r\n\r\n终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。\r\n\r\n道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：\r\n\r\n- number：和JavaScript的`number`完全一致；\r\n- boolean：就是JavaScript的`true`或`false`；\r\n- string：就是JavaScript的`string`；\r\n- null：就是JavaScript的`null`；\r\n- array：就是JavaScript的`Array`表示方式——`[]`；\r\n- object：就是JavaScript的`{ ... }`表示方式。\r\n\r\n以及上面的任意组合。\r\n\r\n并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号`\"\"`，Object的键也必须用双引号`\"\"`。\r\n\r\n由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。\r\n\r\n把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。\r\n\r\n如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。\r\n\r\n### 序列化\r\n\r\n让我们先把小明这个对象序列化成JSON格式的字符串：\r\n\r\n`\'use strict\'; var xiaoming = {    name: \'小明\',    age: 14,    gender: true,    height: 1.65,    grade: null,    \'middle-school\': \'\\\"W3C\\\" Middle School\',    skills: [\'JavaScript\', \'Java\', \'Python\', \'Lisp\'] }; ` Run\r\n\r\n要输出得好看一些，可以加上参数，按缩进输出：\r\n\r\n```\r\nJSON.stringify(xiaoming, null, \'  \');\r\n```\r\n\r\n结果：\r\n\r\n```\r\n{\r\n  \"name\": \"小明\",\r\n  \"age\": 14,\r\n  \"gender\": true,\r\n  \"height\": 1.65,\r\n  \"grade\": null,\r\n  \"middle-school\": \"\\\"W3C\\\" Middle School\",\r\n  \"skills\": [\r\n    \"JavaScript\",\r\n    \"Java\",\r\n    \"Python\",\r\n    \"Lisp\"\r\n  ]\r\n}\r\n```\r\n\r\n第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`：\r\n\r\n```\r\nJSON.stringify(xiaoming, [\'name\', \'skills\'], \'  \');\r\n```\r\n\r\n结果：\r\n\r\n```\r\n{\r\n  \"name\": \"小明\",\r\n  \"skills\": [\r\n    \"JavaScript\",\r\n    \"Java\",\r\n    \"Python\",\r\n    \"Lisp\"\r\n  ]\r\n}\r\n```\r\n\r\n还可以传入一个函数，这样对象的每个键值对都会被函数先处理：\r\n\r\n```\r\nfunction convert(key, value) {\r\n    if (typeof value === \'string\') {\r\n        return value.toUpperCase();\r\n    }\r\n    return value;\r\n}\r\n\r\nJSON.stringify(xiaoming, convert, \'  \');\r\n```\r\n\r\n上面的代码把所有属性值都变成大写：\r\n\r\n```\r\n{\r\n  \"name\": \"小明\",\r\n  \"age\": 14,\r\n  \"gender\": true,\r\n  \"height\": 1.65,\r\n  \"grade\": null,\r\n  \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\",\r\n  \"skills\": [\r\n    \"JAVASCRIPT\",\r\n    \"JAVA\",\r\n    \"PYTHON\",\r\n    \"LISP\"\r\n  ]\r\n}\r\n```\r\n\r\n如果我们还想要精确控制如何序列化小明，可以给`xiaoming`定义一个`toJSON()`的方法，直接返回JSON应该序列化的数据：\r\n\r\n```\r\nvar xiaoming = {\r\n    name: \'小明\',\r\n    age: 14,\r\n    gender: true,\r\n    height: 1.65,\r\n    grade: null,\r\n    \'middle-school\': \'\\\"W3C\\\" Middle School\',\r\n    skills: [\'JavaScript\', \'Java\', \'Python\', \'Lisp\'],\r\n    toJSON: function () {\r\n        return { // 只输出name和age，并且改变了key：\r\n            \'Name\': this.name,\r\n            \'Age\': this.age\r\n        };\r\n    }\r\n};\r\n\r\nJSON.stringify(xiaoming); // \'{\"Name\":\"小明\",\"Age\":14}\'\r\n```\r\n\r\n### 反序列化\r\n\r\n拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象：\r\n\r\n```\r\nJSON.parse(\'[1,2,3,true]\'); // [1, 2, 3, true]\r\nJSON.parse(\'{\"name\":\"小明\",\"age\":14}\'); // Object {name: \'小明\', age: 14}\r\nJSON.parse(\'true\'); // true\r\nJSON.parse(\'123.45\'); // 123.45\r\n```\r\n\r\n`JSON.parse()`还可以接收一个函数，用来转换解析出的属性：\r\n\r\n`\'use strict\'; ` Run\r\n\r\n在JavaScript中使用JSON，就是这么简单！\r\n\r\n### 练习\r\n\r\n用浏览器访问OpenWeatherMap的[天气API](https://api.openweathermap.org/data/2.5/forecast?q=Beijing,cn&appid=800f49846586c3ba6e7052cfc89af16c)，查看返回的JSON数据，然后返回城市、天气预报等信息：\r\n\r\n`\'use strict\' var url = \'https://api.openweathermap.org/data/2.5/forecast?q=Beijing,cn&appid=800f49846586c3ba6e7052cfc89af16c\'; $.getJSON(url, function (data) { ``}); ` Run\r\n\r\n```JavaScript\r\nvar info = {\r\n    city: data.city.name,\r\n    weather: data.list[0].weather[0].main,\r\n    time: data.list[0].dt_txt\r\n};\r\nalert(JSON.stringify(info, null, \'  \'));\r\n\r\n```","timestamp":1590329650947},{"name":"70-箭头函数.md","path":"13-语言学习project/11-JavaScript/70-箭头函数.md","content":"#### 箭头函数\r\n\r\n阅读: 10142079\r\n\r\n------\r\n\r\nES6标准新增了一种新的函数：Arrow Function（箭头函数）。\r\n\r\n为什么叫Arrow Function？因为它的定义用的就是一个箭头：\r\n\r\n```\r\nx => x * x\r\n```\r\n\r\n上面的箭头函数相当于：\r\n\r\n```\r\nfunction (x) {\r\n    return x * x;\r\n}\r\n```\r\n\r\n在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function：\r\n\r\n```\r\n\'use strict\';\r\nconsole.log(\'你的浏览器支持ES6的Arrow Function!\');\r\n```\r\n\r\n Run\r\n\r\n你的浏览器支持ES6的Arrow Function!\r\n\r\n箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连`{ ... }`和`return`都省略掉了。还有一种可以包含多条语句，这时候就不能省略`{ ... }`和`return`：\r\n\r\n```\r\nx => {\r\n    if (x > 0) {\r\n        return x * x;\r\n    }\r\n    else {\r\n        return - x * x;\r\n    }\r\n}\r\n```\r\n\r\n如果参数不是一个，就需要用括号`()`括起来：\r\n\r\n```\r\n// 两个参数:\r\n(x, y) => x * x + y * y\r\n\r\n// 无参数:\r\n() => 3.14\r\n\r\n// 可变参数:\r\n(x, y, ...rest) => {\r\n    var i, sum = x + y;\r\n    for (i=0; i<rest.length; i++) {\r\n        sum += rest[i];\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\r\n如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：\r\n\r\n```\r\n// SyntaxError:\r\nx => { foo: x }\r\n```\r\n\r\n因为和函数体的`{ ... }`有语法冲突，所以要改为：\r\n\r\n```\r\n// ok:\r\nx => ({ foo: x })\r\n```\r\n\r\n### this\r\n\r\n箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的`this`是词法作用域，由上下文确定。\r\n\r\n回顾前面的例子，由于JavaScript函数对`this`绑定的错误处理，下面的例子无法得到预期结果：\r\n\r\n```\r\nvar obj = {\r\n    birth: 1990,\r\n    getAge: function () {\r\n        var b = this.birth; // 1990\r\n        var fn = function () {\r\n            return new Date().getFullYear() - this.birth; // this指向window或undefined\r\n        };\r\n        return fn();\r\n    }\r\n};\r\n```\r\n\r\n现在，箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`：\r\n\r\n```\r\nvar obj = {\r\n    birth: 1990,\r\n    getAge: function () {\r\n        var b = this.birth; // 1990\r\n        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象\r\n        return fn();\r\n    }\r\n};\r\nobj.getAge(); // 25\r\n```\r\n\r\n如果使用箭头函数，以前的那种hack写法：\r\n\r\n```\r\nvar that = this;\r\n```\r\n\r\n就不再需要了。\r\n\r\n由于`this`在箭头函数中已经按照词法作用域绑定了，所以，用`call()`或者`apply()`调用箭头函数时，无法对`this`进行绑定，即传入的第一个参数被忽略：\r\n\r\n```\r\nvar obj = {\r\n    birth: 1990,\r\n    getAge: function (year) {\r\n        var b = this.birth; // 1990\r\n        var fn = (y) => y - this.birth; // this.birth仍是1990\r\n        return fn.call({birth:2000}, year);\r\n    }\r\n};\r\nobj.getAge(2015); // 25\r\n```\r\n\r\n### 练习\r\n\r\n请使用箭头函数简化排序时传入的函数：\r\n\r\n```\r\n\'use strict\' var arr = [10, 20, 1, 2];\r\n```","timestamp":1590329650947},{"name":"71-闭包.md","path":"13-语言学习project/11-JavaScript/71-闭包.md","content":"#### 闭包\r\n\r\n------\r\n\r\n### 函数作为返回值\r\n\r\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\r\n\r\n我们来实现一个对`Array`的求和。通常情况下，求和的函数是这样定义的：\r\n\r\n```\r\nfunction sum(arr) {\r\n    return arr.reduce(function (x, y) {\r\n        return x + y;\r\n    });\r\n}\r\n\r\nsum([1, 2, 3, 4, 5]); // 15\r\n```\r\n\r\n但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！\r\n\r\n```\r\nfunction lazy_sum(arr) {\r\n    var sum = function () {\r\n        return arr.reduce(function (x, y) {\r\n            return x + y;\r\n        });\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\r\n当我们调用`lazy_sum()`时，返回的并不是求和结果，而是求和函数：\r\n\r\n```\r\nvar f = lazy_sum([1, 2, 3, 4, 5]); // function sum()\r\n```\r\n\r\n调用函数`f`时，才真正计算求和的结果：\r\n\r\n```\r\nf(); // 15\r\n```\r\n\r\n在这个例子中，我们在函数`lazy_sum`中又定义了函数`sum`，并且，内部函数`sum`可以引用外部函数`lazy_sum`的参数和局部变量，当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\r\n\r\n请再注意一点，当我们调用`lazy_sum()`时，每次调用都会返回一个新的函数，即使传入相同的参数：\r\n\r\n```\r\nvar f1 = lazy_sum([1, 2, 3, 4, 5]);\r\nvar f2 = lazy_sum([1, 2, 3, 4, 5]);\r\nf1 === f2; // false\r\n```\r\n\r\n`f1()`和`f2()`的调用结果互不影响。\r\n\r\n### 闭包\r\n\r\n注意到返回的函数在其定义内部引用了局部变量`arr`，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。\r\n\r\n另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了`f()`才执行。我们来看一个例子：\r\n\r\n```\r\nfunction count() {\r\n    var arr = [];\r\n    for (var i=1; i<=3; i++) {\r\n        arr.push(function () {\r\n            return i * i;\r\n        });\r\n    }\r\n    return arr;\r\n}\r\n\r\nvar results = count();\r\nvar f1 = results[0];\r\nvar f2 = results[1];\r\nvar f3 = results[2];\r\n```\r\n\r\n在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个`Array`中返回了。\r\n\r\n你可能认为调用`f1()`，`f2()`和`f3()`结果应该是`1`，`4`，`9`，但实际结果是：\r\n\r\n```\r\nf1(); // 16\r\nf2(); // 16\r\nf3(); // 16\r\n```\r\n\r\n全部都是`16`！原因就在于返回的函数引用了变量`i`，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量`i`已经变成了`4`，因此最终结果为`16`。\r\n\r\n返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\r\n\r\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\r\n\r\n```\r\nfunction count() {\r\n    var arr = [];\r\n    for (var i=1; i<=3; i++) {\r\n        arr.push((function (n) {\r\n            return function () {\r\n                return n * n;\r\n            }\r\n        })(i));\r\n    }\r\n    return arr;\r\n}\r\n\r\nvar results = count();\r\nvar f1 = results[0];\r\nvar f2 = results[1];\r\nvar f3 = results[2];\r\n\r\nf1(); // 1\r\nf2(); // 4\r\nf3(); // 9\r\n```\r\n\r\n注意这里用了一个“创建一个匿名函数并立刻执行”的语法：\r\n\r\n```\r\n(function (x) {\r\n    return x * x;\r\n})(3); // 9\r\n```\r\n\r\n理论上讲，创建一个匿名函数并立刻执行可以这么写：\r\n\r\n```\r\nfunction (x) { return x * x } (3);\r\n```\r\n\r\n但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：\r\n\r\n```\r\n(function (x) { return x * x }) (3);\r\n```\r\n\r\n通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：\r\n\r\n```\r\n(function (x) {\r\n    return x * x;\r\n})(3);\r\n```\r\n\r\n说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？\r\n\r\n当然不是！闭包有非常强大的功能。举个栗子：\r\n\r\n在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用`private`修饰一个成员变量。\r\n\r\n在没有`class`机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：\r\n\r\n```\r\n\'use strict\';\r\n\r\nfunction create_counter(initial) {\r\n    var x = initial || 0;\r\n    return {\r\n        inc: function () {\r\n            x += 1;\r\n            return x;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n它用起来像这样：\r\n\r\n```\r\nvar c1 = create_counter();\r\nc1.inc(); // 1\r\nc1.inc(); // 2\r\nc1.inc(); // 3\r\n\r\nvar c2 = create_counter(10);\r\nc2.inc(); // 11\r\nc2.inc(); // 12\r\nc2.inc(); // 13\r\n```\r\n\r\n在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x`，并且，从外部代码根本无法访问到变量`x`。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。\r\n\r\n闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用`Math.pow(x, y)`函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数`pow2`和`pow3`：\r\n\r\n`\'use strict\'; function make_pow(n) {    return function (x) {        return Math.pow(x, n);    } } ` Run\r\n\r\n### 脑洞大开\r\n\r\n很久很久以前，有个叫阿隆佐·邱奇的帅哥，发现只需要用函数，就可以用计算机实现运算，而不需要`0`、`1`、`2`、`3`这些数字和`+`、`-`、`*`、`/`这些符号。\r\n\r\nJavaScript支持函数，所以可以用JavaScript用函数来写这些计算。来试试：\r\n\r\n`\'use strict\'; // 定义数字0: var zero = function (f) {    return function (x) {        return x;    } }; // 定义数字1: var one = function (f) {    return function (x) {        return f(x);    } }; // 定义加法: function add(n, m) {    return function (f) {        return function (x) {            return m(f)(n(f)(x));        }    } } ` Run","timestamp":1590329650947},{"name":"72-面向对象变成.md","path":"13-语言学习project/11-JavaScript/72-面向对象变成.md","content":"#### 面向对象编程\r\n\r\n阅读: 6659253\r\n\r\n------\r\n\r\nJavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？\r\n\r\n当然不是。如果我们只使用`Number`、`Array`、`string`以及基本的`{...}`定义的对象，还无法发挥出面向对象编程的威力。\r\n\r\nJavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。如果你熟悉Java或C#，很好，你一定明白面向对象的两个基本概念：\r\n\r\n1. 类：类是对象的类型模板，例如，定义`Student`类来表示学生，类本身是一种类型，`Student`表示学生类型，但不表示任何具体的某个学生；\r\n2. 实例：实例是根据类创建的对象，例如，根据`Student`类可以创建出`xiaoming`、`xiaohong`、`xiaojun`等多个实例，每个实例表示一个具体的学生，他们全都属于`Student`类型。\r\n\r\n所以，类和实例是大多数面向对象编程语言的基本概念。\r\n\r\n不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。\r\n\r\n原型是指当我们想要创建`xiaoming`这个具体的学生时，我们并没有一个`Student`类型可用。那怎么办？恰好有这么一个现成的对象：\r\n\r\n```\r\nvar robot = {\r\n    name: \'Robot\',\r\n    height: 1.6,\r\n    run: function () {\r\n        console.log(this.name + \' is running...\');\r\n    }\r\n};\r\n```\r\n\r\n我们看这个`robot`对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！\r\n\r\n于是我们把它改名为`Student`，然后创建出`xiaoming`：\r\n\r\n```\r\nvar Student = {\r\n    name: \'Robot\',\r\n    height: 1.2,\r\n    run: function () {\r\n        console.log(this.name + \' is running...\');\r\n    }\r\n};\r\n\r\nvar xiaoming = {\r\n    name: \'小明\'\r\n};\r\n\r\nxiaoming.__proto__ = Student;\r\n```\r\n\r\n注意最后一行代码把`xiaoming`的原型指向了对象`Student`，看上去`xiaoming`仿佛是从`Student`继承下来的：\r\n\r\n```\r\nxiaoming.name; // \'小明\'\r\nxiaoming.run(); // 小明 is running...\r\n```\r\n\r\n`xiaoming`有自己的`name`属性，但并没有定义`run()`方法。不过，由于小明是从`Student`继承而来，只要`Student`有`run()`方法，`xiaoming`也可以调用：\r\n\r\n![xiaoming-prototype](D:\\Typora_pic\\l-1585985361069.png)\r\n\r\nJavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。\r\n\r\n如果你把`xiaoming`的原型指向其他对象：\r\n\r\n```\r\nvar Bird = {\r\n    fly: function () {\r\n        console.log(this.name + \' is flying...\');\r\n    }\r\n};\r\n\r\nxiaoming.__proto__ = Bird;\r\n```\r\n\r\n现在`xiaoming`已经无法`run()`了，他已经变成了一只鸟：\r\n\r\n```\r\nxiaoming.fly(); // 小明 is flying...\r\n```\r\n\r\n在JavaScrip代码运行时期，你可以把`xiaoming`从`Student`变成`Bird`，或者变成任何对象。\r\n\r\n*请注意*，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用`obj.__proto__`去改变一个对象的原型，并且，低版本的IE也无法使用`__proto__`。`Object.create()`方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建`xiaoming`：\r\n\r\n```\r\n// 原型对象:\r\nvar Student = {\r\n    name: \'Robot\',\r\n    height: 1.2,\r\n    run: function () {\r\n        console.log(this.name + \' is running...\');\r\n    }\r\n};\r\n\r\nfunction createStudent(name) {\r\n    // 基于Student原型创建一个新对象:\r\n    var s = Object.create(Student);\r\n    // 初始化新对象:\r\n    s.name = name;\r\n    return s;\r\n}\r\n\r\nvar xiaoming = createStudent(\'小明\');\r\nxiaoming.run(); // 小明 is running...\r\nxiaoming.__proto__ === Student; // true\r\n```\r\n\r\n这是创建原型继承的一种方法，JavaScript还有其他方法来创建对象，我们在后面会一一讲到。\r\n\r\n#### 创建对象\r\n\r\n阅读: 5265805\r\n\r\n------\r\n\r\nJavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。\r\n\r\n当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。\r\n\r\n例如，创建一个`Array`对象：\r\n\r\n```\r\nvar arr = [1, 2, 3];\r\n```\r\n\r\n其原型链是：\r\n\r\n```\r\narr ----> Array.prototype ----> Object.prototype ----> null\r\n```\r\n\r\n`Array.prototype`定义了`indexOf()`、`shift()`等方法，因此你可以在所有的`Array`对象上直接调用这些方法。\r\n\r\n当我们创建一个函数时：\r\n\r\n```\r\nfunction foo() {\r\n    return 0;\r\n}\r\n```\r\n\r\n函数也是一个对象，它的原型链是：\r\n\r\n```\r\nfoo ----> Function.prototype ----> Object.prototype ----> null\r\n```\r\n\r\n由于`Function.prototype`定义了`apply()`等方法，因此，所有函数都可以调用`apply()`方法。\r\n\r\n很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。\r\n\r\n### 构造函数\r\n\r\n除了直接用`{ ... }`创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：\r\n\r\n```\r\nfunction Student(name) {\r\n    this.name = name;\r\n    this.hello = function () {\r\n        alert(\'Hello, \' + this.name + \'!\');\r\n    }\r\n}\r\n```\r\n\r\n你会问，咦，这不是一个普通函数吗？\r\n\r\n这确实是一个普通函数，但是在JavaScript中，可以用关键字`new`来调用这个函数，并返回一个对象：\r\n\r\n```\r\nvar xiaoming = new Student(\'小明\');\r\nxiaoming.name; // \'小明\'\r\nxiaoming.hello(); // Hello, 小明!\r\n```\r\n\r\n*注意*，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。\r\n\r\n新创建的`xiaoming`的原型链是：\r\n\r\n```\r\nxiaoming ----> Student.prototype ----> Object.prototype ----> null\r\n```\r\n\r\n也就是说，`xiaoming`的原型指向函数`Student`的原型。如果你又创建了`xiaohong`、`xiaojun`，那么这些对象的原型与`xiaoming`是一样的：\r\n\r\n```\r\nxiaoming ↘\r\nxiaohong -→ Student.prototype ----> Object.prototype ----> null\r\nxiaojun  ↗\r\n```\r\n\r\n用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：\r\n\r\n```\r\nxiaoming.constructor === Student.prototype.constructor; // true\r\nStudent.prototype.constructor === Student; // true\r\n\r\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\r\n\r\nxiaoming instanceof Student; // true\r\n```\r\n\r\n看晕了吧？用一张图来表示这些乱七八糟的关系就是：\r\n\r\n![protos](D:\\Typora_pic\\l-1585985594802.png)\r\n\r\n红色箭头是原型链。注意，`Student.prototype`指向的对象就是`xiaoming`、`xiaohong`的原型对象，这个原型对象自己还有个属性`constructor`，指向`Student`函数本身。\r\n\r\n另外，函数`Student`恰好有个属性`prototype`指向`xiaoming`、`xiaohong`的原型对象，但是`xiaoming`、`xiaohong`这些对象可没有`prototype`这个属性，不过可以用`__proto__`这个非标准用法来查看。\r\n\r\n现在我们就认为`xiaoming`、`xiaohong`这些对象“继承”自`Student`。\r\n\r\n不过还有一个小问题，注意观察：\r\n\r\n```\r\nxiaoming.name; // \'小明\'\r\nxiaohong.name; // \'小红\'\r\nxiaoming.hello; // function: Student.hello()\r\nxiaohong.hello; // function: Student.hello()\r\nxiaoming.hello === xiaohong.hello; // false\r\n```\r\n\r\n`xiaoming`和`xiaohong`各自的`name`不同，这是对的，否则我们无法区分谁是谁了。\r\n\r\n`xiaoming`和`xiaohong`各自的`hello`是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！\r\n\r\n如果我们通过`new Student()`创建了很多对象，这些对象的`hello`函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。\r\n\r\n要让创建的对象共享一个`hello`函数，根据对象的属性查找原则，我们只要把`hello`函数移动到`xiaoming`、`xiaohong`这些对象共同的原型上就可以了，也就是`Student.prototype`：\r\n\r\n![protos2](D:\\Typora_pic\\l-1585985594743.png)\r\n\r\n修改代码如下：\r\n\r\n```\r\nfunction Student(name) {\r\n    this.name = name;\r\n}\r\n\r\nStudent.prototype.hello = function () {\r\n    alert(\'Hello, \' + this.name + \'!\');\r\n};\r\n```\r\n\r\n用`new`创建基于原型的JavaScript的对象就是这么简单！\r\n\r\n### 忘记写new怎么办\r\n\r\n如果一个函数被定义为用于创建对象的构造函数，但是调用时忘记了写`new`怎么办？\r\n\r\n在strict模式下，`this.name = name`将报错，因为`this`绑定为`undefined`，在非strict模式下，`this.name = name`不报错，因为`this`绑定为`window`，于是无意间创建了全局变量`name`，并且返回`undefined`，这个结果更糟糕。\r\n\r\n所以，调用构造函数千万不要忘记写`new`。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如[jslint](http://www.jslint.com/)将可以帮你检测到漏写的`new`。\r\n\r\n最后，我们还可以编写一个`createStudent()`函数，在内部封装所有的`new`操作。一个常用的编程模式像这样：\r\n\r\n```\r\nfunction Student(props) {\r\n    this.name = props.name || \'匿名\'; // 默认值为\'匿名\'\r\n    this.grade = props.grade || 1; // 默认值为1\r\n}\r\n\r\nStudent.prototype.hello = function () {\r\n    alert(\'Hello, \' + this.name + \'!\');\r\n};\r\n\r\nfunction createStudent(props) {\r\n    return new Student(props || {})\r\n}\r\n```\r\n\r\n这个`createStudent()`函数有几个巨大的优点：一是不需要`new`来调用，二是参数非常灵活，可以不传，也可以这么传：\r\n\r\n```\r\nvar xiaoming = createStudent({\r\n    name: \'小明\'\r\n});\r\n\r\nxiaoming.grade; // 1\r\n```\r\n\r\n如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从`JSON`拿到了一个对象，就可以直接创建出`xiaoming`。\r\n\r\n### 练习\r\n\r\n请利用构造函数定义`Cat`，并让所有的Cat对象有一个`name`属性，并共享一个方法`say()`，返回字符串`\'Hello, xxx!\'`：\r\n\r\n`\'use strict\'; ``// 测试: var kitty = new Cat(\'Kitty\'); var doraemon = new Cat(\'哆啦A梦\'); if (kitty && kitty.name === \'Kitty\' && kitty.say && typeof kitty.say === \'function\' && kitty.say() === \'Hello, Kitty!\' && kitty.say === doraemon.say) {    console.log(\'测试通过!\'); } else {    console.log(\'测试失败!\'); } ` Run\r\n\r\n#### 原型继承\r\n\r\n阅读: 3569473\r\n\r\n------\r\n\r\n在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。\r\n\r\n由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。\r\n\r\n但是办法还是有的。我们先回顾`Student`构造函数：\r\n\r\n```\r\nfunction Student(props) {\r\n    this.name = props.name || \'Unnamed\';\r\n}\r\n\r\nStudent.prototype.hello = function () {\r\n    alert(\'Hello, \' + this.name + \'!\');\r\n}\r\n```\r\n\r\n以及`Student`的原型链：\r\n\r\n![js-proto](D:\\Typora_pic\\l-1585986144180.png)\r\n\r\n现在，我们要基于`Student`扩展出`PrimaryStudent`，可以先定义出`PrimaryStudent`：\r\n\r\n```\r\nfunction PrimaryStudent(props) {\r\n    // 调用Student构造函数，绑定this变量:\r\n    Student.call(this, props);\r\n    this.grade = props.grade || 1;\r\n}\r\n```\r\n\r\n但是，调用了`Student`构造函数不等于继承了`Student`，`PrimaryStudent`创建的对象的原型是：\r\n\r\n```\r\nnew PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null\r\n```\r\n\r\n必须想办法把原型链修改为：\r\n\r\n```\r\nnew PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null\r\n```\r\n\r\n这样，原型链对了，继承关系就对了。新的基于`PrimaryStudent`创建的对象不但能调用`PrimaryStudent.prototype`定义的方法，也可以调用`Student.prototype`定义的方法。\r\n\r\n如果你想用最简单粗暴的方法这么干：\r\n\r\n```\r\nPrimaryStudent.prototype = Student.prototype;\r\n```\r\n\r\n是不行的！如果这样的话，`PrimaryStudent`和`Student`共享一个原型对象，那还要定义`PrimaryStudent`干啥？\r\n\r\n我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向`Student.prototype`。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数`F`来实现：\r\n\r\n```\r\n// PrimaryStudent构造函数:\r\nfunction PrimaryStudent(props) {\r\n    Student.call(this, props);\r\n    this.grade = props.grade || 1;\r\n}\r\n\r\n// 空函数F:\r\nfunction F() {\r\n}\r\n\r\n// 把F的原型指向Student.prototype:\r\nF.prototype = Student.prototype;\r\n\r\n// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:\r\nPrimaryStudent.prototype = new F();\r\n\r\n// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:\r\nPrimaryStudent.prototype.constructor = PrimaryStudent;\r\n\r\n// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：\r\nPrimaryStudent.prototype.getGrade = function () {\r\n    return this.grade;\r\n};\r\n\r\n// 创建xiaoming:\r\nvar xiaoming = new PrimaryStudent({\r\n    name: \'小明\',\r\n    grade: 2\r\n});\r\nxiaoming.name; // \'小明\'\r\nxiaoming.grade; // 2\r\n\r\n// 验证原型:\r\nxiaoming.__proto__ === PrimaryStudent.prototype; // true\r\nxiaoming.__proto__.__proto__ === Student.prototype; // true\r\n\r\n// 验证继承关系:\r\nxiaoming instanceof PrimaryStudent; // true\r\nxiaoming instanceof Student; // true\r\n```\r\n\r\n用一张图来表示新的原型链：\r\n\r\n![js-proto-extend](D:\\Typora_pic\\l-1585986144194.png)\r\n\r\n注意，函数`F`仅用于桥接，我们仅创建了一个`new F()`实例，而且，没有改变原有的`Student`定义的原型链。\r\n\r\n如果把继承这个动作用一个`inherits()`函数封装起来，还可以隐藏`F`的定义，并简化代码：\r\n\r\n```\r\nfunction inherits(Child, Parent) {\r\n    var F = function () {};\r\n    F.prototype = Parent.prototype;\r\n    Child.prototype = new F();\r\n    Child.prototype.constructor = Child;\r\n}\r\n```\r\n\r\n这个`inherits()`函数可以复用：\r\n\r\n```\r\nfunction Student(props) {\r\n    this.name = props.name || \'Unnamed\';\r\n}\r\n\r\nStudent.prototype.hello = function () {\r\n    alert(\'Hello, \' + this.name + \'!\');\r\n}\r\n\r\nfunction PrimaryStudent(props) {\r\n    Student.call(this, props);\r\n    this.grade = props.grade || 1;\r\n}\r\n\r\n// 实现原型继承链:\r\ninherits(PrimaryStudent, Student);\r\n\r\n// 绑定其他方法到PrimaryStudent原型:\r\nPrimaryStudent.prototype.getGrade = function () {\r\n    return this.grade;\r\n};\r\n```\r\n\r\n### 小结\r\n\r\nJavaScript的原型继承实现方式就是：\r\n\r\n1. 定义新的构造函数，并在内部用`call()`调用希望“继承”的构造函数，并绑定`this`；\r\n2. 借助中间函数`F`实现原型链继承，最好通过封装的`inherits`函数完成；\r\n3. 继续在新的构造函数的原型上定义新方法。\r\n\r\n#### class继承\r\n\r\n阅读: 2328573\r\n\r\n------\r\n\r\n在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。\r\n\r\n有没有更简单的写法？有！\r\n\r\n新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\r\n\r\n我们先回顾用函数实现`Student`的方法：\r\n\r\n```\r\nfunction Student(name) {\r\n    this.name = name;\r\n}\r\n\r\nStudent.prototype.hello = function () {\r\n    alert(\'Hello, \' + this.name + \'!\');\r\n}\r\n```\r\n\r\n如果用新的`class`关键字来编写`Student`，可以这样写：\r\n\r\n```\r\nclass Student {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    hello() {\r\n        alert(\'Hello, \' + this.name + \'!\');\r\n    }\r\n}\r\n```\r\n\r\n比较一下就可以发现，`class`的定义包含了构造函数`constructor`和定义在原型对象上的函数`hello()`（注意没有`function`关键字），这样就避免了`Student.prototype.hello = function () {...}`这样分散的代码。\r\n\r\n最后，创建一个`Student`对象代码和前面章节完全一样：\r\n\r\n```\r\nvar xiaoming = new Student(\'小明\');\r\nxiaoming.hello();\r\n```\r\n\r\n### class继承\r\n\r\n用`class`定义对象的另一个巨大的好处是继承更方便了。想一想我们从`Student`派生一个`PrimaryStudent`需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过`extends`来实现：\r\n\r\n```\r\nclass PrimaryStudent extends Student {\r\n    constructor(name, grade) {\r\n        super(name); // 记得用super调用父类的构造方法!\r\n        this.grade = grade;\r\n    }\r\n\r\n    myGrade() {\r\n        alert(\'I am at grade \' + this.grade);\r\n    }\r\n}\r\n```\r\n\r\n注意`PrimaryStudent`的定义也是class关键字实现的，而`extends`则表示原型链对象来自`Student`。子类的构造函数可能会与父类不太相同，例如，`PrimaryStudent`需要`name`和`grade`两个参数，并且需要通过`super(name)`来调用父类的构造函数，否则父类的`name`属性无法正常初始化。\r\n\r\n`PrimaryStudent`已经自动获得了父类`Student`的`hello`方法，我们又在子类中定义了新的`myGrade`方法。\r\n\r\nES6引入的`class`和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，`class`的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用`class`的好处就是极大地简化了原型链代码。\r\n\r\n你一定会问，`class`这么好用，能不能现在就用上？\r\n\r\n现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把`class`代码转换为传统的`prototype`代码，可以试试[Babel](https://babeljs.io/)这个工具。\r\n\r\n### 练习\r\n\r\n请利用`class`重新定义`Cat`，并让它从已有的`Animal`继承，然后新增一个方法`say()`，返回字符串`\'Hello, xxx!\'`：\r\n\r\n`\'use strict\'; class Animal {    constructor(name) {        this.name = name;    } } ``// 测试: var kitty = new Cat(\'Kitty\'); var doraemon = new Cat(\'哆啦A梦\'); if ((new Cat(\'x\') instanceof Animal) && kitty && kitty.name === \'Kitty\' && kitty.say && typeof kitty.say === \'function\' && kitty.say() === \'Hello, Kitty!\' && kitty.say === doraemon.say) {    console.log(\'测试通过!\'); } else {    console.log(\'测试失败!\'); } ` Run\r\n\r\n这个练习需要浏览器支持ES6的`class`，如果遇到SyntaxError，则说明浏览器不支持`class`语法，请换一个最新的浏览器试试。","timestamp":1590329650947},{"name":"148-Untitled.md","path":"13-语言学习project/12-python3/10-框架/0-flask实战/148-Untitled.md","content":"\r\n\r\n## 搭建框架\r\n\r\n![image-20200429220343272](D:\\Typora_pic\\image-20200429220343272.png)\r\n\r\n![image-20200429220349938](D:\\Typora_pic\\image-20200429220349938.png)\r\n\r\n![image-20200429220854562](D:\\Typora_pic\\image-20200429220854562.png)\r\n\r\n![image-20200429220826869](D:\\Typora_pic\\image-20200429220826869.png)\r\n\r\n![image-20200429220600322](D:\\Typora_pic\\image-20200429220600322.png)\r\n\r\n![image-20200429220638617](D:\\Typora_pic\\image-20200429220638617.png)\r\n\r\n![image-20200429220752552](D:\\Typora_pic\\image-20200429220752552.png)\r\n\r\n![image-20200429220743137](D:\\Typora_pic\\image-20200429220743137.png)\r\n\r\n## cms用户模型搭建\r\n\r\n![image-20200429221137443](D:\\Typora_pic\\image-20200429221137443.png)\r\n\r\n![image-20200429221201297](D:\\Typora_pic\\image-20200429221201297.png)![image-20200504221419179](D:\\Typora_pic\\image-20200504221419179.png)\r\n\r\n![image-20200429221610398](D:\\Typora_pic\\image-20200429221610398.png)\r\n\r\n![image-20200429222030828](D:\\Typora_pic\\image-20200429222030828.png)\r\n\r\n![image-20200429222012096](D:\\Typora_pic\\image-20200429222012096.png)\r\n\r\n![image-20200429223109035](D:\\Typora_pic\\image-20200429223109035.png)\r\n\r\n![image-20200504221134409](D:\\Typora_pic\\image-20200504221134409.png)\r\n\r\n![image-20200504221020267](D:\\Typora_pic\\image-20200504221020267.png)\r\n\r\n![image-20200504221223328](D:\\Typora_pic\\image-20200504221223328.png)\r\n\r\n![image-20200504221302088](D:\\Typora_pic\\image-20200504221302088.png)\r\n\r\n![image-20200504221325154](D:\\Typora_pic\\image-20200504221325154.png)\r\n\r\n![image-20200429223133438](D:\\Typora_pic\\image-20200429223133438.png)\r\n\r\n## cms后台登录\r\n\r\n![image-20200429223835423](D:\\Typora_pic\\image-20200429223835423.png)\r\n\r\n![image-20200429224345145](D:\\Typora_pic\\image-20200429224345145.png)\r\n\r\n![image-20200429224523705](D:\\Typora_pic\\image-20200429224523705.png)\r\n\r\n![image-20200429225658941](D:\\Typora_pic\\image-20200429225658941.png)![image-20200429225727836](D:\\Typora_pic\\image-20200429225727836.png)\r\n\r\n![image-20200429225830783](D:\\Typora_pic\\image-20200429225830783.png)\r\n\r\n![image-20200429225925333](D:\\Typora_pic\\image-20200429225925333.png)\r\n\r\n![image-20200429225957434](D:\\Typora_pic\\image-20200429225957434.png)\r\n\r\n![image-20200429230348114](D:\\Typora_pic\\image-20200429230348114.png)\r\n\r\n## 限制登录\r\n\r\n![image-20200504191504369](D:\\Typora_pic\\image-20200504191504369.png)\r\n\r\n![image-20200504191532583](D:\\Typora_pic\\image-20200504191532583.png)\r\n\r\n### user_id优化\r\n\r\n![image-20200504191625163](D:\\Typora_pic\\image-20200504191625163.png)\r\n\r\n![image-20200504191719258](D:\\Typora_pic\\image-20200504191719258.png)\r\n\r\n![image-20200504191739651](D:\\Typora_pic\\image-20200504191739651.png)\r\n\r\n## 定义宏\r\n\r\n![image-20200504192238659](D:\\Typora_pic\\image-20200504192238659.png)\r\n\r\n![image-20200504192306116](D:\\Typora_pic\\image-20200504192306116.png)\r\n\r\n![image-20200504192431080](D:\\Typora_pic\\image-20200504192431080.png)\r\n\r\n## 用户名渲染和注销实现\r\n\r\n​\t![\t](D:\\Typora_pic\\image-20200504192801711.png)\r\n\r\n![image-20200504192843151](D:\\Typora_pic\\image-20200504192843151.png)\r\n\r\n## 注销\r\n\r\n![image-20200504192952359](D:\\Typora_pic\\image-20200504192952359.png)\r\n\r\n![image-20200504193030785](D:\\Typora_pic\\image-20200504193030785.png)\r\n\r\n## 代码优化--钩子函数\r\n\r\n![image-20200504193241592](D:\\Typora_pic\\image-20200504193241592.png)\r\n\r\n![image-20200504193354685](D:\\Typora_pic\\image-20200504193354685.png)\r\n\r\n## csrf保护\r\n\r\n![image-20200504194836002](D:\\Typora_pic\\image-20200504194836002.png)\r\n\r\n![image-20200504194926382](D:\\Typora_pic\\image-20200504194926382.png)\r\n\r\n## 修改密码\r\n\r\n![image-20200505160441150](D:\\Typora_pic\\image-20200505160441150.png)\r\n\r\n1渲染一个csrf-token\r\n\r\n![image-20200505160620833](D:\\Typora_pic\\image-20200505160620833.png)\r\n\r\n![image-20200505160751190](D:\\Typora_pic\\image-20200505160751190.png)\r\n\r\n2/Ajax头部设置x-csrftoken\r\n\r\n![image-20200505160848541](D:\\Typora_pic\\image-20200505160848541.png)\r\n\r\n![image-20200505160908140](D:\\Typora_pic\\image-20200505160908140.png)","timestamp":1590329650947},{"name":"149-alebic数据库.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/149-alebic数据库.md","content":"![image-20200425115454603](D:\\Typora_pic\\image-20200425115454603.png)\r\n\r\n![image-20200425115934987](D:\\Typora_pic\\image-20200425115934987.png)\r\n\r\n![image-20200425120634448](D:\\Typora_pic\\image-20200425120634448.png)\r\n\r\n![image-20200425120654757](D:\\Typora_pic\\image-20200425120654757.png)","timestamp":1590329650947},{"name":"150-CSRF攻击.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/150-CSRF攻击.md","content":"![image-20200425144222125](D:\\Typora_pic\\image-20200425144222125.png)\r\n\r\n![image-20200425151246886](D:\\Typora_pic\\image-20200425151246886.png)","timestamp":1590329650947},{"name":"151-flas.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/151-flas.md","content":"![image-20200425124240250](D:\\Typora_pic\\image-20200425124240250.png)\r\n\r\n![image-20200425124252488](D:\\Typora_pic\\image-20200425124252488.png)\r\n\r\n![image-20200425124522765](D:\\Typora_pic\\image-20200425124522765.png)\r\n\r\n![image-20200425124557996](D:\\Typora_pic\\image-20200425124557996.png)\r\n\r\n![image-20200425124851376](D:\\Typora_pic\\image-20200425124851376.png)\r\n\r\n![image-20200425124909338](D:\\Typora_pic\\image-20200425124909338.png)","timestamp":1590329650947},{"name":"152-flask.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/152-flask.md","content":"![image-20200425141000653](D:\\Typora_pic\\image-20200425141000653.png)\r\n\r\n![image-20200425141130586](D:\\Typora_pic\\image-20200425141130586.png)\r\n\r\n\r\n\r\n==settingcookie==\r\n\r\n![image-20200425141231572](D:\\Typora_pic\\image-20200425141231572.png)\r\n\r\n![image-20200425141522258](D:\\Typora_pic\\image-20200425141522258.png)\r\n\r\n![image-20200425141635822](D:\\Typora_pic\\image-20200425141635822.png)\r\n\r\n## 删除cookie\r\n\r\n![image-20200425141708088](D:\\Typora_pic\\image-20200425141708088.png)\r\n\r\n![image-20200425141814017](D:\\Typora_pic\\image-20200425141814017.png)\r\n\r\n![image-20200425141833734](D:\\Typora_pic\\image-20200425141833734.png)\r\n\r\n## 设置cookie生存时间\r\n\r\n![image-20200425141912599](D:\\Typora_pic\\image-20200425141912599.png)\r\n\r\n![image-20200425141957773](D:\\Typora_pic\\image-20200425141957773.png)\r\n\r\n![image-20200425142104280](D:\\Typora_pic\\image-20200425142104280.png)\r\n\r\n如果,没有设置,默认浏览器关闭后删除\r\n\r\n![image-20200425142157431](D:\\Typora_pic\\image-20200425142157431.png)\r\n\r\n## 设置cookie的域名\r\n\r\n![image-20200425142257978](D:\\Typora_pic\\image-20200425142257978.png)\r\n\r\n修改hosts:\r\n\r\n![image-20200425142359571](D:\\Typora_pic\\image-20200425142359571.png)\r\n\r\n![image-20200425142327729](D:\\Typora_pic\\image-20200425142327729.png)\r\n\r\n![image-20200425142420822](D:\\Typora_pic\\image-20200425142420822.png)\r\n\r\n![image-20200425142512960](D:\\Typora_pic\\image-20200425142512960.png)\r\n\r\n![image-20200425142611311](D:\\Typora_pic\\image-20200425142611311.png)\r\n\r\n![image-20200425142629211](D:\\Typora_pic\\image-20200425142629211.png)\r\n\r\n![image-20200425142700485](D:\\Typora_pic\\image-20200425142700485.png)","timestamp":1590329650947},{"name":"153-flask.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/153-flask.md","content":"![image-20200425121829715](D:\\Typora_pic\\image-20200425121829715.png)\r\n\r\n![image-20200425121815004](D:\\Typora_pic\\image-20200425121815004.png)\r\n\r\n![image-20200425121859870](D:\\Typora_pic\\image-20200425121859870.png)","timestamp":1590329650947},{"name":"154-flask_script.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/154-flask_script.md","content":"![image-20200425121947847](D:\\Typora_pic\\image-20200425121947847.png)\r\n\r\n![image-20200425122650004](D:\\Typora_pic\\image-20200425122650004.png)\r\n\r\n![image-20200425122457303](D:\\Typora_pic\\image-20200425122457303.png)\r\n\r\n![image-20200425122355263](D:\\Typora_pic\\image-20200425122355263.png)\r\n\r\n![image-20200425122346242](D:\\Typora_pic\\image-20200425122346242.png)\r\n\r\n![image-20200425122619740](D:\\Typora_pic\\image-20200425122619740.png)\r\n\r\n![image-20200425122730304](D:\\Typora_pic\\image-20200425122730304.png)\r\n\r\n![image-20200425123226187](D:\\Typora_pic\\image-20200425123226187.png)\r\n\r\n![image-20200425123253672](D:\\Typora_pic\\image-20200425123253672.png)\r\n\r\n![image-20200425123620742](D:\\Typora_pic\\image-20200425123620742.png)","timestamp":1590329650947},{"name":"155-flask_session.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/155-flask_session.md","content":"![image-20200425144131706](D:\\Typora_pic\\image-20200425144131706.png)![image-20200425142725502](D:\\Typora_pic\\image-20200425142725502.png)\r\n\r\n![image-20200425143544987](D:\\Typora_pic\\image-20200425143544987.png)\r\n\r\n## flask-session\r\n\r\n![image-20200425143857527](D:\\Typora_pic\\image-20200425143857527.png)\r\n\r\n![image-20200425144113146](D:\\Typora_pic\\image-20200425144113146.png)\r\n\r\n![image-20200425144133066](D:\\Typora_pic\\image-20200425144133066.png)","timestamp":1590329650947},{"name":"156-flask_sqlalchemy.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/156-flask_sqlalchemy.md","content":"![image-20200425113835024](D:\\Typora_pic\\image-20200425113835024.png)\r\n\r\n![image-20200425114350394](D:\\Typora_pic\\image-20200425114350394.png)\r\n\r\n![image-20200425114443217](D:\\Typora_pic\\image-20200425114443217.png)\r\n\r\n![image-20200425114509987](D:\\Typora_pic\\image-20200425114509987.png)\r\n\r\n![image-20200425114643612](D:\\Typora_pic\\image-20200425114643612.png)\r\n\r\n### 不推荐\r\n\r\n![image-20200425114822646](D:\\Typora_pic\\image-20200425114822646.png)\r\n\r\n![image-20200425114933025](D:\\Typora_pic\\image-20200425114933025.png)\r\n\r\n![image-20200425115029416](D:\\Typora_pic\\image-20200425115029416.png)","timestamp":1590329650947},{"name":"157-flask_WTF.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/157-flask_WTF.md","content":"![image-20200425131854369](D:\\Typora_pic\\image-20200425131854369.png)\r\n\r\n![image-20200425132943940](D:\\Typora_pic\\image-20200425132943940.png)\r\n\r\n![image-20200425132952705](D:\\Typora_pic\\image-20200425132952705.png)\r\n\r\n![image-20200425133046704](D:\\Typora_pic\\image-20200425133046704.png)\r\n\r\n## WTF 验证器\r\n\r\n![image-20200425133121792](D:\\Typora_pic\\image-20200425133121792.png)\r\n\r\n![image-20200425133301816](D:\\Typora_pic\\image-20200425133301816.png)\r\n\r\n![image-20200425133506942](D:\\Typora_pic\\image-20200425133506942.png)\r\n\r\n![image-20200425134207023](D:\\Typora_pic\\image-20200425134207023.png)\r\n\r\n## 自定义验证字段\r\n\r\n![image-20200425134436599](D:\\Typora_pic\\image-20200425134436599.png)\r\n\r\n![image-20200425134609616](D:\\Typora_pic\\image-20200425134609616.png)\r\n\r\n## 使用WTF渲染模板\r\n\r\n![image-20200425135004511](D:\\Typora_pic\\image-20200425135004511.png)\r\n\r\n![image-20200425135016320](D:\\Typora_pic\\image-20200425135016320.png)\r\n\r\n![image-20200425135228693](D:\\Typora_pic\\image-20200425135228693.png)\r\n\r\n## 文件上传\r\n\r\n![image-20200425135540226](D:\\Typora_pic\\image-20200425135540226.png)\r\n\r\n![image-20200425135835025](D:\\Typora_pic\\image-20200425135835025.png)\r\n\r\n![image-20200425135934651](D:\\Typora_pic\\image-20200425135934651.png)\r\n\r\n访问文件\r\n\r\n![image-20200425140141358](D:\\Typora_pic\\image-20200425140141358.png)\r\n\r\n![image-20200425140200573](D:\\Typora_pic\\image-20200425140200573.png)\r\n\r\n## 文件上传校验\r\n\r\n![image-20200425140443890](D:\\Typora_pic\\image-20200425140443890.png)\r\n\r\n![image-20200425140611658](D:\\Typora_pic\\image-20200425140611658.png)\r\n\r\n将request.form和request.files合并到一起进行验证\r\n\r\n![image-20200425140644447](D:\\Typora_pic\\image-20200425140644447.png)\r\n\r\n![image-20200425140846605](D:\\Typora_pic\\image-20200425140846605.png)\r\n\r\n![image-20200425140920236](D:\\Typora_pic\\image-20200425140920236.png)","timestamp":1590329650947},{"name":"158-flask上下文.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/158-flask上下文.md","content":"![image-20200425152505301](D:\\Typora_pic\\image-20200425152505301.png)\r\n\r\n![image-20200425152643090](D:\\Typora_pic\\image-20200425152643090.png)\r\n\r\n![image-20200425152658082](D:\\Typora_pic\\image-20200425152658082.png)\r\n\r\napp上下文和request上下文\r\n\r\n![image-20200425153529049](D:\\Typora_pic\\image-20200425153529049.png)\r\n\r\n![image-20200425153520824](D:\\Typora_pic\\image-20200425153520824.png)\r\n\r\n![image-20200425153849847](D:\\Typora_pic\\image-20200425153849847.png)\r\n\r\n![image-20200425153910699](D:\\Typora_pic\\image-20200425153910699.png)\r\n\r\n\r\n\r\n![image-20200427203645872](D:\\Typora_pic\\image-20200427203645872.png)","timestamp":1590329650947},{"name":"159-flask框架.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/159-flask框架.md","content":"## debug\r\n\r\n![image-20200423214602745](D:\\Typora_pic\\image-20200423214602745.png)\r\n\r\n![image-20200423214654160](D:\\Typora_pic\\image-20200423214654160.png)\r\n\r\n不需要import,必须写文件名字,  py和txt文件同样适用,==silent=true 找不到文件不报错静默执行==\r\n\r\n![image-20200423214843578](D:\\Typora_pic\\image-20200423214843578.png)\r\n\r\n![image-20200423215132844](D:\\Typora_pic\\image-20200423215132844.png)\r\n\r\n![image-20200423215504390](D:\\Typora_pic\\image-20200423215504390.png)\r\n\r\n## URL+参数\r\n\r\n![image-20200423215623639](D:\\Typora_pic\\image-20200423215623639.png)\r\n\r\n![image-20200423215905834](D:\\Typora_pic\\image-20200423215905834.png)\r\n\r\n![image-20200423220557152](D:\\Typora_pic\\image-20200423220557152.png)\r\n\r\n![image-20200423220700185](D:\\Typora_pic\\image-20200423220700185.png)\r\n\r\n## 自定义url转换器BaseConverter\r\n\r\n![image-20200423221030493](D:\\Typora_pic\\image-20200423221030493.png)\r\n\r\n![image-20200423221612995](D:\\Typora_pic\\image-20200423221612995.png)\r\n\r\n路径加/,以防访问不到\r\n\r\n![image-20200423221854350](D:\\Typora_pic\\image-20200423221854350.png)\r\n\r\n## get+POST\r\n\r\n![image-20200423222119869](D:\\Typora_pic\\image-20200423222119869.png)\r\n\r\n## 页面跳转和重定向\r\n\r\n![image-20200423222146419](D:\\Typora_pic\\image-20200423222146419.png)\r\n\r\n![image-20200423222405164](D:\\Typora_pic\\image-20200423222405164.png)\r\n\r\n## response\r\n\r\n![image-20200423222453344](D:\\Typora_pic\\image-20200423222453344.png)\r\n\r\n![image-20200423223007906](D:\\Typora_pic\\image-20200423223007906.png)\r\n\r\n![image-20200423223030739](D:\\Typora_pic\\image-20200423223030739.png)\r\n\r\n将接受到的response类型强制转换为json对象\r\n\r\n![image-20200423223154675](D:\\Typora_pic\\image-20200423223154675.png)\r\n\r\n![image-20200423223414924](D:\\Typora_pic\\image-20200423223414924.png)\r\n\r\n## jinjia2\r\n\r\n### 指定templates\r\n\r\n![image-20200423223652186](D:\\Typora_pic\\image-20200423223652186.png)\r\n\r\n![image-20200423223729396](D:\\Typora_pic\\image-20200423223729396.png)\r\n\r\n### 变量\r\n\r\n![image-20200423223846886](D:\\Typora_pic\\image-20200423223846886.png)\r\n\r\n==将字典key=value传进模板,可以直接使用{{age}}==\r\n\r\n![image-20200423224155601](D:\\Typora_pic\\image-20200423224155601.png)\r\n\r\n![image-20200423224139295](D:\\Typora_pic\\image-20200423224139295.png)\r\n\r\n![image-20200423224107335](D:\\Typora_pic\\image-20200423224107335.png)\r\n\r\n### 模板中使用url_for\r\n\r\n![image-20200423224617427](D:\\Typora_pic\\image-20200423224617427.png)\r\n\r\n### 过滤器\r\n\r\n![image-20200423224837911](D:\\Typora_pic\\image-20200423224837911.png)\r\n\r\n![image-20200423225201612](D:\\Typora_pic\\image-20200423225201612.png)\r\n\r\n![image-20200423225234424](D:\\Typora_pic\\image-20200423225234424.png)\r\n\r\n![image-20200423225304325](D:\\Typora_pic\\image-20200423225304325.png)\r\n\r\n![image-20200423225425283](D:\\Typora_pic\\image-20200423225425283.png)\r\n\r\n![image-20200423225538069](D:\\Typora_pic\\image-20200423225538069.png)\r\n\r\n![image-20200423225711321](D:\\Typora_pic\\image-20200423225711321.png)\r\n\r\n![image-20200423225749439](D:\\Typora_pic\\image-20200423225749439.png)\r\n\r\ntruncate:简介内容使用\r\n\r\n![image-20200423225938700](D:\\Typora_pic\\image-20200423225938700.png)\r\n\r\n### 自定义过滤器\r\n\r\n![image-20200423230312227](D:\\Typora_pic\\image-20200423230312227.png)\r\n\r\n![image-20200423230330289](D:\\Typora_pic\\image-20200423230330289.png)\r\n\r\n![image-20200423230453405](D:\\Typora_pic\\image-20200423230453405.png)\r\n\r\n![image-20200423230436408](D:\\Typora_pic\\image-20200423230436408.png)\r\n\r\n![image-20200423230514647](D:\\Typora_pic\\image-20200423230514647.png)\r\n\r\n![image-20200423230632863](D:\\Typora_pic\\image-20200423230632863.png)\r\n\r\n![image-20200423230715695](D:\\Typora_pic\\image-20200423230715695.png)\r\n\r\n![image-20200423231222089](D:\\Typora_pic\\image-20200423231222089.png)\r\n\r\n![image-20200423231406358](D:\\Typora_pic\\image-20200423231406358.png)\r\n\r\n### 宏\r\n\r\n![image-20200423231447568](D:\\Typora_pic\\image-20200423231447568.png)\r\n\r\n![image-20200423231910961](D:\\Typora_pic\\image-20200423231910961.png)\r\n\r\n### 导入宏\r\n\r\n![image-20200423231954889](D:\\Typora_pic\\image-20200423231954889.png)\r\n\r\n![image-20200423232438368](D:\\Typora_pic\\image-20200423232438368.png)\r\n\r\n### include\r\n\r\n![image-20200423233048785](D:\\Typora_pic\\image-20200423233048785.png)\r\n\r\n![image-20200423233106410](D:\\Typora_pic\\image-20200423233106410.png)\r\n\r\n![image-20200423233233938](D:\\Typora_pic\\image-20200423233233938.png)\r\n\r\n### set  with  模板中定义变量\r\n\r\n![image-20200423233341487](D:\\Typora_pic\\image-20200423233341487.png)\r\n\r\n![image-20200423233543642](D:\\Typora_pic\\image-20200423233543642.png)\r\n\r\n### 加载静态文件\r\n\r\n![image-20200423233635146](D:\\Typora_pic\\image-20200423233635146.png)\r\n\r\n![image-20200423233755634](D:\\Typora_pic\\image-20200423233755634.png)\r\n\r\n### 继承和block\r\n\r\n![image-20200423233917568](D:\\Typora_pic\\image-20200423233917568.png)\r\n\r\n\r\n\r\n![image-20200423234121781](D:\\Typora_pic\\image-20200423234121781.png)\r\n\r\n![image-20200423234414891](D:\\Typora_pic\\image-20200423234414891.png)\r\n\r\n![image-20200423234457482](D:\\Typora_pic\\image-20200423234457482.png)","timestamp":1590329650947},{"name":"160-flask蓝图.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/160-flask蓝图.md","content":"![image-20200424230032536](D:\\Typora_pic\\image-20200424230700827.png)\r\n\r\n![image-20200424230040787](D:\\Typora_pic\\image-20200424230040787.png)\r\n\r\n![image-20200424230823351](D:\\Typora_pic\\image-20200424230823351.png)\r\n\r\n![image-20200424230843590](D:\\Typora_pic\\image-20200424230843590.png)\r\n\r\n![image-20200424231345263](D:\\Typora_pic\\image-20200424231345263.png)\r\n\r\n![image-20200424231410464](D:\\Typora_pic\\image-20200424231410464.png)\r\n\r\n![image-20200424231654147](D:\\Typora_pic\\image-20200424231654147.png)\r\n\r\n![image-20200424231720012](D:\\Typora_pic\\image-20200424231720012.png)\r\n\r\n![image-20200424231737044](D:\\Typora_pic\\image-20200424231737044.png)\r\n\r\n![image-20200424231810657](D:\\Typora_pic\\image-20200424231810657.png)\r\n\r\n### url_for反转视图\r\n\r\n![image-20200424232129405](D:\\Typora_pic\\image-20200424232129405.png)\r\n\r\n![image-20200424232142696](D:\\Typora_pic\\image-20200424232142696.png)\r\n\r\n![image-20200424232338824](D:\\Typora_pic\\image-20200424232338824.png)","timestamp":1590329650947},{"name":"161-flask进阶.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/161-flask进阶.md","content":"### 视图高级\r\n\r\n![image-20200424212715459](D:\\Typora_pic\\image-20200424212715459.png)\r\n\r\n![image-20200424212737223](D:\\Typora_pic\\image-20200424212737223.png)\r\n\r\n### 视图\r\n\r\n![image-20200424214517298](D:\\Typora_pic\\image-20200424214517298.png)\r\n\r\n![image-20200424214525094](D:\\Typora_pic\\image-20200424214525094.png)\r\n\r\n### 标准视图\r\n\r\n![image-20200424214740303](D:\\Typora_pic\\image-20200424214740303.png)\r\n\r\n![image-20200424220944632](D:\\Typora_pic\\image-20200424220944632.png)\r\n\r\n![image-20200424220218840](D:\\Typora_pic\\image-20200424220218840.png)\r\n\r\n![image-20200424220421408](D:\\Typora_pic\\image-20200424220421408.png)\r\n\r\n![image-20200424220831843](D:\\Typora_pic\\image-20200424220831843.png)\r\n\r\n### 基于调度的类视图\r\n\r\n![image-20200424221832420](D:\\Typora_pic\\image-20200424221832420.png)\r\n\r\n![image-20200424221921808](D:\\Typora_pic\\image-20200424221921808.png)\r\n\r\n![image-20200424222307298](D:\\Typora_pic\\image-20200424222307298.png)\r\n\r\n![image-20200424222033189](D:\\Typora_pic\\image-20200424222033189.png)\r\n\r\n### 装饰器的类视图\r\n\r\n![image-20200424223226219](D:\\Typora_pic\\image-20200424223226219.png)\r\n\r\n![image-20200424223559717](D:\\Typora_pic\\image-20200424223559717.png)\r\n\r\n![image-20200424223751892](D:\\Typora_pic\\image-20200424223751892.png)\r\n\r\n![image-20200424230317385](D:\\Typora_pic\\image-20200424230317385.png)","timestamp":1590329650947},{"name":"162-memcache.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/162-memcache.md","content":"![image-20200428213641810](D:\\Typora_pic\\image-20200428213641810.png)\r\n\r\n![image-20200428215244842](D:\\Typora_pic\\image-20200428215244842.png)\r\n\r\n![image-20200428215656598](D:\\Typora_pic\\image-20200428215656598.png)\r\n\r\n![image-20200428220038354](D:\\Typora_pic\\image-20200428220038354.png)\r\n\r\n![image-20200428220132532](D:\\Typora_pic\\image-20200428220132532.png)\r\n\r\n![image-20200428220311852](D:\\Typora_pic\\image-20200428220311852.png)\r\n\r\n![image-20200428220617509](D:\\Typora_pic\\image-20200428220617509.png)\r\n\r\n![image-20200428220639483](D:\\Typora_pic\\image-20200428220639483.png)\r\n\r\n![image-20200428220754252](D:\\Typora_pic\\image-20200428220754252.png)\r\n\r\ntelnet 链接\r\n\r\n![image-20200428220854269](D:\\Typora_pic\\image-20200428220854269.png)\r\n\r\n![image-20200428221502905](D:\\Typora_pic\\image-20200428221502905.png)\r\n\r\n![image-20200428221538084](D:\\Typora_pic\\image-20200428221538084.png)\r\n\r\n![image-20200428222150448](D:\\Typora_pic\\image-20200428222150448.png)\r\n\r\n![image-20200428223232285](D:\\Typora_pic\\image-20200428223232285.png)\r\n\r\n![image-20200428223603963](D:\\Typora_pic\\image-20200428223603963.png)\r\n\r\nstats  查看命令的执行次数\r\n\r\n![image-20200428223445417](D:\\Typora_pic\\image-20200428223445417.png)\r\n\r\n## 使用python使用memcache\r\n\r\n![image-20200428224048814](D:\\Typora_pic\\image-20200428224048814.png)\r\n\r\n![image-20200428224325534](D:\\Typora_pic\\image-20200428224325534.png)\r\n\r\n![image-20200428224437402](D:\\Typora_pic\\image-20200428224437402.png)\r\n\r\n### 连接多台虚拟机\r\n\r\n![image-20200428224541987](D:\\Typora_pic\\image-20200428224541987.png)\r\n\r\n\r\n\r\n开启端口\r\n\r\n![image-20200428224700764](D:\\Typora_pic\\image-20200428224700764.png)\r\n\r\n分布式\r\n\r\n![image-20200428224806553](D:\\Typora_pic\\image-20200428224806553.png)\r\n\r\n## memcache的安全机制\r\n\r\n![image-20200428225253024](D:\\Typora_pic\\image-20200428225253024.png)\r\n\r\n![image-20200428225450404](D:\\Typora_pic\\image-20200428225450404.png)","timestamp":1590329650947},{"name":"163-mysql.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/163-mysql.md","content":"![image-20200424234503449](D:\\Typora_pic\\image-20200424234503449.png)\r\n\r\n```shell\r\npip install pymysql\r\npip install SQLAlchemy\r\n```\r\n\r\n![image-20200424234632035](D:\\Typora_pic\\image-20200424234632035.png)\r\n\r\n![image-20200424235503954](D:\\Typora_pic\\image-20200424235503954.png)\r\n\r\n![image-20200425072220278](D:\\Typora_pic\\image-20200425072220278.png)\r\n\r\n### ORM 对象关系映射 Object relationship mapping\r\n\r\n![image-20200425072642700](D:\\Typora_pic\\image-20200425072642700.png)\r\n\r\n![image-20200425072802929](D:\\Typora_pic\\image-20200425072802929.png)\r\n\r\n### ORM 绑定到数据库\r\n\r\n![image-20200425073601703](D:\\Typora_pic\\image-20200425073601703.png)\r\n\r\n![image-20200425073747635](D:\\Typora_pic\\image-20200425073747635.png)\r\n\r\n![image-20200425073914769](D:\\Typora_pic\\image-20200425073914769.png)\r\n\r\n![image-20200425073959623](D:\\Typora_pic\\image-20200425073959623.png)\r\n\r\n### SQLAlchemy类型\r\n\r\n![image-20200425074212924](D:\\Typora_pic\\image-20200425074212924.png)\r\n\r\n![image-20200425074219491](D:\\Typora_pic\\image-20200425074219491.png)\r\n\r\n![image-20200425074854120](D:\\Typora_pic\\image-20200425074854120.png)\r\n\r\n==decimal:总长度10,小数位4==  存储金额的时候专门使用的,为精度专门定义的一种类型\r\n\r\n![image-20200425075016818](D:\\Typora_pic\\image-20200425075016818.png)\r\n\r\n![image-20200425075415494](D:\\Typora_pic\\image-20200425075415494.png)\r\n\r\n![image-20200425075546546](D:\\Typora_pic\\image-20200425075546546.png)\r\n\r\n![image-20200425075713911](D:\\Typora_pic\\image-20200425075713911.png)\r\n\r\n![image-20200425075702210](D:\\Typora_pic\\image-20200425075702210.png)\r\n\r\n![image-20200425075816885](D:\\Typora_pic\\image-20200425075816885.png)\r\n\r\n![image-20200425075912181](D:\\Typora_pic\\image-20200425075912181.png)\r\n\r\n![image-20200425075919954](D:\\Typora_pic\\image-20200425075919954.png)\r\n\r\n![image-20200425075956450](D:\\Typora_pic\\image-20200425075956450.png)\r\n\r\n### column 常用参数\r\n\r\n![image-20200425080812418](D:\\Typora_pic\\image-20200425080812418.png)\r\n\r\n![image-20200425080627928](D:\\Typora_pic\\image-20200425080627928.png)\r\n\r\n### query\r\n\r\n![image-20200425080838085](D:\\Typora_pic\\image-20200425080838085.png)\r\n\r\n![image-20200425092702513](D:\\Typora_pic\\image-20200425092702513.png)\r\n\r\n### filter\r\n\r\n![image-20200425092746640](D:\\Typora_pic\\image-20200425092746640.png)\r\n\r\n![image-20200425092807765](D:\\Typora_pic\\image-20200425092807765.png)\r\n\r\n![image-20200425093526564](D:\\Typora_pic\\image-20200425093526564.png)\r\n\r\n### 外键和四种约束\r\n\r\n![image-20200425093653681](D:\\Typora_pic\\image-20200425093653681.png)\r\n\r\n​\t![image-20200425094313150](D:\\Typora_pic\\image-20200425094313150.png)\r\n\r\n![image-20200425095224878](D:\\Typora_pic\\image-20200425095224878.png)\r\n\r\n## 一对多关系\r\n\r\n![image-20200425095441426](D:\\Typora_pic\\image-20200425095441426.png)\r\n\r\n### 父子模型中分别定义关联\r\n\r\n![image-20200425095817598](D:\\Typora_pic\\image-20200425095817598.png)\r\n\r\n![image-20200425095640863](D:\\Typora_pic\\image-20200425095640863.png)\r\n\r\n![image-20200425095830116](D:\\Typora_pic\\image-20200425095830116.png)\r\n\r\n### 只在子模型中定义关联\r\n\r\n![image-20200425100004709](D:\\Typora_pic\\image-20200425100004709.png)\r\n\r\n## 一对一关系\r\n\r\n==提交父表,添加子表==\r\n\r\n![image-20200425100335621](D:\\Typora_pic\\image-20200425100335621.png)\r\n\r\n==提交子表,添加父表==\r\n\r\n![image-20200425100432809](D:\\Typora_pic\\image-20200425100432809.png)\r\n\r\n### 一对一\r\n\r\n![image-20200425101127893](D:\\Typora_pic\\image-20200425101127893.png)\r\n\r\n![image-20200425101237558](D:\\Typora_pic\\image-20200425101237558.png)\r\n\r\n![image-20200425101321895](D:\\Typora_pic\\image-20200425101321895.png)\r\n\r\n==只在子表中添加一对一关联==\r\n\r\n![image-20200425101355215](D:\\Typora_pic\\image-20200425101355215.png)\r\n\r\n## 多对多关系\r\n\r\n![image-20200425102327782](D:\\Typora_pic\\image-20200425102327782.png)\r\n\r\n![image-20200425102403604](D:\\Typora_pic\\image-20200425102403604.png)\r\n\r\n![image-20200425102642626](D:\\Typora_pic\\image-20200425102642626.png)\r\n\r\n## cascade\r\n\r\n![image-20200425103334061](D:\\Typora_pic\\image-20200425103334061.png)\r\n\r\n![image-20200425103453448](D:\\Typora_pic\\image-20200425103453448.png)\r\n\r\n![image-20200425103829410](D:\\Typora_pic\\image-20200425103829410.png)\r\n\r\n![image-20200425104118933](D:\\Typora_pic\\image-20200425104118933.png)\r\n\r\n![image-20200425104204782](D:\\Typora_pic\\image-20200425104204782.png)\r\n\r\n![image-20200425104643862](D:\\Typora_pic\\image-20200425104643862.png)\r\n\r\n![image-20200425105214102](D:\\Typora_pic\\image-20200425105214102.png)\r\n\r\n## 排序\r\n\r\n![image-20200425105344917](D:\\Typora_pic\\image-20200425105344917.png)\r\n\r\n![image-20200425105518324](D:\\Typora_pic\\image-20200425105518324.png)\r\n\r\n## 切片\r\n\r\n![image-20200425110027314](D:\\Typora_pic\\image-20200425110027314.png)\r\n\r\n![image-20200425105956064](D:\\Typora_pic\\image-20200425105956064.png)\r\n\r\nlimit :找多少条\r\n\r\n![image-20200425110104922](D:\\Typora_pic\\image-20200425110104922.png)\r\n\r\noffset 偏移\r\n\r\n![image-20200425110214899](D:\\Typora_pic\\image-20200425110214899.png)\r\n\r\nslice  倒数10个\r\n\r\n![image-20200425110325313](D:\\Typora_pic\\image-20200425110325313.png)\r\n\r\n![image-20200425110348718](D:\\Typora_pic\\image-20200425110348718.png)\r\n\r\n## 数据查询懒加载\r\n\r\n![image-20200425111050027](D:\\Typora_pic\\image-20200425111050027.png)\r\n\r\n![image-20200425111235974](D:\\Typora_pic\\image-20200425111235974.png)\r\n\r\n![image-20200425111133354](D:\\Typora_pic\\image-20200425111133354.png)\r\n\r\n![image-20200425111430528](D:\\Typora_pic\\image-20200425111430528.png)\r\n\r\n## 高级查询\r\n\r\n![image-20200425111537174](D:\\Typora_pic\\image-20200425111537174.png)\r\n\r\n![image-20200425111912028](D:\\Typora_pic\\image-20200425111912028.png)\r\n\r\n![image-20200425111929525](D:\\Typora_pic\\image-20200425111929525.png)\r\n\r\n![image-20200425111943351](D:\\Typora_pic\\image-20200425111943351.png)\r\n\r\n![image-20200425112252545](D:\\Typora_pic\\image-20200425112252545.png)\r\n\r\n![image-20200425112529699](D:\\Typora_pic\\image-20200425112529699.png)\r\n\r\n### 联合查询\r\n\r\n![image-20200425112924642](D:\\Typora_pic\\image-20200425112924642.png)","timestamp":1590329650947},{"name":"164-redis.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/164-redis.md","content":"![image-20200428225558234](D:\\Typora_pic\\image-20200428225558234.png)\r\n\r\n![image-20200428225701816](D:\\Typora_pic\\image-20200428225701816.png)\r\n\r\n![image-20200428230244111](D:\\Typora_pic\\image-20200428230244111.png)\r\n\r\n![image-20200428230506108](D:\\Typora_pic\\image-20200428230506108.png)\r\n\r\n![image-20200428230717142](D:\\Typora_pic\\image-20200428230717142.png)\r\n\r\n![image-20200428230950987](D:\\Typora_pic\\image-20200428230950987.png)\r\n\r\n## 列表操作\r\n\r\n![image-20200428231038992](D:\\Typora_pic\\image-20200428231038992.png)\r\n\r\n![image-20200428231309308](D:\\Typora_pic\\image-20200428231309308.png)\r\n\r\n![image-20200428231515463](D:\\Typora_pic\\image-20200428231515463.png)\r\n\r\n删除列表websites中 1个 值为baidu\r\n\r\n![image-20200428231602026](D:\\Typora_pic\\image-20200428231602026.png)\r\n\r\n正值从头开始删除,-1从结束位置开始删除\r\n\r\n![image-20200428231721596](D:\\Typora_pic\\image-20200428231721596.png)\r\n\r\n## 集合操作\r\n\r\n数据不能重复,无序\r\n\r\n![image-20200428231837708](D:\\Typora_pic\\image-20200428231837708.png)\r\n\r\n![image-20200428231948487](D:\\Typora_pic\\image-20200428231948487.png)\r\n\r\n![image-20200428232233955](D:\\Typora_pic\\image-20200428232233955.png)\r\n\r\n## 哈希操作\r\n\r\n![image-20200428232414381](D:\\Typora_pic\\image-20200428232414381.png)\r\n\r\n![image-20200428232458593](D:\\Typora_pic\\image-20200428232458593.png)\r\n\r\n![image-20200428232646881](D:\\Typora_pic\\image-20200428232646881.png)\r\n\r\n![image-20200428232739763](D:\\Typora_pic\\image-20200428232739763.png)\r\n\r\n## 事务操作\r\n\r\n![image-20200428232841216](D:\\Typora_pic\\image-20200428232841216.png)\r\n\r\n![image-20200428232943367](D:\\Typora_pic\\image-20200428232943367.png)![image-20200428233015707](D:\\Typora_pic\\image-20200428233015707.png)\r\n\r\n监听时如果值改变,事务就会取消执行\r\n\r\n![image-20200428233133294](D:\\Typora_pic\\image-20200428233133294.png)\r\n\r\n![image-20200428233228449](D:\\Typora_pic\\image-20200428233228449.png)\r\n\r\n## 发布和订阅\r\n\r\n![image-20200428233319291](D:\\Typora_pic\\image-20200428233319291.png)\r\n\r\n![image-20200428233350083](D:\\Typora_pic\\image-20200428233350083.png)![image-20200428233409374](D:\\Typora_pic\\image-20200428233409374.png)\r\n\r\n订阅多个频道\r\n\r\n![image-20200428233425226](D:\\Typora_pic\\image-20200428233425226.png)\r\n\r\n![image-20200428233444063](D:\\Typora_pic\\image-20200428233444063.png)\r\n\r\n## 数据持久化机制\r\n\r\n![image-20200428234817622](D:\\Typora_pic\\image-20200428234817622.png)\r\n\r\n![image-20200428235047513](D:\\Typora_pic\\image-20200428235047513.png)\r\n\r\n配置文件![image-20200428233632666](D:\\Typora_pic\\image-20200428233632666.png)\r\n\r\n### RDB机制\r\n\r\n---\r\n\r\n\r\n\r\n![image-20200428233644313](D:\\Typora_pic\\image-20200428233644313.png)\r\n\r\n在900 秒内出现1次数据写操作,就同步数据\r\n\r\n数据库存在的目录:\r\n\r\n![image-20200428233842099](D:\\Typora_pic\\image-20200428233842099.png)\r\n\r\n修改后需要重启redis服务,才生效\r\n\r\n![image-20200428233920745](D:\\Typora_pic\\image-20200428233920745.png)\r\n\r\n![image-20200428234019842](D:\\Typora_pic\\image-20200428234019842.png)\r\n\r\n数据存储:键值对,经过压缩\r\n\r\n![image-20200428234733920](D:\\Typora_pic\\image-20200428234733920.png)\r\n\r\n### AOF机制\r\n\r\n---\r\n\r\n![image-20200428234225544](D:\\Typora_pic\\image-20200428234225544.png)\r\n\r\n![image-20200428234405825](D:\\Typora_pic\\image-20200428234405825.png)\r\n\r\n保存数据的文件名\r\n\r\n![image-20200428234425671](D:\\Typora_pic\\image-20200428234425671.png)\r\n\r\n同步机制:![image-20200428234519364](D:\\Typora_pic\\image-20200428234519364.png)\r\n\r\n![image-20200428234629256](D:\\Typora_pic\\image-20200428234629256.png)![image-20200428234800599](D:\\Typora_pic\\image-20200428234800599.png)\r\n\r\n## 安全\r\n\r\n![image-20200428235213996](D:\\Typora_pic\\image-20200428235255288.png)\r\n\r\n设置配置文件中的密码![image-20200428235337976](D:\\Typora_pic\\image-20200428235337976.png)![image-20200428235343944](D:\\Typora_pic\\image-20200428235343944.png)\r\n\r\n![image-20200428235307660](D:\\Typora_pic\\image-20200428235307660.png)\r\n\r\n连接时设置密码\r\n\r\n![image-20200428235427306](D:\\Typora_pic\\image-20200428235427306.png)\r\n\r\n![image-20200428235457524](D:\\Typora_pic\\image-20200428235457524.png)\r\n\r\n## 其他机器链接redis\r\n\r\n设置允许远程链接 ==增加远程IP== 配置文件\r\n\r\n![image-20200428235626707](D:\\Typora_pic\\image-20200428235626707.png)\r\n\r\n![image-20200428235647306](D:\\Typora_pic\\image-20200428235647306.png)\r\n\r\n![image-20200428235658726](D:\\Typora_pic\\image-20200428235658726.png)\r\n\r\n## python操作redis\r\n\r\n![image-20200428235820157](D:\\Typora_pic\\image-20200428235820157.png)\r\n\r\n![image-20200429000104792](D:\\Typora_pic\\image-20200429000104792.png)\r\n\r\n![image-20200429000129058](D:\\Typora_pic\\image-20200429000129058.png)\r\n\r\n![image-20200429000222684](D:\\Typora_pic\\image-20200429000222684.png)\r\n\r\n![image-20200429000452824](D:\\Typora_pic\\image-20200429000452824.png)\r\n\r\n![image-20200429000240346](D:\\Typora_pic\\image-20200429000240346.png)![image-20200429000250829](D:\\Typora_pic\\image-20200429000250829.png)\r\n\r\n![image-20200429000343066](D:\\Typora_pic\\image-20200429000343066.png)\r\n\r\n![image-20200429000821288](D:\\Typora_pic\\image-20200429000821288.png)\r\n\r\n![image-20200429000701637](D:\\Typora_pic\\image-20200429000701637.png)","timestamp":1590329650947},{"name":"165-restful API介绍.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/165-restful API介绍.md","content":"![image-20200427214604893](D:\\Typora_pic\\image-20200427214604893.png)\r\n\r\n![image-20200427214555693](D:\\Typora_pic\\image-20200427214555693.png)\r\n\r\n![image-20200427214651772](D:\\Typora_pic\\image-20200427214651772.png)\r\n\r\n## flask -restful 插件\r\n\r\n![image-20200427214818584](D:\\Typora_pic\\image-20200427214818584.png)\r\n\r\n![image-20200427215436403](D:\\Typora_pic\\image-20200427215436403.png)\r\n\r\n![image-20200427215742890](D:\\Typora_pic\\image-20200427215742890.png)\r\n\r\n![image-20200427215818959](D:\\Typora_pic\\image-20200427215818959.png)\r\n\r\n## flask-restful插件\r\n\r\n![image-20200427215851388](D:\\Typora_pic\\image-20200427215851388.png)\r\n\r\n![image-20200427220116215](D:\\Typora_pic\\image-20200427220116215.png)\r\n\r\n![image-20200427220756576](D:\\Typora_pic\\image-20200427220756576.png)\r\n\r\n![image-20200427220959711](D:\\Typora_pic\\image-20200427220959711.png)\r\n\r\n![image-20200427221302396](D:\\Typora_pic\\image-20200427221302396.png)\r\n\r\n![image-20200427221424121](D:\\Typora_pic\\image-20200427221424121.png)\r\n\r\n![](D:\\Typora_pic\\image-20200427222241630.png)\r\n\r\n![image-20200427222234355](D:\\Typora_pic\\image-20200427222234355.png)\r\n\r\n![image-20200427222755670](D:\\Typora_pic\\image-20200427222755670.png)\r\n\r\n![image-20200427222426836](D:\\Typora_pic\\image-20200427222426836.png)\r\n\r\n![image-20200427222448956](D:\\Typora_pic\\image-20200427222448956.png)\r\n\r\n![image-20200427222558903](D:\\Typora_pic\\image-20200427222558903.png)\r\n\r\n![image-20200427222655628](D:\\Typora_pic\\image-20200427222655628.png)\r\n\r\n![image-20200427222712122](D:\\Typora_pic\\image-20200427222712122.png)\r\n\r\n![image-20200427223119251](D:\\Typora_pic\\image-20200427223119251.png)\r\n\r\n![image-20200427223350284](D:\\Typora_pic\\image-20200427223350284.png)\r\n\r\n![image-20200427223516799](D:\\Typora_pic\\image-20200427223516799.png)\r\n\r\n![image-20200427223702311](D:\\Typora_pic\\image-20200427223702311.png)\r\n\r\n## 结合蓝图\r\n\r\n![image-20200427223924625](D:\\Typora_pic\\image-20200427223924625.png)\r\n\r\n![image-20200427224055869](D:\\Typora_pic\\image-20200427224055869.png)\r\n\r\n![image-20200427224115948](D:\\Typora_pic\\image-20200427224115948.png)\r\n\r\n![image-20200427224426774](D:\\Typora_pic\\image-20200427224426774.png)\r\n\r\n![image-20200427224608459](D:\\Typora_pic\\image-20200427224608459.png)\r\n\r\n![image-20200427224625581](D:\\Typora_pic\\image-20200427224625581.png)\r\n\r\n![image-20200427224705503](D:\\Typora_pic\\image-20200427224705503.png)","timestamp":1590329650947},{"name":"166-信号机制.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/166-信号机制.md","content":"![image-20200427211813950](D:\\Typora_pic\\image-20200427211813950.png)\r\n\r\n![image-20200427211827079](D:\\Typora_pic\\image-20200427211827079.png)\r\n\r\n![image-20200427212207614](D:\\Typora_pic\\image-20200427212207614.png)\r\n\r\n![image-20200427212826421](D:\\Typora_pic\\image-20200427212826421.png)\r\n\r\n![image-20200427213009177](D:\\Typora_pic\\image-20200427213009177.png)\r\n\r\n![image-20200427213051450](D:\\Typora_pic\\image-20200427213051450.png)\r\n\r\n### flask内置的9种信号\r\n\r\n![image-20200427213249961](D:\\Typora_pic\\image-20200427213249961.png)\r\n\r\n![image-20200427213818742](D:\\Typora_pic\\image-20200427213818742.png)\r\n\r\n![image-20200427214006264](D:\\Typora_pic\\image-20200427214006264.png)","timestamp":1590329650947},{"name":"167-子域名实现.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/167-子域名实现.md","content":"![image-20200424233026786](D:\\Typora_pic\\image-20200424233026786.png)\r\n\r\n![image-20200424233154804](D:\\Typora_pic\\image-20200424233154804.png)\r\n\r\n![image-20200424233221221](D:\\Typora_pic\\image-20200424233221221.png)","timestamp":1590329650947},{"name":"168-钩子函数.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/168-钩子函数.md","content":"![image-20200427204249090](D:\\Typora_pic\\image-20200427204249090.png)\r\n\r\n![image-20200427210125971](D:\\Typora_pic\\image-20200427210125971.png)\r\n\r\n![image-20200427205834303](D:\\Typora_pic\\image-20200427205834303.png)\r\n\r\n![image-20200427210758641](D:\\Typora_pic\\image-20200427210758641.png)\r\n\r\n![image-20200427210834562](D:\\Typora_pic\\image-20200427210834562.png)\r\n\r\n![image-20200427211533493](D:\\Typora_pic\\image-20200427211533493.png)\r\n\r\n![image-20200427211613063](D:\\Typora_pic\\image-20200427211613063.png)","timestamp":1590329650947},{"name":"169-项目结构重构.md","path":"13-语言学习project/12-python3/10-框架/1-flask框架/169-项目结构重构.md","content":"![image-20200425124125634](D:\\Typora_pic\\image-20200425124125634.png)\r\n\r\n![image-20200425124131429](D:\\Typora_pic\\image-20200425124131429.png)","timestamp":1590329650947},{"name":"147-flask.md","path":"13-语言学习project/12-python3/10-框架/147-flask.md","content":"[image-20200425121829715](D:\\Typora_pic\\image-20200425121829715.png)\r\n\r\n![image-20200425121815004](D:\\Typora_pic\\image-20200425121815004.png)\r\n\r\n![image-20200425121859870](D:\\Typora_pic\\image-20200425121859870.png)","timestamp":1590329650947},{"name":"120-init方法.md","path":"13-语言学习project/12-python3/120-init方法.md","content":"# [python中的Init方法， new 方法 call 方法](https://www.cnblogs.com/shiqi17/p/9665884.html)\r\n\r\nnew 方法实现单列模式思考\r\n\r\n```python\r\nclass Single:\r\n    _single = None\r\n    _single_only = None\r\n    def __init__(self, value):\r\n        self.v = value\r\n        print(self.v)\r\n\r\n    def __new__(cls, *args, **kwargs):\r\n        if Single._single:\r\n            return Single._single\r\n        else:\r\n            Single._single = super(Single, cls).__new__(cls, *args, **kwargs)\r\n            print(\"只执行一次\")\r\n            return Single._single\r\n\r\ns2 = Single(2)\r\n#结果报错\r\n    Single._single = super(Single, cls).__new__(cls, *args, **kwargs)\r\n# TypeError: object() takes no parameters\r\n#**报错显示 基类 object() 不接受额外参数**\r\n.......\r\n    def __new__(cls, *args, **kwargs):\r\n        if Single._single:\r\n            return Single._single\r\n        else:\r\n            Single._single = super(Single, cls).__new__(cls)  #这样继承就好了\r\n            print(\"只执行一次\")\r\n            return Single._single\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"121-python学习.md","path":"13-语言学习project/12-python3/121-python学习.md","content":"```python\r\n1.切片、列表生成器    \r\nclassmates = [\'chiller\', \'tom\', \'mm\']\r\nprint(classmates[0:2])\r\nprint([x * x for x in range(1,11)])\r\n2.生成器\r\ndef fib(max):\r\n    n, a, b = 0, 0, 1\r\n    while n < max:\r\n        yield b\r\n        a, b = b , a+b\r\n        n = n+1\r\n    return \'done\'\r\n\r\nf = fib(5)\r\nprint(next(f))\r\n3.高阶函数\r\n函数名是变量\r\n4.map\\reduce\r\ndef f(x):\r\n    return x*x\r\n\r\nr = map(f, [1,2,3,4,5])\r\nprint(list(r))\r\n5.functools.partial将某些函数的参数固定住，返回一个新的函数。\r\n6.*args和**kw参数\r\n7.一个包要成为包，该目录下必须有__init__.py的文件，否则python会把这个目录当成普通目录。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。\r\n8. __slots__限制实例的属性\r\n9. 用get_name和set_name的方式给类的属性设置存取方法。\r\nclass Student(object):\r\n    def get_name(self):\r\n        return self._score\r\n    def set_name(self,value):\r\n        self.name = value\r\n\r\n s = Student()\r\n s.set_name(\'gaolong\')\r\n s.get_name()#galong \r\n10.装饰器给类定义属性\r\nclass Student(object):\r\n    @property\r\n    def score(self):\r\n        return self._score\r\n    @score.setter\r\n    def score(self, value):\r\n        if not isinstance(value, int):\r\n            raise ValueError(\'score must be integer\')\r\n        if value < 0 or value > 100:\r\n            raise ValueError(\'score must between 0~100\')\r\n        self._score = value\r\ns = Student()\r\ns.score = 90\r\nprint(s.score)\r\n11.只定义getter，不定义setter方法就是只读属性\r\n12.多继承与Minxin\r\nclass Bat(Mammal, Flyable)\r\n      pass\r\n既集成Mammal，又集成Flayble\r\nMinXin：\r\nclass Dog(Mammal, RunnableMixIn, CarnivorousMixIn):\r\n    pass\r\nPython自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。\r\n13.定制类\r\n__str__ ：打印类信息\r\n__iter__:循环\r\n__getattr__:调用不存在的属性时，避免报错\r\n__call__:直接在实例本身调用方法\r\n14.使用枚举类\r\n15.使用元类：运行时\r\ntype()：可以查看一个类型或者变量的类型，我们说class的定义就是在运行时动态创建的，而创建的class的方法就是使用type()函数。\r\nHello = type(\'Hello\', (object,), dict(hello=fn))\r\n16.操作文件和目录\r\n17.序列化\r\n可存储和可传输\r\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。\r\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\r\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\r\njson:不同语言之间传递对象必须把对象序列化成标准格式，如XML\\JSON\r\n```\r\n\r\n*python的主攻方向有网络编程、数据处理、web后台开发等，个人主攻python的爬虫方向，并且首先熟悉python语法，为python做自动化处理，为提高工作效率做准备。*\r\n\r\n```objective-c\r\n1.互联网最重要的协议是TCP/IP协议\r\n\r\n通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。\r\n\r\nIP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。\r\n\r\nIP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。\r\n\r\nIPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334。\r\n\r\nTCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。\r\n\r\n许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。\r\n\r\n一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。\r\n\r\n端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个IP包来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。\r\n\r\n一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。\r\n//tcp是建立可靠连接、并且通讯双方都可以以流的形式发送数据，相对TCP 、UDP则是面向无连接的协议。\r\n //使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。\r\n //虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议\r\n```\r\n\r\n##### 绑定数据库\r\n\r\n> 为了便于程序保存和读取数据，而且能直接通过条件快速查询到指定的数据，就出现了数据库。\r\n\r\n##### HTTP协议\r\n\r\n> ```python\r\n> 1.Request Header\r\n> GET / HTTP/1.1\r\n> GET表示一个读取请求，将从服务器获取网页数据，/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接，以加快传输速度。\r\n> Host:www.sina.com.cn\r\n>  表示请求的域名是www.sina.com.cn。\r\n> HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下:\r\n>     200 OK\r\n> ```\r\n\r\n\r\n\r\n##### 堆栈、堆、栈的区别\r\n\r\n> python中有个语法是尾递归优化，递归需要很多内存空间，存储局部变量的值，所以容易导致栈溢出。系统给每个进程分配的栈空间是2M，32位系统。\r\n>\r\n> 参考文献：[http://www.cppblog.com/oosky/archive/2006/01/21/2958.html](https://link.jianshu.com?t=http%3A%2F%2Fwww.cppblog.com%2Foosky%2Farchive%2F2006%2F01%2F21%2F2958.html)\r\n>\r\n> 一个由c/C++编译的程序占用的内存分为以下几个部分：\r\n>\r\n> 1. 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\r\n> 2. 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。\r\n> 3. 全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放\r\n> 4. 文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放\r\n> 5. 程序代码区—存放函数体的二进制代码。\r\n>\r\n> \r\n>\r\n> ```c\r\n> 2.1申请方式 \r\n> stack: \r\n> //由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 \r\n> heap: \r\n> //需要程序员自己申请，并指明大小，在c中malloc函数 \r\n> 如p1 = (char *)malloc(10); \r\n> //在C++中用new运算符 \r\n> 如p2 = (char *)malloc(10); \r\n> //但是注意p1、p2本身是在栈中的。 \r\n> ```\r\n\r\n##### utf-8编码和Unicode编码的区别\r\n\r\n> oo\r\n\r\n##### 参考文档\r\n\r\n> 1. [http://www.yiibai.com/python/python3-webbug-series1.html](https://link.jianshu.com?t=http%3A%2F%2Fwww.yiibai.com%2Fpython%2Fpython3-webbug-series1.html)\r\n> 2. [http://www.cnblogs.com/xin-xin/p/4297852.html](https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fxin-xin%2Fp%2F4297852.html)\r\n\r\n\r\n\r\n#### python每日实战练习\r\n\r\n##### 参考文献：\r\n\r\n> 1. [https://github.com/Yixiaohan/show-me-the-code](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FYixiaohan%2Fshow-me-the-code)\r\n> 2. [https://www.zhihu.com/question/29372574](https://link.jianshu.com?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F29372574)\r\n> 3. [http://www.aosabook.org/en/500L/blockcode-a-visual-programming-toolkit.html](https://link.jianshu.com?t=http%3A%2F%2Fwww.aosabook.org%2Fen%2F500L%2Fblockcode-a-visual-programming-toolkit.html)\r\n\r\n##### 000将图片或者头像加一段文字\r\n\r\n> [http://www.aosabook.org/en/500L/blockcode-a-visual-programming-toolkit.html](https://link.jianshu.com?t=http%3A%2F%2Fwww.aosabook.org%2Fen%2F500L%2Fblockcode-a-visual-programming-toolkit.html)\r\n>\r\n> \r\n>\r\n> ```python\r\n> from PIL import Image, ImageDraw, ImageFont\r\n>  \r\n> def add_num(img):\r\n>     draw = ImageDraw.Draw(img)\r\n>     myfont = ImageFont.truetype(\'C:/windows/fonts/Arial.ttf\',size=20)\r\n>     fillcolor = \"#ff0020\"\r\n>     width, heigth = img.size\r\n>     draw.text((width-40, 0), \"lizhixin\", font=myfont, fill=fillcolor)\r\n>     img.save(\'result.jpg\',\'jpeg\')\r\n>  \r\n>     return 0\r\n>  \r\n> if __name__ == \'__main__\':\r\n>     image = Image.open(\'image.jpg\')\r\n>     add_num(image)\r\n> ```\r\n\r\n\r\n\r\n","timestamp":1590329650947},{"name":"122-python知识.md","path":"13-语言学习project/12-python3/122-python知识.md","content":"# [Pthon强制删除非空文件夹](https://www.cnblogs.com/shiqi17/p/12163096.html)\r\n\r\n## 删除空文件夹\r\n\r\n- os：模块\r\n```python\r\nos.remove(path)  #既能删除文件，又能删除文件夹\r\nos.removedir()    #removedir只能删除文件夹\r\nos.system(\"rm -rf pathname\")   # Linux下调用bash命令\r\n```\r\n## 删除非空文件夹\r\n\r\n- shutil:模块\r\n```python\r\n  shutil.rmtree(path, ignore_errors=True)\r\n```\r\n\r\n\r\n\r\n# [Python操作Excel 之 openpyxl](https://www.cnblogs.com/shiqi17/p/10739223.html)\r\n\r\n一、基础\r\n\r\n1. 安装openpyxl 模块`pip install openpyxl `\r\n\r\n- ==font(字体类)：字号、字体颜色、下划线等==\r\n- ==fill(填充类)：颜色等==\r\n- ==border(边框类)：设置单元格边框==\r\n- ==alignment(位置类)：对齐方式==\r\n- ==number_format(格式类)：数据格式==\r\n- ==protection(保护类)：写保护==\r\n\r\n1.1\r\n\r\n```python\r\nfrom openpyxl import Workbook\r\nimport uuid,string,json,time,os,base64\r\nfrom openpyxl.workbook import Workbook\r\nfrom openpyxl.styles import Font, Alignment, Side, Border\r\nfrom Lib.Utils import Utils\r\n#============================= 创建excel文件\r\nwb = Workbook()   #创建文件对象\r\n\r\nwb.remove(wb[\"sheet\"])\r\nwb.remove(self.wb[\"sheet\"])  #移除掉第一个sheet\r\n\r\nws = wb.create_sheet(\"蒸汽压力记录表\", 0)\r\nws1 = wb.create_sheet(\"Mysheet\")           #创建一个sheet\r\n#============================= 操作单元格\r\nws1[\"A1\"]=123.11\r\nws1[\"B2\"]=\"你好\"\r\nd=ws1.cell(row=4, column=2, value=10)\r\nprint ws1[\"A1\"].value\r\nprint ws1[\"B2\"].value\r\nprint d.value\r\n\r\n\r\n\r\n#=============================对多个单元格\r\nclass ExportReport:\r\n    def __init__(self, start_time, water_temp, test_people,\r\n                 sample_name, pressure_value, pressure_list,*args, **kwargs):\r\n        \"\"\"\r\n        :param start_time: 实验开始时间\r\n        :param water_temp: 水浴温度\r\n        :param test_people: 试验人\r\n        :param sample_name: 样品名称\r\n        :param pressure_value: 最终压力\r\n        :param args: 实验过程压力记录列表\r\n        :param kwargs:\r\n        \"\"\"\r\n        self.start_time = start_time\r\n        self.water_temp = str(water_temp)+\' ℃\'\r\n        self.test_people = test_people\r\n        self.sample_name = sample_name\r\n        self.pressure_value = pressure_value\r\n        self.all_col = 5+len(pressure_list) #一共多少列\r\n        self.pressure_record = pressure_list #第六列到最后一列的数据列表\r\n\r\n        #所有的数据列\r\n        self.data_list = [self.start_time, self.water_temp,self.test_people,self.sample_name,\r\n            self.pressure_value]\r\n        self.data_list.extend(self.pressure_record)\r\n        self.col_list = [\"开始时间\", \"水浴温度\", \"测试人\", \"样品名称\", \"最终压力值\"]\r\n\r\n        # base64转化为图片\r\n        # self.bs64 = bs64\r\n        # self.img_path = Utils.change_base64_as_img(self.bs64)\r\n\r\n        self.wb = Workbook()\r\n        #self.wb.remove(self.wb[\"sheet\"])\r\n\r\n        self.ws = self.wb.create_sheet(\"{0}蒸汽压力记录表\".format(self.sample_name), 0)\r\n        #生成所含列总数的大写字母\r\n        self.upper_string_list = string.ascii_uppercase[:self.all_col]\r\n        # 水平对齐，居中对齐\r\n        self.alignment_style = Alignment(horizontal=\'center\', vertical=\'center\')\r\n        #定义border 边框样式\r\n        left, right, top, bottom = [Side(style=\'thin\', color=\'000000\')]*4\r\n        self.border_style = Border(left=left, right=right, top=top, bottom=bottom)\r\n        #定义字体\r\n        self.font_size = Font(size=9)\r\n        for col in self.upper_string_list:\r\n            self.ws.column_dimensions[col].width = 20\r\n\r\n    #创建表头第一行\r\n    def create_row1(self):\r\n        #把所有列合并\r\n        self.ws.merge_cells(start_row=1, end_row=1, start_column=1, end_column=self.all_col)\r\n        #写入值\r\n        # self.ws.cell(row=1, column=1).value = value\r\n        self.ws.cell(row=1, column=1).value = \"{0}蒸汽压力记录表\".format(self.sample_name)\r\n        self.ws[\'A1\'].alignment = self.alignment_style\r\n        self.ws[\'A1\'].font = Font(size=16, bold=True)\r\n        self.create_row2_3()\r\n        \r\n    def create_row2_3(self):\r\n        #把前五列，二三行单元格合并，并写入值\r\n        for col in range(1, len(self.col_list)+1):\r\n            self.ws.merge_cells(start_row=2, end_row=3, start_column=col, end_column=col)\r\n            col_str = self.upper_string_list[col-1]+\"2\"\r\n            self.ws[col_str] = self.col_list[col-1]\r\n            self.ws[col_str].alignment = self.alignment_style\r\n            self.ws[col_str].font = Font(size=12, bold=True)\r\n\r\n        #把第二行第六列开始到最后列合并\r\n        self.ws.merge_cells(start_row=2, end_row=2, start_column=len(self.col_list)+1, end_column=self.all_col)\r\n        col_str = self.upper_string_list[len(self.col_list)]+\"2\"\r\n        self.ws[col_str] = \"实验过程压力记录\"\r\n        self.ws[col_str].alignment = self.alignment_style\r\n        self.ws[col_str].font = Font(size=12, bold=True)\r\n\r\n        #第三行第六列开始到最后列写入值\r\n        for index, col_ltr in enumerate(self.upper_string_list[5:]):\r\n            col_str = col_ltr+\'3\'\r\n            self.ws[col_str] = \"第{0}次压力记录\".format(index+1)\r\n            self.ws[col_str].alignment = self.alignment_style\r\n            self.ws[col_str].font = Font(size=12, bold=True)\r\n\r\n    def add_data(self):\r\n        #第四行开始写入数据,所有数据居中对齐，水平居中\r\n        for index, col in enumerate(self.upper_string_list):\r\n            col_str = col+\"4\"\r\n            self.ws[col_str] = self.data_list[index]\r\n            self.ws[col_str].alignment = self.alignment_style\r\n            self.ws[col_str].font = Font(size=12, bold=True)\r\n\r\n    def create(self,value=None):\r\n        if value:\r\n            self.ws.cell(row=1, column=1).value = value\r\n        self.create_row1()\r\n        self.add_data()\r\n\r\n    def save(self, filename):\r\n        try:\r\n            self.wb.save(filename)\r\n        except:\r\n            self.wb.save(filename[:-5] + str(\'_\' + Utils.getFileName()) + filename[-5:])\r\n\r\n        # 关闭excel\r\n        self.close()\r\n\r\n    def close(self):\r\n        self.wb.close()\r\n\r\nif __name__ == \'__main__\':\r\n    er = ExportReport(1, 2, 3, 4, 5, [\'x\', \'s\', \'s\', \'b\',\'w\'])\r\n    er.create()\r\n    er.wb.save(\'17表.xlsx\')\r\n\r\n\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"123-python获取windows安装列表.md","path":"13-语言学习project/12-python3/123-python获取windows安装列表.md","content":"# 1.python获取windows软件安装列表\r\n\r\n[![img](D:\\Typora_pic\\noavatar_middle.gif)](https://blog.51cto.com/11072687)\r\n\r\n[youjiabest](https://blog.51cto.com/11072687)关注1人评论[8726人阅读](javascript:;)[2016-03-18 10:48:47](javascript:;)\r\n\r\n  windows系统会在两个地方记录软件列表：\r\n\r\n64位：HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\r\n\r\n32位：HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\r\n\r\n\r\n\r\n这两个注册表存储的软件会重复，所以我们还要去重\r\n\r\n\r\n\r\n  我们使用python的标准库_winreg来获取软件安装列表，并输出到文件中，代码如下：\r\n\r\n```python\r\n#!/usr/bin/python\r\n\r\nimport os\r\nimport socket\r\nimport _winreg\r\n\r\n#将软件安装列表输出到网盘上\r\nos.system(r\'net use p: \\\\10.0.0.6\\public password /user:Lc\\tanjun\')\r\n\r\n#使用主机名命名软件安装列表\r\nhostname = socket.gethostname()\r\nfile = open(r\'P:\\todo\\temp\\%s.txt\' % hostname, \'a\')\r\n\r\n#需要遍历的两个注册表\r\nsub_key = [r\'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\', r\'SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\']\r\n\r\nsoftware_name = []\r\n\r\nfor i in sub_key:\r\n    key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, i, 0, _winreg.KEY_ALL_ACCESS)\r\n    for j in range(0, _winreg.QueryInfoKey(key)[0]-1):\r\n        try:\r\n            key_name = _winreg.EnumKey(key, j)\r\n            key_path = i + \'\\\\\' + key_name\r\n            each_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, key_path, 0, _winreg.KEY_ALL_ACCESS)\r\n            DisplayName, REG_SZ = _winreg.QueryValueEx(each_key, \'DisplayName\')\r\n            DisplayName = DisplayName.encode(\'utf-8\')\r\n            software_name.append(DisplayName)\r\n        except WindowsError:\r\n            pass\r\n\r\n#去重排序\r\nsoftware_name = list(set(software_name))\r\nsoftware_name = sorted(software_name)\r\n\r\nfor result in software_name:\r\n    file.write(result + \'\\n\')\r\n```\r\n\r\n\r\n\r\n结果如下：\r\n\r\n```bash\r\n[root@netserver temp]# cat op-tanjun3.txt | egrep -v \"Microsoft|NVIDIA|Intel\"\r\n360安全卫士\r\n64 Bit HP CIO Components Installer\r\nAdobe AIR\r\nAdobe Flash Player 21 NPAPI\r\nAdobe Flash Player 21 PPAPI\r\nAdobe Reader XI (11.0.15) - Chinese Simplified\r\nJava 7 Update 79\r\nJava 7 Update 79 (64-bit)\r\nJava Auto Updater\r\nKeyPass\r\nPidgin\r\nPyQt GPL v4.10.2 for Python v2.7 (x64)\r\nPython 2.7.3 (64-bit)\r\nRealtek High Definition Audio Driver\r\nRemote Desktop Organizer\r\nShotgun Integration\r\nSublime Text 2.0.2\r\nSynology Assistant (remove only)\r\nTeamViewer 11\r\nVMware Workstation\r\nVMware vSphere Client 6.0\r\nWinRAR 5.30 (64-位)\r\nXshell 5\r\nbl\r\nhppLaserJetService\r\nph\r\ntools-freebsd\r\ntools-linux\r\ntools-netware\r\ntools-solaris\r\ntools-winPre2k\r\ntools-windows\r\n搜狗拼音输入法 7.9正式版\r\n腾讯QQ\r\n英特尔? 芯片组设备软件\r\n```","timestamp":1590329650947},{"name":"124-python调用Win32 API实现截图.md","path":"13-语言学习project/12-python3/124-python调用Win32 API实现截图.md","content":"# python调用Win32 API实现截图\r\n\r\n[![img](D:\\Typora_pic\\ae3ae117-d1ce-4c43-a0aa-773ec8d082f1.webp)](https://www.jianshu.com/u/f61f5e908373)\r\n\r\n[闲云逸心](https://www.jianshu.com/u/f61f5e908373)关注\r\n\r\n0.1842017.08.20 16:29:32字数 1,606阅读 6,485\r\n\r\n### 0x01 Win32 API简介\r\n\r\nWin32 API即为Microsoft 32位平台（包括：Windows 9x, Windows NT3.1/4.0/5.0, WindowsCE等）的应用程序编程接口（Application Programming Interface），是构筑所有32位Windows平台的基石，所有在Win32平台上运行的应用程序都可以调用这些函数。\r\n\r\n使用Win32 API，应用程序可以充分挖掘Windows的32位操作系统的潜力。 Mircrosoft的所有32位平台都支持统一的API，包括函数、结构、消息、宏及接口。使用 Win32 API不但可以开发出在各种平台上都能成功运行的应用程序，而且也可以充分利用每个平台特有的功能和属性。\r\n\r\n在具体编程时，程序实现方式的差异依赖于相应平台的底层功能的不同。最显著的差异是某些函数只能在更强大的平台上实现其功能。例如，安全函数只能在Windows NT操作系统下使用。另外一些主要差别就是系统限制，比如值的范围约束，或函数可管理的项目个数等等。\r\n\r\n标准Win32 API函数可以分为以下几类：\r\n\r\n- 窗口管理\r\n- 窗口通用控制\r\n- Shell特性\r\n- 图形设备接口\r\n- 系统服务\r\n- 国际特性\r\n- 网络服务\r\n\r\nwin32api可参考https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx\r\n\r\n### 0x02 Pywin32\r\n\r\n#### 1、安装Pywin32\r\n\r\n由于本次操作是使用python来操作Win32api，需要先安装Pywin32，可以从这里下载对应的Python和Windows版本文件，下载完后直接运行安装就可以了。\r\n\r\n安装文件：https://sourceforge.net/projects/pywin32/files/\r\n\r\n#### 2、截图思路\r\n\r\n截图操作的大致思路如下：\r\n\r\n- 模拟按下键盘上的“win + PrtSc”组合键\r\n- 从剪贴板读取缓存的截图\r\n- 将截图文件保存在本地\r\n\r\n#### 3、模拟按键\r\n\r\n使用的是win32api中的`keydb_event`函数，相关详细信息可以参考https://msdn.microsoft.com/en-us/library/windows/desktop/ms646304(v=vs.85).aspx\r\n\r\n键位码可以参考https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n\r\n\r\n\r\n```python\r\nwin32api.keybd_event(0x91, 0, 0, 0)     # 0x91 --> win key\r\nwin32api.keybd_event(0x2C, 0, 0, 0)     # 0x2C --> PRINT SCREEN key\r\nwin32api.keybd_event(0x91, 0, win32con.KEYEVENTF_KEYUP, 0)\r\nwin32api.keybd_event(0x2C, 0, win32con.KEYEVENTF_KEYUP, 0)\r\n```\r\n\r\n#### 4、PrtSc相关知识\r\n\r\n当按下“win + PrtSc”组合键后，截图被保存在剪贴板中，可以直接在word或者是附件中的画图程序里粘贴后使用，使用剪贴板查看器可以查看剪贴板的内容。\r\n\r\n剪贴板在Windows 7/8/10 中是没有的，可以在网上搜索下载一个，一般为clipbrd.exe。\r\n\r\n![img](D:\\Typora_pic\\6403991-8104d38da972e2e2.webp)\r\n\r\nclipbrd.png\r\n\r\n自己操作下就会发现，剪贴板只能存储最近复制的内容，新内容会替换旧内容（不区分图片或文字），QQ截图使用的也是系统剪贴板。\r\n\r\n从剪贴板查看器的查看选项可以看到，这里有两种图片格式：位图和DIB位图。\r\n\r\n![img](D:\\Typora_pic\\6403991-5dbfb4bdea754188.webp)\r\n\r\nclipbrd_screen.png\r\n\r\n#### 5、从剪贴板中读取截图\r\n\r\nwin32api中有一个模块`win32clipboard`是负责剪贴板相关的操作。相关详细信息可以参考https://msdn.microsoft.com/zh-cn/library/windows/desktop/ff468802(v=vs.85).aspx\r\n\r\n`win32clipboard.IsClipboardFormatAvailable(formats)`确定剪贴板是否包含指定格式的数据。\r\n\r\n`win32clipboard.GetClipboardData(formats)`可以从剪贴板里读取数据。\r\n\r\n需要指定数据的格式`formats`，有关标准剪贴板格式的说明，请参阅标准剪贴板格式https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms649013(v=vs.85).aspx#_win32_Standard_Clipboard_Formats\r\n\r\n此处选用`CF_DIB`，`CF_DIB`返回一个内存对象，包含BIT格式图片的信息。相关详细信息可以参考https://msdn.microsoft.com/zh-cn/library/windows/desktop/ff729168(v=vs.85).aspx\r\n\r\n\r\n\r\n```python\r\nwin32clipboard.OpenClipboard()\r\nif win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_DIB):\r\n    data = win32clipboard.GetClipboardData(win32clipboard.CF_DIB)\r\n```\r\n\r\n#### 6、BMP简介\r\n\r\nBMP（全称Bitmap）是Windows操作系统中的标准图像文件格式，它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准，因此在Windows环境中运行的图形图像软件都支持BMP图像格式。\r\n\r\n典型的BMP图像文件由四部分组成：\r\n\r\n- 位图头文件数据结构，它包含BMP图像文件的类型、显示内容等信息；\r\n- 位图信息数据结构，它包含有BMP图像的宽、高、压缩方法，以及定义颜色等信息；\r\n- 调色板，这个部分是可选的，有些位图需要调色板，有些位图，比如真彩色图（24位的BMP）就不需要调色板；\r\n- 位图数据，这部分的内容根据BMP位图使用的位数不同而不同，在24位图中直接使用RGB，而其他的小于24位的使用调色板中颜色索引值。\r\n\r\n详细内容可查看https://baike.baidu.com/item/BMP/35116?fr=aladdin\r\n\r\n#### 7、构建结构体\r\n\r\n##### BMP文件头结构体\r\n\r\n详细内容可参考https://msdn.microsoft.com/en-us/library/windows/desktop/dd183374(v=vs.85).aspx\r\n\r\n\r\n\r\n```python\r\nclass BITMAPFILEHEADER(Structure):\r\n    _pack_   = 1\r\n    _fields_ = [\r\n        (\'bfType\', WORD),\r\n        (\'bfSize\', DWORD),\r\n        (\'bfReserved1\', WORD),\r\n        (\'bfReserved2\', WORD),\r\n        (\'bfOffBits\', DWORD),\r\n        ]\r\n```\r\n\r\n##### 位图信息头结构体\r\n\r\n详细内容可参考https://msdn.microsoft.com/en-us/library/windows/desktop/dd183376(v=vs.85).aspx\r\n\r\n\r\n\r\n```python\r\nclass BITMAPINFOHEADER(Structure):\r\n    _pack_   = 1\r\n    _fields_ = [\r\n        (\'biSize\', DWORD),\r\n        (\'biWidth\', LONG),\r\n        (\'biHeight\', LONG),\r\n        (\'biPLanes\', WORD),\r\n        (\'biBitCount\', WORD),\r\n        (\'biCompression\', DWORD),\r\n        (\'biSizeImage\', DWORD),\r\n        (\'biXpelsPerMeter\', LONG),\r\n        (\'biYpelsPerMeter\', LONG),\r\n        (\'biClrUsed\', DWORD),\r\n        (\'biClrImportant\', DWORD),\r\n        ]\r\n```\r\n\r\n用sizeof获取二者的大小并赋值给`SIZEOF_BITMAPFILEHEADER`和`SIZEOF_BITMAPINFOHEADER`。\r\n\r\n#### 8、拷贝截图数据\r\n\r\n从内存中拷贝出BMP数据用到的是ctypes中的`memmove`函数。详细内容可查看https://docs.python.org/2/library/ctypes.html?highlight=memmove#ctypes.memmove\r\n\r\n同时，新建一块区域，全部用0来填充，用到的是ctypes中的`memset`函数。详细内容可查看https://docs.python.org/2/library/ctypes.html?highlight=memmove#ctypes.memset\r\n\r\n\r\n\r\n```python\r\nBitMapInfoHeaderHandle = BITMAPINFOHEADER()\r\nmemmove(pointer(BitMapInfoHeaderHandle), data, SIZEOF_BITMAPINFOHEADER)\r\n        \r\nBitMapFileHeaderHandle = BITMAPFILEHEADER()\r\nmemset(pointer(BitMapFileHeaderHandle), 0, SIZEOF_BITMAPFILEHEADER)\r\n```\r\n\r\n#### 9、写文件头\r\n\r\n构建文件头的详细内容可参考https://baike.baidu.com/item/BMP/35116?fr=aladdin\r\n\r\n\r\n\r\n```python\r\nBitMapFileHeaderHandle.bfType = ord(\'B\') | (ord(\'M\') << 8)\r\nBitMapFileHeaderHandle.bfSize = SIZEOF_BITMAPFILEHEADER + len(data)\r\nSIZEOF_COLORTABLE = 0\r\nBitMapFileHeaderHandle.bfOffBits = SIZEOF_BITMAPFILEHEADER + SIZEOF_BITMAPINFOHEADER + SIZEOF_COLORTABLE\r\n```\r\n\r\n#### 10、生成图片\r\n\r\n以二进制方式，先写文件头，再写从剪贴板获取到的字符串到本地的.bmp文件中，完成图片生成。\r\n\r\n\r\n\r\n```python\r\nwith open(filename, \'wb\') as bmp_file:\r\n    bmp_file.write(BitMapFileHeaderHandle)\r\n    bmp_file.write(data)\r\nprint \'file \"{}\" created from clipboard image\'.format(filename)\r\n```\r\n\r\n### 0x03 完整代码\r\n\r\n[PrintScreen.py](https://github.com/lyxw/codes/blob/master/tools/PrintScreen.py)\r\n\r\n\r\n\r\n5人点赞\r\n\r\n\r\n\r\n[随笔](https://www.jianshu.com/nb/15633668)","timestamp":1590329650947},{"name":"125-python高级编程.md","path":"13-语言学习project/12-python3/125-python高级编程.md","content":"```python\r\nPython高级教程\r\n原创丶大皮球 最后发布于2017-11-02 20:15:29 阅读数 7166  收藏\r\n展开\r\n关键字is 和 == 的区别\r\na = \'hello world\'\r\nb = \'hello world\'\r\na == b  #返回True \r\na is b  #返回False \r\n注意：is 判断是否是一个ID， == 判断内容是否一致。\r\n\r\n深拷贝和浅拷贝\r\nimport copy\r\na = [1,2,3,4,5]\r\nb = a   #浅拷贝，a,b同时指向一个id,当其中一个修改时，另外一个也会被修改。\r\nc = copy.deepcopy(a) #深拷贝，c单独开辟一个id,用来存储和a一样的内容。\r\nd =a[:] #这样也是深拷贝。\r\ne = copy.copy(a) #当拷贝内容是可变类型时，那么就会进行深拷贝，如果是不可变类型时，那么就会进行浅拷贝。\r\n注意：深拷贝指的是复制内容，单独开辟一个内存，浅拷贝指的是两个变量同时指向一个内存ID。\r\n私有化和Property\r\nclass Test(object):\r\n\tdef __init__(self):\r\n\t\tself.__num = 100\r\n\t@getNum.setter #等同步于 porperty(setNum,getNum)\r\n\tdef setNum(self,num): #将self.__num的属性封装。\r\n\t\tself.__num = num\r\n\t@porperty #等于getNum = porperty(getNum) 默认的是getter方法。\r\n\tdef getNum(self) #获取__num的值。\r\n\t\treturn self.__num\r\n\tnum = porperty(getNum,setNum) #使用关键字porperty将getNum和setNum方法打包使用，并将引用赋予属性num。\r\nt = Test()\r\nprint(t.__num) #将会出错，表示输出私有属性，外部无法使用。\r\nt.__num = 200  #这里将会理解为添加属性 __num = 200,而不是重新赋值私有属性。\r\nprint(t.__num) #这里输出的200是定义的属性__num，而不是self.__num。 \r\nt.setNum(200) #通过set方法将私有属性重新赋值。\r\nt.getNum() #通过get方法获取__num的值。\r\nprint(_Test__num) #私有属性其实是系统再私有属性前加上了一个_Test，就是一个下划线加类名。\r\n\r\nt.num = 300 #调用类属性num,并重新赋值，porperty会自动检测set方法和get方法，并将引用赋值给set方法。\r\nprint(t.num) #输出类属性，并会自己检测使用get方法进行输出。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n注意： num 前后没有下划线的是公有方法，_num 前边有一个下划线的为私有方法或属性，子类无法继承， 前边有两个下划线的 一般是为了避免于子类属性或者方法名冲突，无法在外部直接访问。前后都有双下划线的为系统方法或属性。后边单个下划线的可以避免与系统关键词冲突。\r\n\r\n列表生成式\r\nrange(1,100,5) #第一个参数表示开始位，第二个参数表示结束位（不含），第三个参数表示步长，就是每5个数返回一次。\r\na = [i for i in range(1,10)] #列表生成式表示返回i的值，并且返回9次，每次返回的是i的值。\r\na = [2 for i in range(1,10)] #这里表示返回2，并且返回9次，但是每次的值都是2。\r\na = [i for i in range10 if i%2==0] #表示在生成式内部加入if判断，当i除以2的余数等于0的时候将数值返回。\r\na = [(i,j) for i in range(5) for j in range(5)] #表示将i和j的值以元组为元素的形式返回，当i循环一次的时候j循环5次，以此类推。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n生成器\r\na = (i for i in range(1,10)) #将列表生成试外部的中括号改为小括号，就能将生成式转化为生成器。\r\nnext(a),a.__next__() #生成器的取值方式只能使用next的方法。\r\ndef num():\r\n\ta,b = 0,1\r\n\tfor i in range(10):\r\n\t\tyield b  #生成关键字yield，有yield的关键字的代码块就是yield的生成器。当运行到yield时代码就会停止，并返回运行结果，当在次运行时依旧是到yield停止，并返回结果。 切记：生成器只能使用next方法。\r\n\t\ta,b = b,a+b\r\n\t\ttemp = yield b  #这里并不是变量的定义，当运行到yield时就会停止，所以当运行到等号右边的时候就会停止运行，当在次使用next的时候，将会把一个None赋值给temp，因为b的值已经在上轮循环中输出。这里可以使用num().send()方法将一个新的值赋值给temp。\r\na = num()  #将生成器赋值给变量a。\r\nfor n in a:  #生成器可以使用for循环使用，并且不会出错。\r\n\tprint(n) \r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n注意：生成器占用内存小，在使用的时候取值，降低CPU和内存空间，提高效率。并且一般都使用for循环进行取值。\r\n\r\n迭代器\r\nfor i in \'\',[],(),{},{:}\r\n#可以for循环的对象是可迭代对象。\r\na = (x for i in range(100))\r\n#列表生成式，把中括号改为小括号就可以变为一个列表生成器，是可迭代对象。\r\nfrom collections import Iterable #如果想验证是否是可迭代对象，可以使用isinstance()判断是否是可迭代对象。\r\nisinstance(\'abc\',Ierable) #判断语法\r\na = [1,2,3,4,5]\r\nb = iter(a)  #使用iter()方法可以将可迭代对象转换为可迭代对象。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n注意：生成器是可迭代对象，迭代器不一定是生成器。并且迭代器无法回取，只能向前取值。\r\n注意：一个对象具有 iter 方法的才能称为可迭代对象，使用yield生成的迭代器函数，也有iter方法。凡是没有iter方法的对象不是可迭代对象，凡是没有__next__()方法的不是是生成器。（这里的方法都是魔法方法，是内置方法，可以使用dir（）查看）\r\n\r\n闭包\r\ndef num(num): #定义函数\r\n\tdef num_in(nim_in): #定义函数\r\n\t\treturn num + num_in #返回两个参数的和。\r\n\treturn num_in #返回内部函数的引用。（变量名）\r\n\r\na = num(100) #将参数为100的函数num接收，并赋值给a，只不过这个返回值是一个函数的引用。等于 a = num_in，注意这里接收的不光是函数本身，还有已经传递的参数。\r\nb = a(100) #调用函数a,即num_in，并传递一个参数100，返回值给b。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n注意：当一个函数定义在另一个函数内，且使用到了外部函数的参数。整个代码块称为闭包。当外部参数确定时，内部函数参数可以反复调用。\r\n\r\n装饰器\r\n装饰没有参数的函数\r\n\r\ndef function(func): #定义了一个闭包\r\n\tdef func_in(): #闭包内的函数\r\n\t\tprint(\'这里是需要装饰的内容，就是需要添加的内容\')\r\n\t\tfunc() #调用实参函数。\r\n\treturn func_in\r\n\t\r\ndef test(): \t#需要被装饰修改的函数。\r\n\tprint(\'无参函数的测试\')\r\n\t\r\ntest = function(test) \t#装饰器的原理就是将原有的函数名重新定义为以原函数为参数的闭包。\r\ntest() 这里再次掉用test()的时候，其实是将会调用闭包内的函数func_in()。所以将会起到装饰修改的作用，最后会再次调用原函数test()。\r\n\r\n@function \t#装饰器的python写法，等价于test = function(test)，并且无需调用当代码运行道这里，Python会自动运行。\r\ndef test():\r\n\tprint(\'无参函数的测试\')\r\ntest() \t#这里再次调用函数时，将会产生修改后的效果。\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n装饰带有参数的函数\r\n\r\ndef function(func): #定义了一个闭包\r\n\tdef func_in(*args,**kwargs): \t#闭包内的函数，因为装饰器运行的实则是闭包内的函数，所以这里将需要有形参用来接收原函数的参数。\r\n\t\tprint(\'这里是需要装饰的内容，就是需要添加的内容\')\r\n\t\tfunc(*args,**kwargs) \t#调用实参函数，并传入一致的实参。\r\n\treturn func_in\r\n\t\r\n@function\t #装饰器的python写法，等价于test = function(test) .\r\ndef test():\r\n\tprint(\'无参函数的测试\')\r\n\t\r\ntest(5，6) \t#这里再次掉用test()的时候，其实是将会调用闭包内的函数func_in()。所以将会起到装饰修改的作用，最后会再次调用原函数test()。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n装饰带有返回值的函数\r\n\r\ndef function(func): #定义了一个闭包\r\n\tdef func_in(*args,**kwargs): #闭包内的函数，因为装饰器运行的实则是闭包内的函数，所以这里将需要有形参用来接收原函数的参数。\r\n\t\tprint(\'这里是需要装饰的内容，就是需要添加的内容\')\r\n\t\tnum = func(*args,**kwargs) #调用实参函数，并传入一致的实参，并且用变量来接收原函数的返回值，\r\n\t\treturn num #将接受到的返回值再次返回到新的test()函数中。\r\n\treturn func_in\r\n@function\r\ndef test(a,b): #定义一个函数\r\n\treturn a+b #返回实参的和\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n通用装饰器\r\n\r\ndef function(func): #定义了一个闭包\r\n\tdef func_in(*args,**kwargs): \t#闭包内的函数，因为装饰器运行的实则是闭包内的函数，所以这里将需要有形参用来接收原函数的参数。\r\n\t\tprint(\'这里是需要装饰的内容，就是需要添加的内容\')\r\n\t\tnum = func(*args,**kwargs) \t#调用实参函数，并传入一致的实参，并且用变量来接收原函数的返回值，\r\n\t\treturn num \t#将接受到的返回值再次返回到新的test()函数中。\r\n\treturn func_in\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n带有参数的装饰器\r\n\r\ndef func(*args,**kwags):\r\n\tdef function(func): #定义了一个闭包\r\n\t\tdef func_in(*args,**kwargs): #闭包内的函数，因为装饰器运行的实则是闭包内的函数，所以这里将需要有形参用来接收原函数的参数。\r\n\t\t\tprint(\'这里是需要装饰的内容，就是需要添加的内容\')\r\n\t\t\tnum = func(*args,**kwargs) #调用实参函数，并传入一致的实参，并且用变量来接收原函数的返回值，\r\n\t\t\treturn num #将接受到的返回值再次返回到新的test()函数中。\r\n\t\treturn func_in\r\n\treturn function\r\n\r\n@func(50)  #这里会先运行函数func，并切传入参数，之后会再次运行闭包函数进行装饰, @func(50)>>@function，然后将由@function继续进行装饰修改。\r\ndef test(a,b):\r\n\tprint(\'这是一个函数\')\r\n\treturn a+b\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n类装饰器\r\n\r\nclass Test(object): #定义一个类\r\n\tdef __init__(self，func):\r\n\t\tself.__func = func\r\n\tdef __call__(self):  #定义call方法，当直接调用类的时候，运行这里。\r\n\t\tprint(\'这里是装饰的功能\')\r\n\t\tself.__func()\t\r\nt = Test() #实例化对象\r\nt() #调用类，将会调用call方法。\r\n\r\n@Test  #类装饰器等于test = Test(test),将函数test当作参数传入类中的init方法，并将函数名赋值给私有属性__func，当函数test被调用的时候，其实是运行Test类中的call方法.\r\ndef test():\r\n\tprint(\'被装饰的函数\')\r\ntest() #这里调用的不在是函数test，而是实例对象test的call方法，会先进行装饰，然后再调用私有属性__func(),__func 其实就是被装饰的函数test。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n动态语言添加属性和方法\r\nclass Person(): #创建一个类\r\n\tdef __init__(self,name): #定义初始化信息。\r\n\t\tself.name = name \r\nli = Person(\'李\')  #实例化Person(\'李\'),给变量li\r\nli.age = 20  #再程序没有停止下，将实例属性age传入。动态语言的特点。\r\nPerson.age = None  #这里使用类名来创建一个属性age给类，默认值是None。Python支持的动态属性添加。\r\ndef eat(self): #定义一个方法，不过这个方法再类之外。\r\n\tprint(\'%s正在吃东西。。\'%self.name) \r\nimport types  #动态添加方法需要使用tpyes模块。\r\nli.eat = types.MethodType(eat,li) #使用types.MethodType，将函数名和实例对象传入，进行方法绑定。并且将结果返回给li.eat变量。实则是使用一个和li.eat方法一样的变量名用来调用。\r\nli.eat() #调用外部方法eat()方法。\r\n\r\n@staticmethod  #定义静态方法。\r\ndef test():  #定义静态方法，静态方法可以不用self参数。\r\n\tprint(\'这是一个静态方法。\')\r\nPerson.test = test  #使用类名.方法名 = test的形式来方便记忆和使用，Person.test其实只是一个变量名，没有特殊的含义。\r\nPerson.test()  #调用test方法。\r\n\r\n@classmethod  #类方法\r\ndef test(cls): \r\n\tprint(\'这是一个类方法。\')\r\nPerson.test = test #定义一个类属性等于方法名。\r\nPerson.test() #调用方法。\r\n\r\nclass test(object): #定义一个类。\r\n\t__slots__ = (\'name\',\'age\') #使用slots来将属性固定，不能进行动态添加修改。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n元类\r\n创建带有类属性的类\r\n\r\nTest = type(\'Test\',(object,),{\'num\':0}  #元类是只使用type创建的类，使用type会有3个参数，第一个是类名，第二个小括号内是父类名，需要使用元组。第三个字典中是类属性，使用type能够快速的动态创建一个类。\r\nclass Test(object):  #创建一个类，等价于上边\r\n\tnum = 0\r\n1\r\n2\r\n3\r\n创建带有方法的类\r\n\r\ndef eat(self):  #定义一个函数，self作为第一个参数。\r\n\tprint (\'%s正在吃饭。。\'%self.name)\r\nPerson = type(\'Person\',(object,), {\'eat\':eat,\'name\':None}  #使用type创建一个类，但是有两个属性，一个是eat,一个是name,但是eat的值是函数eat的引用。\r\np = Person()  #实例化\r\np.name = \'Tom\'  #类属性赋值\r\np.eat()  #调用eat()方法。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n内建属性\r\n__init__ #构造初始化函数,__new__之后运行\r\n__new__ #创建实例所需的属性\r\n__class__ #实例所在的类，实例.__class__\r\n__str__ #实例的字符串表示，可读性高\r\n__repr__ #实例的字符串表示，准确性高\r\n__del__ #删除实例引用\r\n__dict__ #实力自定义属性，vars(实例.__dict__)\r\n__doc__ #类文档，help(类或者实例)\r\n__bases__ #当前类的所有父类\r\n__getattribute__ #属性访问拦截器。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n内建方法\r\nrange(start,stop,[,step]) #生成器\r\nmap(function, iterable, ...) # map() 会根据提供的函数对指定序列做映射。\r\nfilter(function, iterable) #filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。\r\nreduce(function, iterable[, initializer]) #reduce() 函数会对参数序列中元素进行累积。\r\nsorted(iterable[, cmp[, key[, reverse]]]) #sorted() 函数对所有可迭代的对象进行排序操作。sort 与 sorted 区别：\r\nsort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。\r\nlist 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\nPDB调试\r\n1.python -m pdb xxx.py  #在命令行输入以上命令，进入pdb调试模式。XXX.py表示需要打开的文件。\r\n2.import pdb\r\npdb.run(\'func(*args)\') #第二种方式，当程序在运行中调试。\r\n3.pdb.set_trace() #第三种方法，当程序运行到这行代码时，就会自动运行。\r\nl(list) # 显示全部代码\r\nn(next) # 向下执行一行代码\r\nc(contiune) # 执行余下的代码\r\nb(break) 10 # 设置断点，b 10表示将断点设置到第10行。clear 1,删除第一个断点\r\np(print) a,b #打印变量的值\r\na(args) #打印全部的形参数据\r\ns(step) #进入到一个函数\r\nr(return) #快速执行到函数的最后一行\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n进程和线程\r\n进程\r\n\r\nimport\tos\r\npid = os.fork() #这里将会创建一个子进程，返回值会是子进程PID值。\r\nprint(\'父子进程都会输出。\') #这里没有判断语句，将会运行两次，一次是父进程，一次是子进程。\r\nif pid > 0: #判断，父进程的返回值会大于0。\r\n\tprint(\'子进程的PID是%d,父进程的PID是%d\'%(os.getpid(),os.getppid())) #getpid的获取当前进程的pid,如果子进程getpid的时候，会得到子进程的值，再子进程使用getppid的时候能够获取到父进程的pid。\r\nelse: #子进程的返回值则会永远是0\r\n\tprint(\'父进程的PID是%d\'%os.getpid()) #当父进程使用getpid的时候获得的是父进程的pid。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n**注意：**进程值PID是不能重复的，类似于端口。系统会为每个进程会分配不同的PID进行区分不同的软件进程。并且父子进程会独立运行，互不干扰。而且父子进程的调用需要系统来调度，没有固定性。\r\n\r\nimport os\r\npid = os.fork() #创建子进程，接收pid的返回值。\r\nif pid > 0: #判断是子进程还是父进程。\r\n\tprint(\'父进程\') #当pid的返回值是0的时候，会运行父进程\r\nelse:\r\n\tprint(\'子进程\') #否则就是子进程\r\npid =os.fork() #让之前的父子进程再次创建各自的子进程\r\nif pid > 0: #判断父子进程\r\n\tprint(\'父进程的子进程\') #这里会运行2次父进程\r\nelse:\r\n\tprint(\'子进程的子进程\') #这里也会运行两次子进程\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\nwindons中的fork()-Process\r\n\r\nfrom multiprocessing import Process #导入模块类，这是一个类\r\nimport time\r\ndef test(): #定义一个函数\r\n    while True:\r\n        print(\'-1-\')\r\n        time.sleep(1)\r\np = Process(target=test) #创建一个实例，就是一个新进程，并且执行的代码就是test()函数\r\np.start() #调用start方法让子进程开始运行。\r\np.join(10) #join表示延时时间，也就是等待子进程的时间，当10秒过了以后，则会运行主进程。\r\nwhile True: #这里是主进程。\r\n    print(\'-2-\')\r\n    time.sleep(1)\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n注意：Process需要自己创建进程，以及调用开始进程，fork则是全自动运行。后期最好以Process为主，可实现跨平台运行。还有最主要的一点是Process的主进程会等待子进程。\r\n\r\nProcess实例\r\n\r\nfrom multiprocessing import Process\r\nimport time\r\n\r\nclass Process_class(Process): #创建一个Process的子类。\r\n    def run(self): #重写run方法，当调用start方法时，则会默认调用run方法，所以不用再填写target参数。\r\n        while True:\r\n            print(\'--1--\')\r\n            time.sleep(1)\r\np = Process_class() #实例化一个子进程。\r\np.start() #运行子进程\r\np.join(5) #这里将会等待子进程单独运行5秒。\r\nwhile True: #主进程，当join等待结束收，则会父子进程一起运行。但是如果当父进程运行完，子进程还没有结束，那么父进程会继续等子进程。\r\n    print(\'--main--\')\r\n    time.sleep(1) \r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n进程池Pool\r\n\r\nfrom multiprocessing import Pool #导入Pool模块类\r\nimport os,time\r\ndef work(num): #创建一个进程的工作函数。\r\n    for i in range(2): #表示每次工作需要执行2次。\r\n        print(\'进程的pid是%d,进程值是%d\'%(os.getpid(),num)) #输出两次\r\n        time.sleep(1)\r\n\r\np = Pool(2) #实例化对象，参数2表示创建2个子进程，就是说每次只能执行2个进程。\r\n\r\nfor i in range(6): \r\n    print(\'--%d--\'%i)\r\n    p.apply_async(work,(i,)) #向实例对象添加6次任务，就是6个进程，但是实例对象的进程池只有2个，需要每次执行2个进程，当2个进程执行完以后则会再次执行下面2个。\r\n\r\np.close() #关闭进程池，不再接收进程任务。\r\np.join() #当子进程工作结束后，则会运行主进程。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\nQueue队列\r\n\r\nProcess的Queue用法\r\n\r\nfrom multiprocessing import Process,Queue  #导入Process和Queue\r\nimport os,time,random\r\n\r\ndef write(q):  #定义函数,接收Queue的实例参数\r\n    for v in range(10):\r\n        print(\'Put %s to Queue\'%v)\r\n        q.put(v)  #添加数据到Queue\r\n        time.sleep(1)\r\ndef read(q): #定义函数，接收Queue的实例参数\r\n    while True:\r\n        if not q.empty(): #判断，如果Queue不为空则进行数据取出。\r\n            v = q.get(True) #取出Queue中的数据，并返回保存。\r\n            print(\'Get %s from Queue\'%v)\r\n            time.sleep(1)\r\n        else: #如果Queue内没有数据则退出。\r\n            break\r\n\r\nif __name__ == \'__main__\':\r\n    q = Queue() #实例化Queue括号内可选填，输入数字表示有多少个存储单位。以堵塞方式运行。必须等里边有空余位置时，才能放入数据，或者只能等里边有数据时才能取出数据，取不出数据，或者存不进数据的时候则会一直在等待状态。\r\n    pw = Process(target=write,args=(q,)) #实例化子进程pw,用来执行write函数，注意这里的函数不带括号，只是传递引用，参数需要使用args参数以元组的方式进行接收。\r\n    pr = Process(target=read,args=(q,)) #实例化子进程pr,用来执行read函数，注意这里的函数不带括号，只是传递引用，参数需要使用args参数以元组的方式进行接收。\r\n    pw.start() #开始执行pw。\r\n    pr.start() #开始执行pr。\r\n    pw.join() #等待pw结束\r\n    pr.join() #等待pr结束\r\n    print(\'Over\')  #主进程结束\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\nPool的Queue用法\r\n\r\nfrom multiprocessing import Manager,Pool #这里注意导入的是Manager和Pool\r\nimport os,time,random\r\n\r\ndef write(q):\r\n    for v in range(10):\r\n        print(\'Put %s to Queue\'%v)\r\n        q.put(v)\r\n        time.sleep(1)\r\ndef read(q):\r\n    while True:\r\n        if not q.empty():\r\n            v = q.get(True)\r\n            print(\'Get %s from Queue\'%v)\r\n            time.sleep(1)\r\n        else:\r\n            break\r\n\r\nif __name__ == \'__main__\':\r\n    q = Manager().Queue() #这里实例化的时候是使用Manager的Queue\r\n    p = Pool()\r\n    p.apply_async(write,(q,)) #将任务加入Pool的进程池，注意这里的参数于Process不同。\r\n    p.apply_async(read,(q,)) #将任务加入Pool的进程池，注意这里的参数于Process不同。\r\n    p.close() #关闭进程池，不再接收进程。\r\n    p.join() #子进程完毕，运行以下的主进程。\r\n    print(\'Over\')\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n线程\r\n\r\nfrom threading import Thread #导入Thread线程类。\r\nimport time\r\n\r\nnum = 0 #定义全局变量\r\n\r\ndef work(): #定义函数内容\r\n    global num \r\n    for i in range(1000000):\r\n        num += 1\r\n    print(\'work的num是%d\'%num)\r\n\r\ndef works(): #定义函数\r\n    global num\r\n    for i in range(1000000):\r\n        num += 1\r\n    print(\'works的num是%d\'%num)\r\n\r\nt = Thread(target=work) #创建第一个线程内置的self.name属性为Thread-1,并指向work\r\ntt = Thread(target=works) #创建第二个线程内置的self.name属性为Thread-2,并指向works\r\nt.start() #开始执行\r\ntt.start() #开始执行\r\ntime.sleep(1) #主线程休息一秒\r\nprint(\'最后的num值是%d\'%num) #输出最后的结果。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n注意：线程中的变量数据是可以共享的，进程与线程的区别在于，父子进程是两个单独的个体，子进程类似于直接拷贝的一份父进程的代码独立运行，相当于两个文件。线程则是再主进程的内部分裂运行。举例子来说一个工厂需要做100万件衣服，但是工期太紧，自己做太慢，老板现在有两个选择，一个是雇佣另外一个同样规模的工厂一起来做，两个工厂一起做——进程，另外一个选择就是在自己的工厂内大批量的招募工人用来赶工——线程。总得来说线程的消耗成本会比进程低很多。\r\n\r\n互斥锁\r\n\r\nfrom threading import Thread,Lock #导入互斥锁Lock\r\n\r\nnum = 0\r\n\r\ndef work():\r\n    global num\r\n    l.acquire() #这里表示调用互斥锁上锁方法，如果work函数先运行l.acquire的话，那么后边的程序就不能再修改和使用变量num。直到将其解锁后才能使用。\r\n    for i in range(1000000):\r\n        num += 1\r\n    print(\'work的num是%d\'%num)\r\n    l.release() #这里表示调用互斥锁解锁方法。\r\n\r\ndef works():\r\n    global num\r\n    l.acquire() #这里表示调用互斥锁上锁方法。\r\n    for i in range(1000000):\r\n        num += 1\r\n    print(\'works的num是%d\'%num)\r\n    l.release() #这里表示调用互斥锁解锁方法。\r\n\r\n\r\nl = Lock() #实例化互斥锁，互斥锁是为了保护子线程不争抢数据而使用的一个类。\r\nt = Thread(target=work)\r\ntt = Thread(target=works)\r\nt.start()\r\ntt.start()\r\nprint(\'最后的num值是%d\'%num) #输出最后的结果，如果实验过的可能会发现这个结果并不是2000000，为什么呢？\r\n这里需要明白，主线程和子线程是同时进行的，因为创建子进程在前，最后输出再后，所以当最后线程输出的时候，子线程还在运行，也就是说当子线程的加法运算加到95222的时候你的\r\n主进程刚好运行到最后的输出语句，所以就把95222拿过来进行输出。你也可以试试将最后的输出语句放到实例化的前边，看看结果是不是0，因为子线程还没有开始工作，所以并没有进行加法运算。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n注意：因为线程的数据是共享数据，不用Queue就能实现，所以也会存在一些弊端，因为线程是在进程间独立运行的，所以共享数据会有一定的延时性和不准确性，举例家里有10个馒头，2个孩子，第一个孩子拿走一个会记得还剩下9个，第二个孩子去拿的时候会记得还剩下8个，但是当第一个孩子再去拿的时候会发现只剩下7个了，但是之前明明还剩下9个，这样就会出现问题。互斥锁的作用就是再厨房装上一把锁，当第一个孩子饿的时候就进去吃馒头，将门反锁，这样第二个孩子就吃不到再门口等着，当第一个吃饱的时候第二个再进去，也把门锁上。这样一个一个的来避免冲突。\r\n\r\n同步、异步\r\n\r\nimport threading\r\nimport time\r\n\r\nclass MyThread(threading.Thread):\r\n    def run(self):\r\n        global num \r\n        time.sleep(1)\r\n\r\n        if mutex.acquire(1):  \r\n            num = num+1\r\n            msg = self.name+\' set num to \'+str(num)\r\n            print msg\r\n            mutex.release()\r\nnum = 0\r\nmutex = threading.Lock()\r\ndef test():\r\n    for i in range(5):\r\n        t = MyThread()\r\n        t.start()\r\nif __name__ == \'__main__\':\r\n    test()\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n结果\r\n\r\nThread-3 set num to 1\r\nThread-4 set num to 2\r\nThread-5 set num to 3\r\nThread-2 set num to 4\r\nThread-1 set num to 5\r\n1\r\n2\r\n3\r\n4\r\n5\r\n注意：这里就是一个简单的同步，使用互斥锁来实现，因为每个线程在创建运行的时候都是各自做各自的，如果没有互斥锁来约束步调，那么结果是1,2,3,4,5的概率是未知数，但是加上了互斥锁以后，就会对线程的运行顺序进行排队，达到预期的结果。而异步则是各个线程独立运行，谁先做完就休息，不用等待。\r\n\r\nthreadlocal\r\n\r\nimport threading  #导入模块\r\n\r\nl = threading.local() #实例化local，注意这个local和Lock互斥锁的名称不同。\r\n\r\ndef work(name): #创建函数\r\n    l.name = name #将参数name传递给local实例对象的name属性。注意：这里的l.name是创建的对象属性。\r\n    works() #调用work函数\r\n\r\ndef works(): #创建函数\r\n    name = l.name\r\n    print(\'hello,%s,线程的name是%s\'%(name,threading.current_thread().name))\r\n\r\nt1 = threading.Thread(target=work,args=(\'小李\',)) #实例化线程对象，并调用work,参数name是小李。\r\nt2 = threading.Thread(target=work,args=(\'小王\',))#实例化线程对象，并调用work,参数name是小王。\r\nt1.start()\r\nt2.start()\r\nt1.join()\r\nt2.join()\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n注意：threadlocal是比较方便的共享数据处理办法，他的内部类似于一个字典，Thread.name作为Key，对应的属性作为Value，当Thread-1储存和取值的时候，对应的是它的值，从而避免多个线程对共有数据造成错误和丢失。\r\n\r\n网络编程\r\nTcp/Ip协议\r\n\r\n早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet ProtocolSuite）就是通用协议标准。\r\n\r\n因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n端口\r\n\r\n知名端口\r\n\r\n知名端口是众所周知的端口号，范围从0到1023\r\n例如：\r\n80端口分配给HTTP服务\r\n21端口分配给FTP服务\r\n一般情况下，如果一个程序需要使用知名端口的需要有root权限\r\n\r\n动态端口\r\n\r\n动态端口的范围是从1024到65535\r\n之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。\r\n动态分配是指当一个系统进程或应用程序进程需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。当这个进程关闭时，同时也就释放了所占用的端口号。\r\n\r\n小结\r\n端口有什么作用？在两台计算机通信时，只发 IP 地址是不够的，因为同一台计算机上跑着多个网络程序。一个 IP 包来了之后，到底是交给浏览器还是 QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的 IP 地址和各自的端口号。\r\n\r\nSocket-套接字\r\n\r\nudp-套接字\r\n\r\nfrom socket import *  #导入socket\r\nfrom threading import *  #导入threading\r\n\r\nudp = socket(AF_INET,SOCK_DGRAM) #创建套接字,基于UDP传输协议。相对于TCP比较快。AF_INET表示使用IPV4进行链接。如果使用IPV6则把参数修改为AF_INET6\r\n\r\nudp.bind((\'\',8080)) #绑定任意ip,和8080端口，如果不进行绑定，那么每创建一个套解字就会使用一个动态端口。\r\n\r\nsendip = input(\'输入接收方的IP：\')\r\nsendport = int(input(\'输入接收方的端口：\'))\r\n\r\ndef sendinfo(): #定义发送函数\r\n    while True:\r\n        senddata = input(\'请输入发送的内容：\')\r\n        udp.sendto(senddata.encode(\'utf-8\'),(sendip,sendport)) #调用套解字的sendto方法，第一个参数为编码后的数据，第二个参数为接收方的IP和端口。\r\n\r\ndef receiveinfo(): #定义接收函数\r\n    while True:\r\n        recvdata = udp.recvfrom(1024) #调用recvfrom方法进行数据接收，并且以元祖的方式返回，第一个参数是数据，第二个参数为IP和端口。与发送格式一致。\r\n        print(recvdata[1],recvdata[0].decode(\'utf-8\')) #将接收到的数据进行打印，并将数据进行解码。\r\n\r\ndef main():\r\n    ts = Thread(target=sendinfo) #创建一个线程运行发送函数。\r\n    tr = Thread(target=receiveinfo) #创建一个线程运行接收函数。\r\n\r\n    ts.start()\r\n    tr.start()\r\n\r\n    ts.join()\r\n    tr.join()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n23\r\n24\r\n25\r\n26\r\n27\r\n28\r\n29\r\n30\r\n31\r\n32\r\n注意：socket套接字是用来再网络间通信的模块。\r\n\r\ntcp-套接字\r\n\r\ntcp-套接字 服务器\r\n\r\nfrom socket import * #导入套接字\r\n\r\ntcp = socket(AF_INET,SOCK_STREAM) #创建tcp套接字\r\n\r\ntcp.bind((\'\',8800)) #绑定ip,和端口，客户端需要连接这个ip和端口进行服务器连接。\r\n\r\ntcp.listen(5) #tcp监听，参数为可连接的数量。\r\n\r\nnewsocket,addr = tcp.accept() #接收客户端的连接，并返回一个新的socket和客户端地址。阻塞程序等待客户端的接入。\r\n\r\nwhile 1: # 表示while True,只要条件类型不是空类型、0和None的False类型则就表示while True。\r\n    socketDate = newsocket.recv(1024) #接收客户端的数据。\r\n    if len(socketDate)>0: #如果接收数据的长度大于0，则打印出接收到的信息，如果接收的数据长度为0，则表示客户端使用close方法关闭了套接字。\r\n            print(socketDate.decode(\'utf-8\'))  #将接收数据解码为utf-8输出\r\n    else: #如果客户端关闭了套接字，则跳出循环\r\n            break\r\n\r\n    sendDate = input(\'请输入要回复的内容：\') #输入需要回复的数据\r\n    newsocket.send(sendDate.encode(\'utf-8\')) #使用send将数据编码为utf-8回复\r\n\t\r\nnewsocket.close() #关闭与客户端通信的套接字。\r\ntcp.close() #关闭服务器的套接字，关闭后将不会再接收客户端的连接。\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n22\r\n注意：在linux系统中listen的参数可以忽略，因为系统会自动按照内核进行最大连接数的操作，即使填写参数也没有效果，但是windons和mac中则会有效。以上是单线程案例。\r\n\r\ntcp-套接字 客户端\r\n\r\nfrom socket import * #导入模块\r\n\r\ncsocket = socket(AF_INET,SOCK_STREAM) #创建套接字\r\n\r\nserverIp = input(\'请输入服务器的IP:\') \r\n\r\ncsocket.connect((serverIp,8800)) #连接服务器\r\n\r\nwhile 1:\r\n    sendData = input(\'请输入需要发送打内容:\') #输入发送的内容\r\n    csocket.send(sendData.encode(\'utf-8\')) #编码发送\r\n\r\n    recvData = csocket.recv(1024)\r\n    print(\'recvData:%s\'%recvData.decode(\'utf-8\')) #解码输出\r\n\r\ncsocket.close() #关闭套接字\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n注意：正常的编程工作中，会优先使用tcp套接字。\r\n\r\n交换机、路由器\r\n交换机：\r\n\r\n转发过滤：当⼀个数据帧的⽬的地址在MAC地址表中有映射时，它被转发到连接⽬的节点的端⼝⽽不是所有端⼝（如该数据帧为⼴播帧则转发⾄所有端⼝）\r\n\r\n学习功能：以太⽹交换机了解每⼀端⼝相连设备的MAC地址，并将地址同相应的端⼝映射起来存放在交换机缓存中的MAC地址表中\r\n\r\n交换机能够完成多个电脑的链接每个数据包的发送都是以⼴播的形式进⾏的，容易堵塞⽹络如果PC不知⽬标IP所对应的的MAC，那么可以看出，pc会先发送arp⼴播，得到对⽅的MAC然后，在进⾏数据的传送当switch第⼀次收到arp⼴播数据，会把arp⼴播数据包转发给所有端⼝（除来源端⼝）；如果以后还有pc询问此IP的MAC，那么只是向⽬标的端⼝进⾏转发数据。\r\n\r\n路由器\r\n\r\n路由器（Router）⼜称⽹关设备（Gateway）是⽤于连接多个逻辑上分开的⽹络所谓逻辑⽹络是代表⼀个单独的⽹络或者⼀个⼦⽹。当数据从⼀个⼦⽹传输到另⼀个⼦⽹时，可通过路由器的路由功能来完成具有判断⽹络地址和选择IP路径的功能\r\n\r\n不在同⼀⽹段的pc，需要设置默认⽹关才能把数据传送过去 通常情况下，都会把路由器默认⽹关当路由器收到⼀个其它⽹段的数据包时，会根据“路由表”来决定，把此数据包发送到哪个端⼝；路由表的设定有静态和动态⽅法每经过⼀次路由器，那么TTL值就会减1\r\n\r\n网段、ARP、DNS、MAC地址\r\n网段\r\n\r\n网段（network segment）一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。例如，从192.168.0.1到192.168.255.255这之间就是一个网段。\r\n\r\nA类IP段　 0.0.0.0 到127.255.255.255 Ａ类的默认子网掩码　255.0.0.0　　　　　一个子网最多可以容纳1677万多台电脑\r\nB类IP段　 128.0.0.0 到191.255.255.255 Ｂ类的默认子网掩码　255.255.0.0　　　　一个子网最多可以容纳6万台电脑\r\nC类IP段　 192.0.0.0 到223.255.255.255 Ｃ类的默认子网掩码　255.255.255.0　　　一个子网最多可以容纳254台电脑\r\n\r\n局域网保留地址：\r\nA类：10.0.0.0/8 10.0.0.0-10.255.255.255\r\nB类：172.16.0.0/12 172.16.0.0-172.31.255.255\r\nC类：192.168.0.0/16 192.168.0.0～192.168.255.255\r\n\r\n注意：C类地址必须前三位一致的才算是一个局域网，可以不使用路由器进行通信，例如192.168.1.1-192.168.1.254 是一个局域网，B类地址则必须前两位一致才算是一个局域网。以此类推。即子网掩码有几位相同的则需要有几位一致的。\r\n\r\nARP\r\n\r\n地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。\r\n\r\n工作过程\r\n主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；\r\n主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；\r\n当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：\r\n第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。\r\n第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。\r\n第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。\r\n第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。\r\n第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。\r\n\r\nDNS\r\n\r\nDNS服务器是(Domain Name System或者Domain Name Service)域名系统或者域名服务,域名系统为Internet上的主机分配域名地址和IP地址。用户使用域名地址，该系统就会自动把域名地址转为IP地址。域名服务是运行域名系统的Internet工具。执行域名服务的服务器称之为DNS服务器，通过DNS服务器来应答域名服务的查询。\r\n\r\nMAC地址\r\n\r\nMAC(Media Access Control或者Medium Access Control)地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。\r\n\r\nMAC(Medium/Media Access Control)地址，用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节(48位)。其中，前三个字节是由IEEE的注册管理机构RA负责给不同厂家分配的代码(高位24位)，也称为\"编制上唯一的标识符\"(Organizationally Unique Identifier)，后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符(唯一性)。一个地址块可以生成2个不同的地址。MAC地址实际上就是适配器地址或适配器标识符EUI-48[1]\r\n\r\n注意：在真正的信息传输中，发送者的ip和接收方的ip和数据包内容是不变的，期间会通过各个路由器的mac地址进行传输。简单可以理解为，在网上买了一件衣服，包裹的发送方是商家（可以理解为发送者的IP），包裹的接收方是自己（理解为接收者的IP），期间的各个快递中转站就可以理解为各个路由器的mac地址，最后由数据将会传递到自己手中。\r\n\r\nTCP3次握手、4次挥手和10种状态\r\nTCP3次握手\r\n\r\n在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.\r\n第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； SYN：同步序列编号(Synchronize Sequence Numbers)\r\n第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；\r\n第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.\r\n完成三次握手,客户端与服务器开始传送数据\r\n\r\n\r\n\r\n关闭连接（四次挥手）\r\n\r\n第一次挥手：客户端发送FIN+ACK包（序号为seq=a，确认序号ack=b）给服务端，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。\r\n第二次挥手：服务端收到FIN+ACK包后，发送ACK包给客户端进行确认，服务端进入CLOSE_WAIT状态。客户端收到ACK包后进入FIN_WAIT_2状态。到这里，关闭一个单向通道。\r\n第三次挥手：服务端发送FIN+ACK包给客户端，服务端进入LAST_ACK状态。\r\n第四次挥手：客户端收到FIN+ACK包后，发送ACK包给服务端进行确认，客户端进入TIME_WAIT状态，在等待30秒（可修改）后进入CLOSED状态。服务端收到ACK包后进入CLOSED状态，关闭另一个单向通道。\r\n\r\n\r\n\r\nTCP十种状态\r\n\r\n\r\n\r\nCLOSED：表示关闭状态（初始状态）。\r\nLISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。\r\nSYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。\r\nSYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。\r\nESTABLISHED：表示连接已经建立。\r\nFIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是： FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。\r\nFIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。\r\nTIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。\r\nCLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。\r\nLAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。\r\n\r\ntcp第十一种状态：\r\nCLOSING:这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。\r\n\r\nTCP的2MSL\r\n\r\n\r\n\r\n2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，\r\n当TCP的⼀端发起主动关闭，在发出最后⼀个ACK包后，即第3次握 ⼿完成后发送了第四次握⼿的ACK包后就进⼊了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要⽬的是怕最后⼀个 ACK包对⽅没收到，那么对⽅在超时后将重发第三次握⼿的FIN包，主动关闭端接到重发的FIN包后可以再发⼀个ACK应答包。\r\n\r\n在TIME_WAIT状态 时两端的端⼝不能使⽤，要等到2MSL时间结束才可继续使⽤。当连接处于2MSL等待阶段时任何迟到的报⽂段都将被丢弃。不过在实际应⽤中可以通过设置 SO_REUSEADDR选项达到不必等待2MSL时间结束再使⽤此端⼝。\r\n\r\nTCP⻓连接和短连接\r\n\r\n短链接\r\n\r\n\r\n\r\n⻓连接\r\n\r\n\r\n\r\n常见的网络攻击\r\nDDOS攻击\r\n\r\n\r\n\r\n注意：简单的理解DDOS攻击就是使用TCP的三次握手协议，编写代码使用多线程或者多进程方式恶意的不发送第三次握手导致服务器listen队列爆满，使正常的客户无法正常连接。\r\n\r\nDNS攻击\r\n\r\nDNS欺骗就是攻击者冒充域名服务器的一种欺骗行为。 原理:如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，这样的话，用户上网就只能看到攻击者的主页，而不是用户想要取得的网站的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的\"黑掉\"了对方的网站，而是冒名顶替、招摇撞骗罢了。\r\n\r\nARP攻击\r\n\r\nARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。\r\nARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP木马，则感染该ARP木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。\r\n攻击者向电脑A发送一个伪造的ARP响应，告诉电脑A：电脑B的IP地址192.168.0.2对应的MAC地址是00-aa-00-62-c6-03，电脑A信以为真，将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者。同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址192.168.0.1对应的MAC地址是00-aa-00-62-c6-03，电脑B也会将数据发送给攻击者。\r\n至此攻击者就控制了电脑A和电脑B之间的流量，他可以选择被动地监测流量，获取密码和其他涉密信息，也可以伪造数据，改变电脑A和电脑B之间的通信内容。\r\n————————————————\r\n版权声明：本文为CSDN博主「丶大皮球」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/m18903718781/java/article/details/78428878\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"126-win32com 操作word总结.md","path":"13-语言学习project/12-python3/126-win32com 操作word总结.md","content":"# python win32com 操作word总结\r\n\r\n[![img](D:\\Typora_pic\\d64c825c2193.webp)\r\n\r\n这两天研究python操作word文档，因为相关的文档比较少，磕磕绊绊的各种搜索终于把我要实现的功能大体实现了，代码不多，时间主要耗费在中文乱码上。\r\n\r\n## 实现的内容\r\n\r\n> 打开word文档\r\n> 读取表格\r\n> 表格插入行\r\n> 向表格中填写内容\r\n> 文档另存为\r\n\r\n## 环境\r\n\r\npython 2.7\r\n==文件保存的编码格式是utf-8==\r\n\r\n## 代码\r\n\r\n\r\n\r\n```python\r\n#模块引用\r\nimport win32com\r\nform win32com.client import Dispatch,DispatchEx\r\n#打开word文档\r\nword= Dispatch(\'Word.Application\')\r\nword.Visiable=1\r\npath=\"c:/model.docx\"\r\ndoc = word.Documents.Open(FileName=path,Encoding=\'gbk\')\r\n#中文路径乱码问题处理\r\npath=\"c:/文档.docx\"\r\nFileName=path.decode(\"utf8\")\r\n#读取表格\r\ntable = doc.Tables[0]\r\n#表格插入行\r\ntable.Cell(0,0).Select()\r\nword.Selection.InsertRowsBelow(1) #当前行的下面插入一行\r\n#向表格中填写内容\r\ntable.Cell(0,0).Range.Text=\'abc\'\r\nstr = \"你好\"\r\n#中文写入乱码处理\r\ntable.Cell(0,1).Range.Text=str.decode(\"utf8\")\r\ntable.Cell(0,2).Range.Text=(u\'%s\' % str)\r\n#文档另存为\r\npath=\"c:/result.docx\"\r\ndoc.SaveAs(path)\r\n```\r\n\r\n## 思考\r\n\r\n1、在处理中文乱码的时候，各种尝试，尝试的都无望了，最后感觉是瞎猫床死耗子，才蒙对的。感觉自己对编码原理这块了解太少，有时间需要把这方面的知识好好研究一下。\r\n2、在无望的时候，要以一个什么样的心态对待这个问题，是放弃还是坚持，这个尺度不好把握。在写这篇文章的时候，中文写入乱码这块还没解决，我都已经放弃了，虽然放弃了，我感觉有必要记录一下我都做了那些尝试，在记录的过程中，我突发奇想的在我的程序中删除了一些代码，结果乱码问题却意外的解决了。可能是我这方面经验太少，还是要多多尝试，不断的积累，以后可能会更好的把握这个度吧。","timestamp":1590329650947},{"name":"127-wmi.md","path":"13-语言学习project/12-python3/127-wmi.md","content":"## python中wmi介绍和使用\r\n\r\n (2011-03-03 11:05:00)\r\n\r\n[![img](D:\\Typora_pic\\sg_trans.gif)转载*▼*](javascript:;)\r\n\r\n| 标签： [python中wmi](http://search.sina.com.cn/?c=blog&q=python%D6%D0wmi&by=tag) [介绍和使用](http://search.sina.com.cn/?c=blog&q=%BD%E9%C9%DC%BA%CD%CA%B9%D3%C3&by=tag) [it](http://search.sina.com.cn/?c=blog&q=it&by=tag) | 分类： [工作笔记](http://blog.sina.com.cn/s/articlelist_1656760931_2_1.html) |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n|                                                              |                                                              |\r\n\r\n# python中wmi介绍和使用\r\n\r\n\r\n\r\n\r\n\r\n一：WMI基础知识\r\n====================================================================================\r\nWMI 最初于1998年作为一个附加组件与 Windows NT 4.0 Service Pack 4 一起发行，是内置在Windows 2000、 Windows XP和Windows Server 2003 系列操作系统中核心的管理支持技术。基于由 Distributed Management Task Force (DMTF) 所监督的业界标准，WMI是一种规范和基础结构，通过它可以访问、配置、管理和监视几乎所有的Windows资源。大多用户习惯于使用众多的图形化管理工 具来管理Windows资源，在WMI之前这些工具都是通过 Win32应用程序编程接口(Application ProgrammingInterfaces，API)来访问和管理Windows资源的。只要你熟悉系统编程你就知道API有多么重要。但是大多数脚本 语言都不能直接调用Win32 API，WMI的出现使得系统管理员可以通过一种简便的方法即利用常见的脚本语言实现常用的系统管理任务。\r\n利用WMI需要和脚本如WSH和VBScript结合起来，可以实现的功能大家可以看微软的MSDN文档。\r\n在编写我们自己的脚本之前，我们需要对WMI的体系结构有个基本的了解。如图一：(1.gif)\r\n在WMI 体系结构中我们最需要关心的就是WMI提供程序，WMI提供程序在WMI和托管资源之间扮演着中间方的角色。提供程序代表使用者应用程序和脚本从WMI托 管资源请求信息，并发送指令到WMI托管资源。下面是我们利用WMI编程经常要用到的WMI内置提供程序清单，以供编程参考。\r\n1.Active Directory提供程序\r\n链接库文件：dsprov.dll\r\n命名空间：root\\directory\\ldap\r\n作用：将Active Directory 对象映射到 WMI。\r\n\r\n2.事件日志提供程序\r\n链接库文件：ntevt.dll\r\n命名空间：root\\cimv2\r\n作用：管理 Windows 事件日志，例如，读取、备份、清除、复制、删除、监视、重命名、压缩、解压缩和更改事件日志设置。\r\n\r\n3.注册表提供程序\r\n链接库文件：stdprov.dll\r\n命名空间：root\\default\r\n作用：读取、写入、枚举、监视、创建、删除注册表项和值。\r\n\r\n4.Win32 提供程序\r\n链接库文件：cimwin32.dll\r\n命名空间：root\\cimv2\r\n作用：提供关于计算机、磁盘、外围设备、文件、文件夹、文件系统、网络组件、操作系统、打印机、进程、安全性、服务、共享、SAM 用户及组，以及更多资源的信息。\r\n\r\n5.Windows 安装程序提供程序\r\n链接库文件：msiprov.dll\r\n命名空间：root\\cimv2\r\n作用：提供对已安装软件信息的访问。\r\n\r\n从 上面可以看出在WMI中类（即内置提供程序）被分组到命名空间中，命名空间可以看成是一个组。比如，命名空间 root\\cimv2 包括大部分表示通常与计算机和操作系统相关联的资源的类。在使用类的时候要说明类所在的命名空间。类由属性和方法构成。这是可视化编程中的两个重要的概 念。属性描述的是对象的状态，方法是对象可以执行的操作。\r\n(转载)\r\n\r\n接着看python 中的WMI使用\r\n\r\n是Tim Golden\'s 的WMI.PY,使用起来非常简单.下面的例子是摘自它自身提供的example\r\n\r\nimport wmi\r\n\r\nc = wmi.WMI ()\r\nfor s in c.Win32_Service ():\r\nif s.State == \'Stopped\':\r\n print s.Caption, s.State\r\n打印WIN的服务名称和状态.其中服务是在停止状态下才打印.\r\n\r\nList all running processes\r\n\r\nimport wmi\r\nc = wmi.WMI ()\r\nfor process in c.Win32_Process ():\r\nprint process.ProcessId, process.Name\r\n简单吧,几天语句就把进程列出来了，提权什么都不用，比用delphi方便多了,嘿嘿，不过就是速度慢了点。\r\n\r\nReboot a remote machine\r\n\r\nimport wmi\r\nc = wmi.WMI (computer=\"other_machine\", privileges=[\"RemoteShutdown\"])\r\nos = c.Win32_OperatingSystem (Primary=1)[0]\r\nos.Reboot ()\r\n\r\n\r\nShow the IP and MAC addresses for IP-enabled network interfaces\r\n\r\nimport wmi\r\nc = wmi.WMI ()\r\nfor interface in c.Win32_NetworkAdapterConfiguration (IPEnabled=1):\r\nprint interface.Description, interface.MACAddress\r\nfor ip_address in interface.IPAddress:\r\n print ip_address\r\nprint\r\n\r\n\r\nList registry keys\r\n\r\nimport _winreg\r\nimport wmi\r\nr = wmi.Registry ()\r\nresult, names = r.EnumKey (hDefKey=_winreg.HKEY_LOCAL_MACHINE, sSubKeyName=\"Software\")\r\nfor key in names:\r\nprint key\r\n操作注册表.\r\n\r\n越用越爽啊,简单易用,真不愧是pythonic啊。当然还有很多其他的example,自己看咯.\r\n\r\nwmi python\r\nhttp://tgolden.sc.sabren.com/python/wmi.html\r\nwim cookbook\r\nhttp://tgolden.sc.sabren.com/python/wmi_cookbook.html","timestamp":1590329650947},{"name":"128-内置函数.md","path":"13-语言学习project/12-python3/128-内置函数.md","content":"# [python 中一些常用的内置函数](https://www.cnblogs.com/shiqi17/p/9356188.html)\r\n\r\n#### 一、常用内置函数\r\n\r\n- abs(x) 返回绝对值，参数为int float，非字符只能num\r\n- all(iterable) 如果迭代对象里面的所有值都为真就返回True。all([1, 2, -7]) ---->True all(1, 0, 3]) ----->False\r\n- any(iterable) 和上相反有一个为真就返回 True\r\n- bin(digital) 把十进制数转为2进制 `bin(1)`-->\'0b1\' `bin(4)`-->\'0b00\' `bin(255)` --> \'0b11111111\'\r\n- a= byte(\'abcde\', encoding=\'utf-8\')\r\n\r\n```\r\n>>> a = bytes(\'abcde\', encoding=\'utf-8\')\r\n>>> print(a.capitalize(), \'-------\', a)\r\nb\'Abcde\' ------- b\'abcde\'       #可以看到字符串a作为不可变类型，是无法改变的\r\n```\r\n\r\n- bytearray(\'abcde\', encoding= \"utf-8\") 返回字符串每个字符ASCII值组成的一个列表，用处：作者本人在写登录程序时，用户名非法字符用过，将用户名bytearry()然后循环对比如果有ASCII值在32-47之间，当中就含有非法字符。返回False\r\n\r\n```\r\n>>> b_list = bytearray(\'abcde\', encoding=\"utf-8\") \r\n>>> for item in b_list: \r\n...     print(item)\r\n97\r\n98\r\n99\r\n100\r\n101\r\n>>> b_list[1] = 55\r\n>>> b_list\r\nbytearray(b\'a7cde\')         #可以看到，当我们把列表中的第1个元素ASCII值修改为55后字符串改变了\r\n```\r\n\r\n- callable(v) 判断是否可调用，是返回True。这个还算好用，比如我们自己写装饰器时，判断下传过来是否是可调用的函数，如果不是那就不操作`callable([1])`-->False\r\n- chr(数字）把数字对应的ASCII表中的代表返回 `chr(97)`-->\'a\' `chr(87)`-->\'W\'\r\n- ord(字母) 把字符对应的ASCII值返回，只能一个字母，bytearray返回字符串的ASCII成迭代器（可理解为列表）\r\n- compile() 底层用来把字符串文件编译成可执行文件的函数。第一个参数字符串，第二个不用管，第三个可以为\'exec\'，\'eval\'\r\n\r\n```\r\n>>> code = \"for i in range(3):    print(i)\"\r\n>>> c = compile(code, \' \', \'exec\')\r\n>>> exec(c)\r\n0\r\n1\r\n2\r\n```\r\n\r\n- eval(字符串) exec() 参数为可执行字符串，返回执行结果，同compile，eval只能执行一行简单的代码，而exec只要格式正确都行\r\n\r\n```\r\n>>> eval(\'1 + 2 + 6\')\r\n9\r\n>>> code = \'\'\'def fun(a):\\n   print(a)\\nfun(\"luxi\")\'\'\'\r\n>>> exec(code)         #exec格式正确正常使用\r\nluxi\r\n>>> eval(code)         #eval 作者也不知道，反正同一串代码，exec能执行，eval不行，eval在执行一行简单代码上没问题\r\n  File \"<string>\", line 1\r\n    def fun(a):\r\n      ^\r\nSyntaxError: invalid syntax\r\n```\r\n\r\n- dir(dict) 查看变量，函数类所拥有的方法\r\n  `[...\'__hash__\', \'__init__\', \'__iter__\',...\'get\', \'items\', \'keys\', \'pop\'..\'update\', \'values\']`\r\n- divmod(5, 2) 返回商和余数 --->(2, 1)\r\n- filter(function, iterable) 按照function的规则过滤出来想要的结果\r\n  `for i in filter(lambda x:x>5, [2, 3, 5, 7, 9]):` `print(i)`----->`7\\n9` filter会得到一个filter的迭代对象\r\n- globals() 返回程序命名空间中的所有key-value\r\n- locals() 返回函数的局部作用域（命名空间）的所有key-value\r\n  以上两个关于函数作用域问题在以下文章有写\r\n  [https://www.cnblogs.com/shiqi17/p/9331002.html]","timestamp":1590329650947},{"name":"129-字典.md","path":"13-语言学习project/12-python3/129-字典.md","content":"# [Python 中的字符串（str）、字典（dict）详解及操作方法](https://www.cnblogs.com/shiqi17/p/9305154.html)\r\n\r\n#### 一、字符串\r\n\r\n在python中字符串是一种重要数据类型。其他数据类型分别为：\r\n\r\n1. 数字-number -------- **int、long、float、complex**这几种\r\n2. 字符串-string -------- **\"使用引号\"**引起来的都是字符串\r\n3. 元组-tuple ------------ **(1,2)**使用小括号引起来的元素，中间用逗号隔开.\r\n   注意如果**元组(v1, )**中只有一个值，一定记得要用逗号隔开，不然就无法识别为元组了\r\n4. 布尔值-bool --------- **True及False**\r\n   以上四个为Python中的不可变对象，创建后就不能改变的量-->指该变量指向内存中的值不能被改变，当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址\r\n\r\n------\r\n\r\n\\5. 列表-list --------------- **[1, 2, 3] [\'a\', \'b\', \'c\']**中括号，里面的元素用逗号隔开 6. 字典-dict -------------- **{key1 : value1, key2 : value2}** 使用大括号＋键-值方式定义，键值之间使用 : 冒号，不同的键对值使用逗号分开\r\n\r\n5、6皆为可变对象，指该对象所指向内存中的值可以被改变。\r\n\r\n##### 1.1 字符串的方法\r\n\r\n1. `str.capitalize()` 会将首字母大写\r\n2. `str.count(x, start=None, end=None)` 统计str中的指定字符x的个数，start和end为起始位和结束位\r\n3. `str.center(num, [指定字符])` 将str字符串在num长度的字符中居中，str长度不够则第二个参数为填充字符。同 `\"{0:[填充字符]^[长度]}\".format(str)` 一样的效果\r\n4. `str.endswith(\"tr\")` 判定str是否为指定参数，这儿为\"tr\"结尾，是返回True 否False\r\n5. `str.find([指定字符])` 找到参数字符在str中的起始索引\r\n6. `str.isalnum()` str是否为阿拉伯数字、字符，是返回True\r\n7. `str.isalpha()` 是否为纯英文\r\n8. `str.isdecimal()` 是否为十进制数\r\n9. `str.isdigit()` 是否为整数\r\n10. `str.isidentifier()` 是否为合法标识符（变量名）\r\n11. `str.islower()` 字符串是否全部小写\r\n12. `str.lower()` 将字符串小写\r\n13. `str.isupper()` 字符串是否为大写\r\n14. `str.upper()` 将字符串大写\r\n15. `\'[分隔符]\'.join([iterable])` 如`\"+\".join([\'1\', \'2\', \'3\'])`结果为\'1+2+3\' 分隔符的join方法参数为可循环对象\r\n16. `str.ljust(num, \'[填充符]\')` 扩展str长度到num，不够的位置使用填充符从右往左填充\r\n17. `str_s.replace(\'s\', \'S\', 1)` 替换目标字符，将小写s替换为大写S，只替换一个\r\n18. `str.split(sep=None)` 将字符按照sep参数分割，列表形式返回分割后的元素\r\n19. `str.strip(chars=None)` **重要**默认移除字符串头和尾的 space、\\n、\\t ，或者移除指定参数字符\r\n\r\n```\r\n>>> str_test = \'\\n/home/user/lina  \\t\'\r\n>>> str_test = str_test.strip()      #去除首尾的space \\n \\t \r\n>>> str_test\r\n\'/home/user/lina\'\r\n>>> str_list = str_test.split(\'/\')    #以 \'/\' 分割字符串\r\n>>>str_list\r\n[\'\', \'home\', \'user\', \'lina\']\r\n>>> str_test .strip(\'/\')   #去除首尾的‘/’\r\n\'home/user/lina\'\r\n>>>\r\n```\r\n\r\n#### 二、字典\r\n\r\n```\r\n字典(dict)是python中唯一的一个映射类型.他是以{ }括起来的键值对组成. 在dict中key是唯一的，\r\n在保存的时候, 根据key来计算出⼀一个内存地址然后将key-value保存在这个地址中。\r\n这种算法被称为hash算法, 所以, 切记, 在dict中存储的key-value中的key必须是可hash的,\r\n如果你搞不懂什什么是可哈希, 暂时可以这样记, 可以改变的都是不可哈希的,\r\n那么可哈希就意味着不可变. 这个是为了了能准确的计算内存地址⽽而规定的.\r\n\r\n已知的可哈希(不可变)的数据类型: int, str, tuple, bool不可哈希(可变)的数据类型: list, dict, set（详见开头介绍python中的不可变对象）\r\n\r\n字典其他语言中称为map，使用键-值{key:value}方式存储数据也让其具有极高的查找速度\r\n相比于List、tuple为什么会有如此高的查找速度呢？\r\n设想我们现在使用list、tuple来存储一个人的个人信息,一个列表存储姓名，另一个列表内用元组存其他信息，用列表索引对应\r\n>>> p_name = [\'lina\', \'josh\', \'alex\', \'linda\', \'david\']\r\n>>> p_info = [(22, \'student\', \'UA), (32, \'musician\', \'Germany\'), (33, \'worker\', \'Austrilia\'), (26, \'artist\', \'Russia\'), (\'54\', \'politician\', \'UA\')]\r\n>>>\r\n```\r\n\r\n假设我们要查找到某人的具体信息，那么我们就必须先从p_name中拿到他的索引`index_var = p_name.index(var)`，然后拿着索引index_var到p_info中去p_info[index_var]拿到具体信息，第一次查找时，我们必须**遍历列表**，这个过程列表元素少很快，当列表元素多了的时候，遍历就很浪费时间了，第二次查找时就是可以用二分法了。而当用字典来存储时，直接姓名哈希算法hash找到个人信息存储地址--->\r\n\r\n```\r\n>>> p_info = {\'lina\': (22, \'student\', \'UA),\r\n... \'josh\': (32, \'musician\', \'Germany\'),\r\n... \'alex\': (33, \'worker\', \'Austrilia\'),\r\n... \'linda\': (26, \'artist\', \'Russia\'),\r\n... \'david\': (\'54\', \'politician\', \'UA\')}\r\n>>> p_info[\'josh\']\r\n(32, \'musician\', \'Germany\')\r\n```\r\n\r\n这样通过名字作为索引，就可以一次直接查询到，不用去遍历整个keys，然后通过哈希算法根据key，算出value的存储地址直接拿到value。几乎不会随着字典的增大而查找速度变慢 =\r\n注意：创建或者添加时，**key是唯一的**不可重复。\r\n\r\n##### 2.1字典的增\r\n\r\n```\r\n2.1.1直接通过 dict[索引] = value 方式增加\r\n优点：简单方便   缺点：如果新增的key和已经存在的key重复，那就会直接更新该key对应的value\r\n当然你也可以通过 key in dict 或者get()方法判断，key是否已经存在字典中\r\n>>> dict1 = {\'name\': \'lina\'}\r\n>>> dict1[\'age\'] = 24\r\n>>>dict1\r\n{\'name\': \'lina\', \'age\': 24}\r\n>>> \r\n>>> \'age\' in dict1      #判断字典中是否存在该key存在返回True，不存在False\r\nTrue\r\n>>> dict1.get(\'name\')  #通过字典的get()方法拿到对应的key的value\r\n\'lina\'\r\n>>> dict1.get(\'job\')  #当key不存在时返回None\r\n>>>\r\n2.1.2 dict.setdefault(\'key\', value) 设置，增加新key-value\r\n相比于第一种方式，这样去增加值，当key不存在时，新增key-value，当key存在时，不做操作。避免了误操作修改了重要数据\r\n>>> dict2 = {\'name\': \'lina\'}\r\n>>> dict2.setdefault(\'age\', 23)    #setdefault()安全设置key-value\r\n23\r\n>>> dict2\r\n{\'age\': 23, \'name\': \'lina\'}\r\n>>> dict2.setdefault(\'name\', \'alex\')   #尝试用setdefault()设置已存在的key-value\r\n\'lina\'\r\n>>> dict2.get(\'name\')   #可以看见，setdefault无法改变已经存在了的key-value\r\n\'lina\'\r\n```\r\n\r\n##### 2.2字典的删除\r\n\r\n```\r\n2.2.1 del dict[key] python内置函数del 删除\r\n缺点：如果你不小心玩成del dict 这样，那你就完了，整个字典都给你删除了\r\n2.2.2 dict.pop(key) 最常用的，标准删除格式。通过dict.pop函数，删除并返回value\r\n安全删除建议使用\r\n2.2.3 dict.popitem() 随机删除，当没看见\r\n2.2.4 dict.clear() 清空字典所有元素\r\n```\r\n\r\n##### 2.3字典的改、查\r\n\r\n```\r\n2.3.1 dict.updata(new_dict) 将一个新字典更新到原字典中，如果dict和new_dict 存在相同的key，就用新字典的key-value去更新原字典的value\r\n2.3.2 dict[key]直接查询，缺点当key不存在时，会直接报错。建议使用dict.get(key) key存在直接返回value，不存在返回None\r\ndict1 = {\"k1\": \"v1\",\r\n         \"k2\": \"v2\",\r\n         \"k3\": \"v3\"}\r\n\r\nnew_dict = {\"k3\": \"vv3\",\r\n         \"k4\": \"vv4\"}\r\n\r\ndict1.update(new_dict)\r\nprint(dict1)\r\n\r\n#结果为：\r\n{\'k1\': \'v1\', \'k2\': \'v2\', \'k4\': \'vv4\', \'k3\': \'vv3\'}  #dict1中的k3-v3 更新为k3-vv3\r\n\r\n#-------------------------------------------------------------------------------------------\r\n#查\r\nprint(dict1[\"k1\"])\r\nprint(dict1.get(\"k2\")\r\n\r\n#结果为\r\nv1\r\nv2\r\n```\r\n\r\n##### 2.4 字典的遍历\r\n\r\n```\r\n2.4.1 按照keys进行遍历\r\n语法：for key in dict:\r\n>>> dict1 = {\'a\': 1, \'b\': 2, \'c\': 3}\r\n>>> for key in dict1:\r\n...     print(\"key:{0: <3}value:{1}\".format(key, dict1.get(key)))\r\n... \r\nkey:a  value:1\r\nkey:b  value:2\r\nkey:c  value:3\r\n2.4.2 按照dict.items() 遍历\r\n字典中的items 是一个个的元组，每一个元组是一个(key, valule) 的组合\r\ndict1 = {\"k1\": 1,\"k2\": 2,\"k3\": 3}\r\nfor k,v in dict1.items():\r\n    print(k,v)\r\n\r\n#结果为\r\nk3 v3\r\nk1 v1\r\nk2 v2\r\n```\r\n\r\n##### 2.5 字典的输出\r\n\r\n```\r\n2.5.1 输出keys,， dict.keys()会输出一个由keys组成的dict_keys对象，是类似列表格式，可用list(dict.keys())转化为列表\r\n2.5.2 输出values , 同理keys一样，是由values组成的一个dict_keys对象\r\n>>> dict1 = {\"k1\": 1,\"k2\": 2,\"k3\": 3}\r\n>>> dict1.keys()   #输出keys\r\ndict_keys([\'k3\', \'k2\', \'k1\'])\r\n>>> list(dict1.keys())   #转为list方法\r\n[\'k3\', \'k2\', \'k1\']\r\n>>> dict1.values()  #输出values\r\ndict_values([1, 2, 3])\r\n```","timestamp":1590329650947},{"name":"130-截图.md","path":"13-语言学习project/12-python3/130-截图.md","content":"# python3应用windows api对后台程序窗口及桌面截图并保存的方法\r\n\r\n 更新时间：2019年08月27日 11:12:30  作者：Demon_Hunter  [![img](https://www.jb51.net/skin/2018/images/text-message.png) 我要评论](https://www.jb51.net/article/168576.htm#comments)\r\n\r\n今天小编就为大家分享一篇python3应用windows api对后台程序窗口及桌面截图并保存的方法，具有很好的参考价值，希望对大家有所帮助。一起跟随小编过来看看吧\r\n\r\n**python的版本及依赖的库的安装**\r\n\r\n```\r\npip install pywin32==224\r\npip install numpy==1.15.3\r\npip install opencv-python==3.4.2.16\r\npip install opencv-contrib-python==3.4.2.16\r\npip install Pillow-PIL==0.1.dev0\r\n```\r\n\r\n**对后台窗口截图**\r\n\r\n```python\r\n#对后台窗口截图\r\nimport win32gui, win32ui, win32con\r\nfrom ctypes import windll\r\nfrom PIL import Image\r\nimport cv2\r\nimport numpy\r\n \r\n#获取后台窗口的句柄，注意后台窗口不能最小化\r\nhWnd = win32gui.FindWindow(\"NotePad\",None) #窗口的类名可以用Visual Studio的SPY++工具获取\r\n#获取句柄窗口的大小信息\r\nleft, top, right, bot = win32gui.GetWindowRect(hWnd)\r\nwidth = right - left\r\nheight = bot - top\r\n#返回句柄窗口的设备环境，覆盖整个窗口，包括非客户区，标题栏，菜单，边框\r\nhWndDC = win32gui.GetWindowDC(hWnd)\r\n#创建设备描述表\r\nmfcDC = win32ui.CreateDCFromHandle(hWndDC)\r\n#创建内存设备描述表\r\nsaveDC = mfcDC.CreateCompatibleDC()\r\n#创建位图对象准备保存图片\r\nsaveBitMap = win32ui.CreateBitmap()\r\n#为bitmap开辟存储空间\r\nsaveBitMap.CreateCompatibleBitmap(mfcDC,width,height)\r\n#将截图保存到saveBitMap中\r\nsaveDC.SelectObject(saveBitMap)\r\n#保存bitmap到内存设备描述表\r\nsaveDC.BitBlt((0,0), (width,height), mfcDC, (0, 0), win32con.SRCCOPY)\r\n \r\n#如果要截图到打印设备：\r\n###最后一个int参数：0-保存整个窗口，1-只保存客户区。如果PrintWindow成功函数返回值为1\r\n#result = windll.user32.PrintWindow(hWnd,saveDC.GetSafeHdc(),0)\r\n#print(result) #PrintWindow成功则输出1\r\n \r\n#保存图像\r\n##方法一：windows api保存\r\n###保存bitmap到文件\r\nsaveBitMap.SaveBitmapFile(saveDC,\"img_Winapi.bmp\")\r\n \r\n##方法二(第一部分)：PIL保存\r\n###获取位图信息\r\nbmpinfo = saveBitMap.GetInfo()\r\nbmpstr = saveBitMap.GetBitmapBits(True)\r\n###生成图像\r\nim_PIL = Image.frombuffer(\'RGB\',(bmpinfo[\'bmWidth\'],bmpinfo[\'bmHeight\']),bmpstr,\'raw\',\'BGRX\',0,1)\r\n##方法二（后续转第二部分）\r\n \r\n##方法三（第一部分）：opencv+numpy保存\r\n###获取位图信息\r\nsignedIntsArray = saveBitMap.GetBitmapBits(True)\r\n##方法三（后续转第二部分）\r\n \r\n#内存释放\r\nwin32gui.DeleteObject(saveBitMap.GetHandle())\r\nsaveDC.DeleteDC()\r\nmfcDC.DeleteDC()\r\nwin32gui.ReleaseDC(hWnd,hWndDC)\r\n \r\n##方法二（第二部分）：PIL保存\r\n###PrintWindow成功,保存到文件,显示到屏幕\r\nim_PIL.save(\"im_PIL.png\") #保存\r\nim_PIL.show() #显示\r\n \r\n##方法三（第二部分）：opencv+numpy保存\r\n###PrintWindow成功，保存到文件，显示到屏幕\r\nim_opencv = numpy.frombuffer(signedIntsArray, dtype = \'uint8\')\r\nim_opencv.shape = (height, width, 4)\r\ncv2.cvtColor(im_opencv, cv2.COLOR_BGRA2RGB)\r\ncv2.imwrite(\"im_opencv.jpg\",im_opencv,[int(cv2.IMWRITE_JPEG_QUALITY), 100]) #保存\r\ncv2.namedWindow(\'im_opencv\') #命名窗口\r\ncv2.imshow(\"im_opencv\",im_opencv) #显示\r\ncv2.waitKey(0)\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n**对桌面截图**\r\n\r\n```python\r\n# 截图整个桌面\r\nimport win32gui\r\nimport win32ui\r\nimport win32con\r\nimport win32api\r\n \r\n# 获取桌面\r\nhdesktop = win32gui.GetDesktopWindow()\r\n# 分辨率适应\r\nwidth = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)\r\nheight = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)\r\nleft = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)\r\ntop = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)\r\n# 创建设备描述表\r\ndesktop_dc = win32gui.GetWindowDC(hdesktop)\r\nimg_dc = win32ui.CreateDCFromHandle(desktop_dc)\r\n# 创建一个内存设备描述表\r\nmem_dc = img_dc.CreateCompatibleDC()\r\n# 创建位图对象\r\nscreenshot = win32ui.CreateBitmap()\r\nscreenshot.CreateCompatibleBitmap(img_dc, width, height)\r\nmem_dc.SelectObject(screenshot)\r\n# 截图至内存设备描述表\r\nmem_dc.BitBlt((0, 0), (width, height), img_dc, (0, 0), win32con.SRCCOPY)\r\n# 将截图保存到文件中\r\nscreenshot.SaveBitmapFile(mem_dc, \'screenshot.bmp\')\r\n# 内存释放\r\nmem_dc.DeleteDC()\r\nwin32gui.DeleteObject(screenshot.GetHandle())\r\n```\r\n\r\n以上这篇python3应用windows api对后台程序窗口及桌面截图并保存的方法就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。","timestamp":1590329650947},{"name":"131-截图2.md","path":"13-语言学习project/12-python3/131-截图2.md","content":"# Python实现屏幕截图的两种方式\r\n\r\n 更新时间：2018年02月05日 11:51:13  作者：weiyinfu  [![img](https://www.jb51.net/skin/2018/images/text-message.png) 我要评论](https://www.jb51.net/article/134443.htm#comments)\r\n\r\n这篇文章主要介绍了Python实现屏幕截图的两种方式及对这两者的特点和用法进行详细解释，感兴趣的朋友一起看看\r\n\r\n- 使用windows API\r\n- 使用PIL中的ImageGrab模块\r\n\r\n下面对两者的特点和用法进行详细解释。\r\n\r\n**一、Python调用windows API实现屏幕截图**\r\n\r\n**好处是**\r\n\r\n- 灵活\r\n- 速度快\r\n\r\n**缺点是：\r\n**\r\n\r\n- 写法繁琐\r\n- 不跨平台\r\n\r\n```\r\nimport` `time``import` `win32gui, win32ui, win32con, win32api``def` `window_capture(filename):`` ``hwnd ``=` `0` `# 窗口的编号，0号表示当前活跃窗口`` ``# 根据窗口句柄获取窗口的设备上下文DC（Divice Context）`` ``hwndDC ``=` `win32gui.GetWindowDC(hwnd)`` ``# 根据窗口的DC获取mfcDC`` ``mfcDC ``=` `win32ui.CreateDCFromHandle(hwndDC)`` ``# mfcDC创建可兼容的DC`` ``saveDC ``=` `mfcDC.CreateCompatibleDC()`` ``# 创建bigmap准备保存图片`` ``saveBitMap ``=` `win32ui.CreateBitmap()`` ``# 获取监控器信息`` ``MoniterDev ``=` `win32api.EnumDisplayMonitors(``None``, ``None``)`` ``w ``=` `MoniterDev[``0``][``2``][``2``]`` ``h ``=` `MoniterDev[``0``][``2``][``3``]`` ``# print w,h　　　#图片大小`` ``# 为bitmap开辟空间`` ``saveBitMap.CreateCompatibleBitmap(mfcDC, w, h)`` ``# 高度saveDC，将截图保存到saveBitmap中`` ``saveDC.SelectObject(saveBitMap)`` ``# 截取从左上角（0，0）长宽为（w，h）的图片`` ``saveDC.BitBlt((``0``, ``0``), (w, h), mfcDC, (``0``, ``0``), win32con.SRCCOPY)`` ``saveBitMap.SaveBitmapFile(saveDC, filename)``beg ``=` `time.time()``for` `i ``in` `range``(``10``):`` ``window_capture(``\"haha.jpg\"``)``end ``=` `time.time()``print``(end ``-` `beg)\r\n```\r\n\r\n输出结果为0.375秒，也就是说通过windows API每次截图只需要0.0375s，真是快得一逼呀。\r\n\r\n**二、使用PIL的ImageGrab模块**\r\n\r\n```\r\nimport` `time``import` `numpy as np``from` `PIL ``import` `ImageGrab``# 每抓取一次屏幕需要的时间约为1s,如果图像尺寸小一些效率就会高一些``beg ``=` `time.time()``debug ``=` `False``for` `i ``in` `range``(``10``):`` ``img ``=` `ImageGrab.grab(bbox``=``(``250``, ``161``, ``1141``, ``610``))`` ``img ``=` `np.array(img.getdata(), np.uint8).reshape(img.size[``1``], img.size[``0``], ``3``)``end ``=` `time.time()``print``(end ``-` `beg)\r\n```\r\n\r\n输出结果为4.015秒，也就是说截取一次屏幕需要半秒钟，更何况此处只截取了窗口的一部分矩形区域。所以ImageGrab模块能用是能用，就是有点慢。\r\n\r\n**三、使用Selenium截图**\r\n\r\n使用Selenium只能进行WEB程序截图\r\n\r\n使用Selenium的各个浏览器需要制定驱动的位置，驱动下载地址参见Selenium 官网\r\n\r\n```\r\nfrom` `selenium ``import` `webdriver``import` `time``def` `capture(url, filename``=``\"capture.png\"``):`` ``browser ``=` `webdriver.Chrome(r``\"C:\\Users\\weidiao\\Desktop\\chromedriver_win32\\chromedriver.exe\"``)`` ``browser.set_window_size(``1200``, ``900``)`` ``browser.get(url) ``# Load page`` ``browser.execute_script(``\"\"\"`` ``(function () {``  ``var y = 0;``  ``var step = 100;``  ``window.scroll(0, 0);``  ``function f() {``  ``if (y < document.body.scrollHeight) {``   ``y += step;``   ``window.scroll(0, y);``   ``setTimeout(f, 50);``  ``} else {``   ``window.scroll(0, 0);``   ``document.title += \"scroll-done\";``  ``}``  ``}``  ``setTimeout(f, 1000);`` ``})();`` ``\"\"\"``)`` ``for` `i ``in` `range``(``30``):``  ``if` `\"scroll-done\"` `in` `browser.title:``   ``break``  ``time.sleep(``1``)`` ``beg ``=` `time.time()`` ``for` `i ``in` `range``(``10``):``  ``browser.save_screenshot(filename)`` ``end ``=` `time.time()`` ``print``(end ``-` `beg)`` ``browser.close()``capture(``\"//www.jb51.net\"``)\r\n```\r\n\r\n打印时间为3.033s，速度介于windows API和PIL ImageGrab模块之间。\r\n\r\n**ps：下面看下python基础===python实现截图**\r\n\r\npython实现全屏截图：\r\n\r\n```\r\nfrom` `PIL ``import` `ImageGrab``im ``=` `ImageGrab.grab()``im.save(``\'F:\\\\12.png\'``)\r\n```\r\n\r\n**总结**\r\n\r\n以上所述是小编给大家介绍的Python实现屏幕截图的两种方式，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！","timestamp":1590329650947},{"name":"132-控制桌面.md","path":"13-语言学习project/12-python3/132-控制桌面.md","content":"# 如何使用Python自动控制windows桌面\r\n\r\n 更新时间：2019年07月11日 08:27:50  作者：千锋Python唐唐君  [![img](https://www.jb51.net/skin/2018/images/text-message.png) 我要评论](https://www.jb51.net/article/165080.htm#comments)\r\n\r\n这篇文章主要介绍了如何使用Python自动控制windows桌面,文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值,需要的朋友可以参考下\r\n\r\n**前言**\r\n\r\n在使用PC时与PC交互的主要途径是看屏幕显示、听声音，点击鼠标和敲键盘等等。在自动化办公的趋势下，繁琐的工作可以让程序自动完成。比如自动化测试、自动下单交易等。很多软件除了可以GUI方式操作外还可以用CLI接口操作，不过当一些软件未提供CLI接口时，我们应该怎么办呢？我们还可以用程序控制桌面上的窗口、模拟点击鼠标或按下键盘等动作来释放自己。\r\n\r\npywin32是一个Python库，它为Python提供访问Windows API的扩展，提供了齐全的windows常量、接口、线程以及COM机制等等，安装后会自带一个pythonwin的IDE。接下来主要介绍下如何通过Python去操作windows桌面软件。\r\n\r\n**1、打开软件或文件**\r\n\r\n比如打开一个谷歌浏览器，或者打开一个word文件，如下所示：\r\n\r\n```\r\nwin32api.ShellExecute(``1``, ``\'open\'``,`` ``r``\'C:Program Files (x86)GoogleChromeApplicationchrome.exe\'``,`` ``\'``\', \'``\', ``1``)``win32api.ShellExecute(``1``, ``\'open\'``,`` ``r``\'C:UsersJayDesktopEnvironment Guider.docx\'``,`` ``\'``\', \'``\', ``1``)\r\n```\r\n\r\nwin32api.ShellExecute()的参数主要包括：\r\n\r\n- HWND：指定父窗口句柄\r\n- Operation：指定动作， 譬如\"edit\",“explore”,“open”,“find”,“print”,“NULL”\r\n- FileName：指定要打开的文件或程序\r\n- Parameters：指定打开程序所需参数\r\n- Directory：缺省目录\r\n- ShowCmd：打开选项，可选值:\r\n  - SW_HIDE = 0; {隐藏窗口，活动状态给令一个窗口}\r\n  - SW_SHOWNORMAL = 1; {用最近的大小和位置显示窗口, 同时令其进入活动状态}\r\n  - SW_NORMAL = 1; {用当前的大小和位置显示一个窗口，不改变活动窗口}\r\n  - SW_SHOWMINIMIZED = 2; {最小化窗口，并将其激活}\r\n  - SW_SHOWMAXIMIZED = 3; {最大化窗口，并将其激活}\r\n  - SW_MAXIMIZE = 3; {同 SW_SHOWMAXIMIZED}\r\n  - SW_SHOWNOACTIVATE = 4; {用最近的大小和位置显示一个窗口，不改变活动窗口}\r\n  - SW_SHOW = 5; {用当前的大小和位置显示一个窗口，令其进入活动状态}\r\n  - SW_MINIMIZE = 6; {最小化窗口, 不激活}\r\n  - SW_SHOWMINNOACTIVE = 7; {同 SW_MINIMIZE}\r\n  - SW_SHOWNA = 8; {用当前的大小和位置显示一个窗口，不改变活动窗口}\r\n  - SW_RESTORE = 9; {同 SW_SHOWNORMAL}\r\n  - SW_SHOWDEFAULT = 10; {同 SW_SHOWNORMAL}\r\n  - SW_MAX = 10; {同 SW_SHOWNORMAL}\r\n\r\n执行成功会返回应用程序句柄， 如果返回值 <= 32，则表示执行错误。返回值可能的错误有:\r\n\r\n- 0—— {内存不足}\r\n- 2—— {文件名错误}\r\n- 3—— {路径名错误}\r\n- 11—— {EXE 文件无效}\r\n- 26—— {发生共享错误}\r\n- 27—— {文件名不完全或无效}\r\n- 28—— {超时}\r\n- 29—— {DDE 事务失败}\r\n- 30—— {正在处理其他 DDE 事务而不能完成该 DDE 事务}\r\n- 31—— {没有相关联的应用程序}\r\n\r\n**2、查找窗体的句柄**\r\n\r\n在win32编程的世界里，包括窗口到文本框的所有控件都是窗体，所有的窗体都有独立的句柄。要操作任意一个窗体，都需要找到这个窗体的句柄。句柄是一个32位整数，在windows中用于标记对象。比如查找Snipping Tool和New Text Document.txt的句柄，如下所示：\r\n\r\n```\r\npara_hld ``=` `win32gui.FindWindow(``None``, ``\"Snipping Tool\"``)``# 1836416``para_hld ``=` `win32gui.FindWindow(``None``, ``\"New Text Document.txt - Notepad\"``)``# 591410\r\n```\r\n\r\nwin32gui.FindWindow()属于win32gui的模块，它自顶层窗口（也就是桌面）开始搜索条件匹配的窗体，并返回这个窗体的句柄。该函数仅能查找主窗口，因此无法搜索子窗口，也不区分大小写，未找到则返回0。\r\n\r\nwin32gui.FindWindow()的参数主要包括 (lpClassName=None, lpWindowName=None):\r\n\r\n- lpClassName：字符型，窗体的类名，可以在Spy++里找到\r\n- lpWindowName：字符型，窗口名，也就是标题栏上能看见的那个标题。\r\n\r\n![img](https://files.jb51.net/file_images/article/201907/2019710163928034.jpg?201961182715)\r\n\r\n**3、查找句柄的类名和标题**\r\n\r\n比如通过Snipping Tool和New Text Document.txt的句柄查找对应的类名和标题，如下所示：\r\n\r\n```\r\ntitle ``=` `win32gui.GetWindowText(``1836416``)``classname ``=` `win32gui.GetClassName(``1836416``)``print` `\"windows handler:{0}; title:{1}; classname:{2}\"``.``format``(``1836416``, title, classname)\r\n```\r\n\r\n打印显示如下：\r\n\r\n```\r\nwindows handler:``1836416``; title:Snipping Tool; classname:Microsoft``-``Windows``-``Tablet``-``SnipperToolbar``title ``=` `win32gui.GetWindowText(``591410``)``classname ``=` `win32gui.GetClassName(``591410``)``print` `\"windows handler:{0}; title:{1}; classname:{2}\"``.``format``(``591410``, title, classname)\r\n```\r\n\r\n打印显示如下：\r\n\r\n```\r\nwindows handler:``591410``; title:New Text Document.txt ``-` `Notepad; classname:Notepad\r\n```\r\n\r\n**4、调用win32gui.EnumWindows()枚举所有窗口句柄**\r\n\r\n直到最后一个顶层窗口被枚举则停止枚举过程。如下所示：\r\n\r\n```\r\nhWndList ``=` `[]``win32gui.EnumWindows(``lambda` `hWnd, param: param.append(hWnd), hWndList)``print` `hWndList``for` `hwnd ``in` `hWndList:`` ``title ``=` `win32gui.GetWindowText(hwnd)`` ``print` `title\r\n```\r\n\r\n打印显示如下：\r\n\r\n```\r\n[852802L, 65946L, 65928L, 65930L, 65900L, 65920L, 65924L, 65922L, 65944L, 65892L, 65886L, 6817870L, 65960L, 6031410L, …… 66052L, 65734L]``……``New Text Document.txt - Notepad``Snipping Tool``DDE Server Window``OfficePowerManagerWindow``OfficePowerManagerWindow``DDE Server Window``GDI+ Window``Global Internet Access``……\r\n```\r\n\r\n**5、win32gui.SetForegroundWindow()函数将指定窗体设置到最顶层，并且激活该窗口**\r\n\r\n构造函数为：win32gui.SetWindowPos（HWN hWnd，HWND hWndlnsertAfter, int X，int Y, int cx，int cy, UNIT．Flags）\r\n\r\n关于win32gui.SetForegroundWindow(para_hld)报错的问题：\r\n\r\n```\r\npywintypes.error: (``0``, ‘SetForegroundWindow``\', ‘No error message is available\'``)\r\n```\r\n\r\n其实调用SetForegroundWindow()会有很多限制，参考官网的[说明](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setforegroundwindow)\r\n\r\n![img](https://files.jb51.net/file_images/article/201907/2019710163928035.jpg?201961182732)\r\n\r\n因此调用SetForegroundWindow()时需要查看当前运行的条件是否符合上述要求，此处在调用SetForegroundWindow()前事先发送一个键盘event来解决该问题。\r\n\r\n例程如下所示：\r\n\r\n```\r\nwin32api.keybd_event(``13``, ``0``, ``0``, ``0``) ``#``win32gui.SetForegroundWindow(para_hld)\r\n```\r\n\r\n**6、win32api.keybd_event()模拟键盘输入**\r\n\r\n构造函数如下所示：\r\n\r\n```\r\nwin32api.keybd_event (bVk, bScan, dwFlags, dwExtraInfo)\r\n```\r\n\r\n- bVk：虚拟键码（键盘键码对照表见附录）；\r\n- bScan：硬件扫描码，一般设置为0即可；\r\n- dwFlags：函数操作的一个标志位，如果值为KEYEVENTF_EXTENDEDKEY则该键被按下，也可设置为0即可，如果值为KEYEVENTF_KEYUP则该按键被释放；\r\n- dwExtraInfo：定义与击键相关的附加的32位值，一般设置为0即可。\r\n\r\n按下enter键后抬起的例程如下所示：\r\n\r\n```\r\nwin32api.keybd_event(``13``,``0``,``0``,``0``) ``# enter``win32api.keybd_event(``13``,``0``,win32con.KEYEVENTF_KEYUP,``0``) ``#释放按键\r\n```\r\n\r\n**7、模拟鼠标输入**\r\n\r\n直接给出例程，如下所示：\r\n\r\n```\r\n# 获取鼠标当前位置的坐标``print` `win32api.GetCursorPos()``# 将鼠标移动到坐标处``win32api.SetCursorPos((``100``, ``100``))``# 左点击``win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, ``100``, ``100``, ``0``, ``0``)``time.sleep(``2``)``win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, ``100``, ``100``, ``0``, ``0``)\r\n```\r\n\r\n**8、关于鼠标键盘的操作还可以使用PyUserInput库**\r\n\r\nPyUserInput是一个使用python的跨平台的操作鼠标和键盘的模块，使用非常方便。支持的平台及依赖如下：\r\n\r\n- Linux - Xlib\r\n- Mac - Quartz, AppKit\r\n- Windows - pywin32, pyHook\r\n\r\n实例化一个鼠标和键盘对象，如下所示：\r\n\r\n```\r\nfrom` `pymouse ``import` `PyMouse``from` `pykeyboard ``import` `PyKeyboard``m ``=` `PyMouse()``k ``=` `PyKeyboard()``操作鼠标和键盘，如下所示：``m.click(``190``,``70``,``1``)``#移动并且在xy位置点击``time.sleep(``2``)``m.click(``190``, ``200``, ``1``)``#移动并且在xy位置点击``time.sleep(``2``)``k.tap_key(k.function_keys[``5``])``#–点击功能键F5\r\n```\r\n\r\n以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。","timestamp":1590329650947},{"name":"133-控制键盘和鼠标pyautoGUI.md","path":"13-语言学习project/12-python3/133-控制键盘和鼠标pyautoGUI.md","content":"# Python PyAutoGUI模块控制鼠标和键盘实现自动化任务详解\r\n\r\n 更新时间：2018年09月04日 09:40:31  作者：斗大的熊猫  [![img](https://www.jb51.net/skin/2018/images/text-message.png) 我要评论](https://www.jb51.net/article/146786.htm#comments)\r\n\r\n这篇文章主要介绍了Python PyAutoGUI模块控制鼠标和键盘实现自动化任务,结合实例形式详细分析了pyautogui模块的安装、导入以及针对鼠标与键盘的各种常见响应操作实现技巧,需要的朋友可以参考下\r\n\r\n本文实例讲述了Python PyAutoGUI模块控制鼠标和键盘实现自动化任务。分享给大家供大家参考，具体如下：\r\n\r\nPyAutoGUI是用Python写的一个模块，使用它可以控制鼠标和键盘。\r\n\r\n利用它可以实现自动化任务，再也不用担心有重复枯燥的任务了。\r\n\r\n**pyautogui模块的功能：**\r\n\r\n- 移动鼠标、点击左右键和滚轮\r\n- 发送虚拟按键\r\n\r\n**# 安装pyautogui**\r\n\r\n这个模块支持Windows, Mac OS X 和 Linux。\r\n\r\n根据系统不同，你可能需要安装一些依赖。\r\n\r\n**Linux系统（Debian系列）：**\r\n\r\n```\r\n$ sudo apt``-``get install python3``-``pip``$ sudo pip3 install python3``-``xlib``$ sudo apt``-``get install scrot``$ sudo apt``-``get install python3``-``tk``$ ``and` `sudo apt``-``get install python3``-``dev\r\n```\r\n\r\nScrot是pyautogui使用的截图工具。\r\n\r\n**Mac OS X：**\r\n\r\n```\r\n$ sudo pip3 install pyobjc``-``framework``-``Quartz``$ sudo pip3 install pyobjc``-``core``$ sudo pip3 install pyobjc``$ sudo pip3 install pillow\r\n```\r\n\r\nOS X上的Python3可以通过brewhome或port安装。\r\n\r\nWindows系统不用安装依赖。\r\n\r\n安装完依赖之后，安装pyautogui：\r\n\r\n```\r\n$ sudo pip3 install pyautogui``# Windows``pip install pyautogui\r\n```\r\n\r\n导入模块测试：\r\n\r\n```\r\nimport` `pyautogui\r\n```\r\n\r\n**# 准备**\r\n\r\nPython移动鼠标、点击键盘非常快，有可以导致其他应用出现问题。如果出现了问题，而鼠标还一直瞎晃，在这种情况下，你很难点击窗口退出程序。\r\n\r\n两种解决方法：\r\n\r\n**#1 pyautogui的暂停和Fail-Safe**\r\n\r\n你可以告诉你的Python脚本在每执行一个函数后暂停几秒钟，这样你就有了几秒种的控制权。\r\n\r\n```\r\nimport` `pyautogui``pyautogui.PAUSE ``=` `1.5\r\n```\r\n\r\nfail-safe：当鼠标移动到屏幕的左上角时触法PyAutoGUI的FailSafeException异常。你可以使用try except语句处理异常，或直接让脚本异常退出。如果你想终止程序，只要你快速的把鼠标移动到屏幕左上角就可以了。\r\n\r\n```\r\nimport` `pyautogui``pyautogui.FAILSAFE ``=` `True\r\n```\r\n\r\n**#2 注销系统**\r\n\r\n这个方法比较粗暴直接，不建议使用。Windows和Linux的快捷键是：Ctrl–Alt–Del；Mac OS X的快捷键是Command–Shift–Option-Q。\r\n\r\n**# 移动鼠标**\r\n\r\nPyAutoGUI使用x，y坐标，屏幕左上角坐标是(0, 0)。\r\n\r\n1366×768分辨率：\r\n\r\n ![img](D:\\Typora_pic\\201894100059717.png)\r\n\r\n使用`pyautogui.size()`函数获得屏幕的分辨率：\r\n\r\n```\r\nimport` `pyautogui``pyautogui.size()``# (1366, 768)``width, height ``=` `pyautogui.size()\r\n```\r\n\r\n![img](D:\\Typora_pic\\20189493755842.png) \r\n\r\nOk，现在我们得到了屏幕的分辨率，下面我们来控制鼠标移动。\r\n\r\n`moveTo`函数，绝对坐标。(block.py)：\r\n\r\n```\r\nimport` `pyautogui``for` `i ``in` `range``(``10``):``  ``pyautogui.moveTo(``300``, ``300``, duration``=``0.25``)``  ``pyautogui.moveTo(``400``, ``300``, duration``=``0.25``)``  ``pyautogui.moveTo(``400``, ``400``, duration``=``0.25``)``  ``pyautogui.moveTo(``300``, ``400``, duration``=``0.25``)\r\n```\r\n\r\n执行：\r\n\r\n```\r\n$ python3 block.py\r\n```\r\n\r\n上面代码让鼠标顺时针移动，并划10次方框。\r\n\r\n划圆：\r\n\r\n```\r\nimport` `pyautogui``import` `math``width, height ``=` `pyautogui.size()``r ``=` `250` `# 圆的半径``# 圆心``o_x ``=` `width``/``2``o_y ``=` `height``/``2``pi ``=` `3.1415926``for` `i ``in` `range``(``10``): ``# 转10圈`` ``for` `angle ``in` `range``(``0``, ``360``, ``5``): ``# 利用圆的参数方程`` ``X ``=` `o_x ``+` `r ``*` `math.sin(angle``*``pi``/``180``)`` ``Y ``=` `o_y ``+` `r ``*` `math.cos(angle``*``pi``/``180``)`` ``pyautogui.moveTo(X, Y, duration``=``0.1``)\r\n```\r\n\r\n`moveRel()`函数，相对坐标。以当前鼠标所在位置为基点：\r\n\r\n```\r\nimport` `pyautogui``for` `i ``in` `range``(``10``):`` ``pyautogui.moveRel(``100``, ``0``, duration``=``0.25``)`` ``pyautogui.moveRel(``0``, ``100``, duration``=``0.25``)`` ``pyautogui.moveRel(``-``100``, ``0``, duration``=``0.25``)`` ``pyautogui.moveRel(``0``, ``-``100``, duration``=``0.25``)\r\n```\r\n\r\n获得鼠标所在坐标：\r\n\r\n```\r\nimport` `pyautogui``x, y ``=` `pyautogui.position()\r\n```\r\n\r\n实时获得鼠标位置坐标：\r\n\r\n```\r\nimport` `pyautogui``try``:`` ``while` `True``:``  ``x, y ``=` `pyautogui.position()``  ``print``(x,y)``except` `KeyboardInterrupt:`` ``print``(``\'\\nExit.\'``)\r\n```\r\n\r\n**# 鼠标点击、拖拽和滚轮**\r\n\r\n**鼠标点击**\r\n\r\n使用`click()`函数发送虚拟鼠标点击，默认情况下在鼠标所在的位置点击左键。函数原型：\r\n\r\n```\r\npyautogui.click(x``=``cur_x, y``=``cur_y, button``=``\'left\'``)\r\n```\r\n\r\n- x，y是要点击的位置，默认是鼠标当前位置\r\n- button是要点击的按键，有三个可选值：‘left\', ‘middle\', ‘right\'。\r\n\r\n要在当前位置点击右键：\r\n\r\n```\r\nimport` `pyautogui``pyautogui.click(button``=``\'right\'``)\r\n```\r\n\r\n要在指定位置点击左键：\r\n\r\n```\r\nimport` `pyautogui``pyautogui.click(``100``, ``100``)\r\n```\r\n\r\nclick函数完成了一次鼠标点击。一次完整的点击包括两部分，按下`mouseDown()`和弹起`mouseUp()`。上面这两个函数参数和click函数一样，其实click函数只是简单的封装了`mouseDown()`和`mouseUp()`函数。\r\n\r\n其他函数：\r\n\r\n- pyautogui.doubleClick()：鼠标双击，其实就是执行两次click()函数。\r\n- pyautogui.rightClick()：右击\r\n- pyautogui.middleClick()：中击\r\n\r\n**鼠标拖拽**\r\n\r\n拖拽的意思是：按下鼠标键并拖动鼠标。PyAutoGUI提供了两个函数：`dragTo()` 和 `dragRel()`。它的参数和`moveTo()` 和 `moveRel()` 一样。\r\n\r\n注意：duration时间不能太短，拖动太快有些系统会吃不消。\r\n\r\n使用它你可以在简单的画图程序中绘制复杂的图形。\r\n\r\n![img](D:\\Typora_pic\\20189494304188.png)\r\n\r\n**滚轮**\r\n\r\n使用函数`scroll()`，它只接受一个整数。如果值为正往上滚，值为负往下滚。\r\n\r\n```\r\npyautogui.scroll(``200``)\r\n```\r\n\r\n**# 定位某个按钮的位置**\r\n\r\npyautogui有截屏功能。你可能会疑惑，它怎么还带截屏？\r\n\r\n假如你有一个按钮要10秒种点击一下，这个任务使用上面介绍的函数可以轻松实现。但是我们假设你每次点击这个按钮它都会变换一个位置（随机），这时你该怎么办？下面我们就来解决这个问题。\r\n\r\n首先看一下怎么使用pyautogui截屏：\r\n\r\n```\r\nimport` `pyautogui``im ``=` `pyautogui.screenshot()``# 获得某个坐标的像素``im.getpixel((``50``, ``200``))``# (30, 132, 153)``# 判断屏幕坐标的像素是不是等于某个值``pyautogui.pixelMatchesColor(``50``, ``200``, (``30``, ``132``, ``153``))``# True\r\n```\r\n\r\n小测试：实时获得鼠标所在位置的像素值。\r\n\r\n现在我们来解决前面提出的问题。问题的关键是怎么找到按钮所在的坐标。其实很简单，首先对你要点击的按钮截个图，就叫button.png吧。然后使用`locateOnScreen`函数找到按钮所在的位置：\r\n\r\n```\r\nimport` `pyautogui``pyautogui.locateOnScreen(``\'button.png\'``)``# (643, 745, 70, 29)\r\n```\r\n\r\nlocateOnScreen其实就是简单的颜色对比，如果有一个像素不匹配，它就会返回None。这个函数返回了匹配图形的坐标，找到中间点：\r\n\r\n```\r\nx, y ``=` `pyautogui.center((``643``, ``745``, ``70``, ``29``)) ``# 获得中心点``pyautogui.click(x, y)\r\n```\r\n\r\n`locateAllOnScreen()`：找到所有匹配的位置坐标。\r\n\r\n**# 键盘按键**\r\n\r\n前面是鼠标相关，下面我们看看键盘。\r\n\r\n**输入字符串**\r\n\r\n`pyautogui.typewrite()`：\r\n\r\n```\r\nimport` `pyautogui``pyautogui.click(``100``, ``100``)``pyautogui.typewrite(``\'Hello world!\'``)\r\n```\r\n\r\n![img](D:\\Typora_pic\\20189494638174.png)\r\n\r\n上面的字符串是一次输入，为了唬人可以延迟输入：\r\n\r\n```\r\ntypewrite(``\'Hello world!\'``, ``0.25``)\r\n```\r\n\r\nPyAutoGUI输入单个字符还可以，但是一些特殊字符怎么办呢？例如上面输入完Hello World，然后换行继续输入。\r\n\r\nPyAutoGUI键盘表：\r\n\r\n\r\n\r\n| ‘enter\' (或‘return\' 或 ‘\\n\')           | 回车                                   |\r\n| -------------------------------------- | -------------------------------------- |\r\n| ‘esc\'                                  | ESC键                                  |\r\n| ‘shiftleft\', ‘shiftright\'              | 左右SHIFT键                            |\r\n| ‘altleft\', ‘altright\'                  | 左右ALT键                              |\r\n| ‘ctrlleft\', ‘ctrlright\'                | 左右CTRL键                             |\r\n| ‘tab\' (‘\\t\')                           | TAB键                                  |\r\n| ‘backspace\', ‘delete\'                  | BACKSPACE 、DELETE键                   |\r\n| ‘pageup\', ‘pagedown\'                   | PAGE UP 和 PAGE DOWN键                 |\r\n| ‘home\', ‘end\'                          | HOME 和 END键                          |\r\n| ‘up\', ‘down\', ‘left\', ‘right\'          | 箭头键                                 |\r\n| ‘f1\', ‘f2\', ‘f3\'….                     | F1…….F12键                             |\r\n| ‘volumemute\', ‘volumedown\', ‘volumeup\' | 有些键盘没有                           |\r\n| ‘pause\'                                | PAUSE键                                |\r\n| ‘capslock\', ‘numlock\', ‘scrolllock\'    | CAPS LOCK, NUM LOCK, 和 SCROLL LOCK 键 |\r\n| ‘insert\'                               | INS或INSERT键                          |\r\n| ‘printscreen\'                          | PRTSC 或 PRINT SCREEN键                |\r\n| ‘winleft\', ‘winright\'                  | Win键                                  |\r\n| ‘command\'                              | Mac OS X command键                     |\r\n\r\n\r\n\r\n```\r\nimport` `pyautogui``pyautogui.click(``100``, ``100``)``pyautogui.typewrite(``\'Hello world!\'``, ``0.25``)``pyautogui.typewrite([``\'enter\'``, ``\'a\'``, ``\'b\'``, ``\'left\'``, ``\'left\'``, ``\'X\'``, ``\'Y\'``], ``\'0.25\'``)\r\n```\r\n\r\n![img](D:\\Typora_pic\\201894100259561.png)\r\n\r\n**按键的按下和释放**\r\n\r\n和鼠标按键非常类似。\r\n\r\n- keyDown()：按下某个键\r\n- keyUp()：松开某个键\r\n- press()：一次完整的击键，前面两个函数的组合。\r\n\r\nalt＋F4：\r\n\r\n```\r\npyautogui.keyDown(``\'altleft\'``);``pyautogui.press(``\'f4\'``);``pyautogui.keyUp(``\'altleft\'``)\r\n```\r\n\r\n也可以直接使用热键函数：\r\n\r\n```\r\npyautogui.hotkey(``\'altleft\'``, ``\'f4\'``)\r\n```\r\n\r\n关于PyAutoGUI的介绍就到这里，如果你使用它做了什么好玩的自动化脚本，欢迎留言。\r\n\r\n更多关于Python相关内容感兴趣的读者可查看本站专题：《[Python数据结构与算法教程](https://www.jb51.net/Special/663.htm)》、《[Python Socket编程技巧总结](https://www.jb51.net/Special/648.htm)》、《[Python函数使用技巧总结](https://www.jb51.net/Special/642.htm)》、《[Python字符串操作技巧汇总](https://www.jb51.net/Special/636.htm)》、《[Python入门与进阶经典教程](https://www.jb51.net/Special/520.htm)》及《[Python文件与目录操作技巧汇总](https://www.jb51.net/Special/516.htm)》\r\n\r\n希望本文所述对大家Python程序设计有所帮助。\r\n\r\n#### 您可能感兴趣的文章:\r\n\r\n- [Python pyautogui模块实现鼠标键盘自动化方法详解](https://www.jb51.net/article/180619.htm)\r\n- [python PyAutoGUI 模拟鼠标键盘操作和截屏功能](https://www.jb51.net/article/166879.htm)\r\n- [使用 python pyautogui实现鼠标键盘控制功能](https://www.jb51.net/article/166877.htm)\r\n- [Python使用pyautogui模块实现自动化鼠标和键盘操作示例](https://www.jb51.net/article/146791.htm)\r\n- [pyautogui自动化控制鼠标和键盘操作的步骤](https://www.jb51.net/article/183928.htm)","timestamp":1590329650947},{"name":"134-继承super.md","path":"13-语言学习project/12-python3/134-继承super.md","content":"# [python 中的super()继承，搜索广度为先](https://www.cnblogs.com/shiqi17/p/9469721.html)\r\n\r\n一、python中类的继承\r\n\r\n1.1 单继承\r\n\r\n在python 中我们可以这样来定义一个类：及继承它的子类\r\n\r\n```python\r\nclass Father:\r\n    def __init__(self, mes):       #1 父类的init构造方法\r\n        print(\'From Father. form {}\'.format(mes))\r\n\r\nclass Child(Father):\r\n    def __init__(self, message, personal):     #2 子类的构造方法\r\n        Father.__init__(self, message)       #3 继承父类构造方法\r\n        print(\"I\'m child. From {}\".format(personal))\r\n        \r\nc = Child(\'儿子\', \'拼爹\')\r\n\r\n#执行结果为\r\nFrom Father. form 儿子     #4\r\nI\'m child. From 拼爹      #5\r\n```\r\n\r\n在这个列子中，子类 Child 继承父类 Father，并在#2 自己的构造方法#3处中继承父类的构造方法，先执行完#3处继承父类#1的构造放方法得到结果#4，然后继续执行自身构造方法输出#5\r\n\r\n1.2 help(super) 看下super有些什么\r\n\r\n```python\r\n>>> help(super)\r\n\r\nHelp on class super in module builtins:\r\n\r\nclass super(object)\r\n |  super() -> same as super(__class__, <first argument>)\r\n |  super(type) -> unbound super object\r\n |  super(type, obj) -> bound super object; requires isinstance(obj, type)\r\n |  super(type, type2) -> bound super object; requires issubclass(type2, type)\r\n |  Typical use to call a cooperative superclass method:\r\n |  class C(B):\r\n |      def meth(self, arg):\r\n |          super().meth(arg)\r\n |  This works for class methods too:\r\n |  class C(B):\r\n |      @classmethod\r\n |      def cmeth(cls, arg):\r\n |          super().cmeth(arg)\r\n |  \r\n |  Methods defined here:\r\n |  \r\n #...........后面还有很多,没什么好讲的，这儿就够了\r\n```\r\n\r\n1.3 super的使用\r\n\r\n1. super() #另一个写法 super(\'class_name\', self)\r\n\r\n2. super(type) \r\n3. super(type, obj) \r\n4. super(type, type2)\r\n\r\n推荐第一种写法，方便\r\n\r\n```\r\nclass A:\r\n  def __init__(self):\r\n    print(\"From A\")\r\nclass B(A):\r\n  def __init__(self):\r\n    super().__init__()     #1 这儿还有个写法super(B, self).__init__()\r\n    print(\"From B\"\r\n\r\nb = B()\r\n#结果为\r\nFrom A\r\nFrom B\r\n```\r\n\r\n单继承下乍看没区别，的确。可是当考虑到多继承时\r\n\r\n二、多继承\r\n\r\n2.1 多继承下深度为先\r\n\r\n```\r\nclass A:\r\n    def __init__(self):\r\n        print(\"From A\")\r\n        print(\"END A\")\r\n\r\nclass B(A):\r\n    def __init__(self):\r\n        print(\"From B\")\r\n        A.__init__(self)\r\n        print(\"END B\")\r\n\r\nclass C(A):\r\n    def __init__(self):\r\n        print(\"From C\")\r\n        A.__init__(self)\r\n        print(\"END C\")\r\n\r\nclass D(A):\r\n    def __init__(self):\r\n        print(\"From D\")\r\n        A.__init__(self)\r\n        print(\"END D\")\r\n\r\nclass E(B, C, D):\r\n    def __init__(self):\r\n        print(\"From E\")\r\n        B.__init__(self)\r\n        C.__init__(self)\r\n        D.__init__(self)\r\n        print(\"END E\")\r\n\r\nE()\r\n\r\n#结果为\r\nFrom E\r\nFrom B\r\nFrom A\r\nEND A\r\nEND B\r\nFrom C\r\nFrom A\r\nEND A\r\nEND C\r\nFrom D\r\nFrom A\r\nEND A\r\nEND D\r\nEND E\r\n```\r\n\r\n首先可以看到，E当中继承顺序是 B、C、D，\r\n然后搜索顺序则为先到第一个继承的E-->B-->A -->C-->A -->D-->A 深度为先。然后结果大家也看到了，这样的继承方式==会导致A被执行很多遍==。\r\n\r\n2.2、super继承 广度为先\r\n\r\nsuper的使用方式有两种: 1. super()__init__() 2. super(类名, self).__init__()\r\n\r\n```\r\nclass A:\r\n    def __init__(self):\r\n        print(\"From A\")\r\n        print(\"END A\")\r\n\r\nclass B(A):\r\n    def __init__(self):\r\n        print(\"From B\")\r\n        super().__init__()\r\n        print(\"END B\")\r\n\r\nclass C(A):\r\n    def __init__(self):\r\n        print(\"From C\")\r\n        super(C, self).__init__()\r\n        print(\"END C\")\r\n\r\nclass D(A):\r\n    def __init__(self):\r\n        print(\"From D\")\r\n        super(D, self).__init__()\r\n        print(\"END D\")\r\n\r\nclass E(B, C, D):\r\n    def __init__(self):\r\n        print(\"From E\")\r\n        super().__init__()\r\n        print(\"END E\")\r\n\r\nE()  #1 继承顺序\r\n\r\nprint(E.__mro__)     #2 查看super类里面维护的继承顺序\r\n\r\n#-结果为：\r\n\r\nFrom E\r\nFrom B\r\nFrom C\r\nFrom D\r\nFrom A\r\nEND A\r\nEND D\r\nEND C\r\nEND B\r\nEND E\r\n(<class \'__main__.E\'>, <class \'__main__.B\'>, <class \'__main__.C\'>, <class \'__main__.D\'>, <class \'__main__.A\'>, <class \'object\'>) #3\r\n```\r\n\r\n可以看到#1处E(B, C, D)的继承查找顺序就为 E-->B-->C-->D-->A 通过#2处\r\n**E.__mro__属性也可以看到，super自己维护的顺序为#3最后的列表 E-->B-->C-->D-->A--object（所有新式类的基类）**\r\n是一样的。因为它就是按照__mro__来寻找的","timestamp":1590329650947},{"name":"135-装饰器.md","path":"13-语言学习project/12-python3/135-装饰器.md","content":"六、装饰器\r\n\r\n装饰器是一个==以函数作为参数并返回一个替换函数==的可执行函数。\r\n\r\n```python\r\n>>> def out_fun(fun):         #1接受函数作为参数\r\n...     def inner(a, b= 0, *args):\r\n...         print(\'装饰器先运行0.0\')\r\n...         result = fun(a) + b         #2运行传过来的被装饰函数\r\n...         print(\'装饰后结果为：\',result)\r\n...         return result\r\n...     return inner\r\n>>> def foo(x):         #3定义foo函数\r\n...     print(\'---------------\\n这是被装饰函数\')\r\n...     result = 2*x\r\n...     print(\'被装饰函数执行结果为:{}\\n--------------\'.format(result))\r\n...     return 2*x\r\n>>> decorate_foo = out_fun(foo)         #4将foo函数作为jout_fun参数执行out_fun\r\n>>> foo =decorate_foo         #把装饰过的foo函数decorate_foo 重赋值给foo，再调用foo()\r\n>>> foo(2)\r\n装饰器先运行0.0\r\n---------------\r\n这是被装饰函数\r\n被装饰执行结果为:4\r\n---------------\r\n装饰后结果为： 2\r\n```\r\n\r\n现在来理解下这段程序，#1处定义了一个函数，他只接受函数作为参数,#2出运行传过来的被装饰函数，#3定义了一个函数，#4处将#3定义的foo作为参数传给out_fun(foo)得到被装饰后decorate_foo，然后再将装饰后的函数重新赋值给foo,然后当你再次运行foo函数的时候，永远都是得到被装饰后的结果了。\r\n讲到这儿就说个实际应用列子吧！\r\n如汽车在公路上行驶，按照某地交通规则，在国道上限速最高80迈，无下限，高速公路上最低60迈最高120迈。\r\n我们原始程序，通过测速传感器传来的参数计算出汽车当前速度，并返回该速度。\r\n\r\n```python\r\n>>> status = 1\r\n>>> def car_speed(angular_speed, radius = 0.35)  #根据传来的角速度参数，以及半径计算出当前速度\r\n...     current_speed = angular_speed*radius*3.6\r\n...     return current_speed\r\n>>> \r\n>>> def slowdown():\r\n...     pass   #假设调用此函数是调用刹车、减速系统，会减慢汽车速度\r\n>>>\r\n>>> def decorate_fun(fun):\r\n...     def inner(*args, **kwargs):\r\n...         current_speed = fun(args[0]) if len(args) = 1 else fun(args[0], radius = args[1])\r\n...         if current_speed >110:\r\n...             sys.stdout.write(\'您已超速！\')\r\n...             sys.stdout.flush()\r\n...         elif current_speed > 160:\r\n...             sys.stdout.write(\'超速50%系统已限速，请注意安全\')\r\n...             sys.stdout.flush()\r\n...             slowdown()\r\n...         elif current_speed < 60:\r\n...             sys.stdout.write(\'该路段限速60，请注意\')\r\n...             sys.stdout.flush()\r\n...         else: pass\r\n...         return current_speed\r\n...     return inner\r\n>>> \r\n>>> decorator_car_speed = decorate_fun(car_speed)\r\n>>> decorato_car_speed(120)\r\n您已超速！\r\n```\r\n\r\n这段程序，当汽车在国道等非限速区域是，直接调用car_speed()函数就可以得到速度，而当行驶上高速公路后，就存在边界值问题，我们可以使用装饰后的decorate_car_speed()函数来处理。\r\n\r\n \r\n\r\n七、装饰器符号@ 的应用\r\n\r\n 通过前面已经了解了装饰器原理了，这儿就简单说下@ 的应用。@ 只是python的一种语法糖而已，让程序看起更美观，简洁\r\n\r\n```\r\n>>> def decorator_foo(fun):\r\n...     def inner(*args, **kwargs):\r\n...         fun(*args, **kwargs)\r\n...         pass\r\n...     return inner\r\n>>>\r\n>>> @decorator_foo         #1\r\n>>> def foo(*args, **kwargs):         #2\r\n...     pass\r\n>>>\r\n```\r\n\r\n在#1处@decorator_foo 使用@符号+装饰器函数，在被装饰函数的上方，记住一定要正上方挨着不能空行，就等于前面所学的`decorator = decorator_foo(foo)` + `foo = decorator()` 这样以后你调用foo就是调用的被装饰后的foo了\r\n\r\n八、讲一个厉害的装饰器应用\r\n\r\n \\- 情形和需求是这样的，比如我在django view 下做用户验证（不用session），有home函数处理普通用户请求，index处理管理员请求，bbs返回论坛请求，member处理会员请求。\r\n\r\n- 当然我们如果在每一个函数内都做一次验证，那代码重复就太多了，所以选择用装饰器，不失为一个好方法。可是现在们要求，根据不同的函数，home、bbs、member都在本地数据库验证,而index做ldap验证，意思就是我们要在一个装饰器里面，根据不同的函数做不同的验证。\r\n\r\n一般的验证：\r\n\r\n```\r\ndef _authentication(r):\r\n    print(\'假设使用这个函数做本地用户认证，过了返回True，错误返回False\')\r\n    return #返回验证结果\r\n\r\ndef auth(fun):         #装饰器函数\r\n    def wrapper(request, *args, **kwargs):\r\n        if _authentication(request):         #调用验证函数\r\n            result = fun(request)\r\n            return result\r\n        else:\r\n            return \'用户名或密码错了，重新登录吧！\'\r\n    return wrapper\r\n\r\n@auth\r\ndef index(request):\r\n    pass\r\n\r\n@auth\r\ndef home(request):\r\n    pass\r\n\r\n@auth\r\ndef bbs(request):\r\n    pass\r\n\r\n@auth\r\ndef member(request):\r\n    pass\r\n```\r\n\r\n全部代码我就不写了，太多复杂了，就用伪代码，逻辑描述来代替了。\r\n可以看出来，我们这个函数可以实现用户验证功能，不管你使用cookie也好，去本地数据库取数据也罢。但是我们上面说的需求，把index来的请求分离出来，做ldap验证，显然这样的装饰器是没法做到的。无法识别谁来的请求。\r\n\r\n@装饰器还提供了一功能，能解决这个问题，往下看：\r\n\r\n```\r\ndef _authentication(r):\r\n    print(\'假设使用这个函数做本地用户认证，过了返回True，错误返回False\')\r\n    return #返回验证结果\r\n\r\ndef _ldap(r):\r\n    print(\'ldap验证\')    \r\n    return  #返回ldap验证结果\r\n\r\ndef auth(souce_type):\r\n    #这儿的souce_type参数就是@auth(v)运行时传过来的参数\r\n    def outer(fun):    \r\n        def wrapper(request, *args, **kwargs):\r\n            if souce_type == \'local\':     #* 1 如果请求来源标记是\'local\'就本地验证\r\n                if _authentication(request):\r\n                    result = fun(request)\r\n                    return result\r\n                else:\r\n                    return \'用户名或密码错了，重新登录吧！\'\r\n            elif souce_type == \'ldap\':    #* 1 如果请求来源标记是\'ldap\'就ldap验证\r\n                if _ldap(request):\r\n                    return fun(request)\r\n                else:\r\n                    return \'用户名或密码错了，重新登录吧！\'\r\n        return wrapper\r\n    return outer\r\n@auth(souce_type = \'ldap\')     #3 装饰\r\ndef index(request):\r\n    pass\r\n\r\n@auth(souce_type = \'local\')         #4\r\ndef home(request):\r\n    pass\r\n```\r\n\r\n- 注意#3，#4处，我们把auth(\'parameter\')加参数运行了一次，而装饰器函数auth里面进行了三层嵌套，auth---->outer----->wrapper，你可以这样理解，原来的@auth @符号会把后面的内容auth运行一次直接就返回了wrapper， 现在，我们自己把auth(\'parameter\')加参数运行了一次得到outer，@auth(parameter)就等同于 @outer，@符号把后面的outer运行一次后再得到wrapper并赋给被修饰函数，而函数souce_type来源也被我们带进了装饰器。\r\n\r\n人生还有意义。那一定是还在找存在的理由","timestamp":1590329650947},{"name":"136-迭代器.md","path":"13-语言学习project/12-python3/136-迭代器.md","content":"# [python 生成器、列表解析式、yield、迭代器](https://www.cnblogs.com/shiqi17/p/9348581.html)\r\n\r\n开局一张图总结关系\r\n\r\n![](D:\\Typora_pic\\1226829-20180808170030116-52783735.png)\r\n\r\n一、列表解析式\r\n\r\n我们习惯生成列表通过list = [1, 2, 3]的方式。还有一种很方便的列表生成方式 list = [a*2 for a in range(10)]，或者list = [fun(a) for a in range(10)]都是可以的\r\n\r\n```\r\n>>> L1 = [a*2 for a in range(10)]\r\n>>> L1\r\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\r\n```\r\n\r\n如果只是生成一个100元素，1000元素的列表，那很简单，可是你需要==一个100万，一亿个元素==的列表时，这样去生成列表，你要知道，它是实实在在的存在你的内存里面，==这么大一个列表，过于耗费内存==。\r\n那么有没有什么好的解决办法呢？------------>生成器\r\n\r\n二、生成器\r\n\r\n按照某种算法推算出列表元素，可以==一直一边循环一边计算出列表元素==的机制，称之为生成器：generator。一个简单生成器构造：生成器把中括号[]换成小括号()就好了， 这样就得到了一个生成器,\r\n\r\n```python\r\n# [.....]生成列表，(.....)生成生成器\r\n# 列表是L = [a*2 for a in range(10)] 生成器把中括号[]换成小括号()\r\nG = (a*2 for a in range(10))  \r\n```\r\n\r\n三、yield\r\n\r\n首先我们来写一个斐波拉契数列 1, 1, 2, 3, 5, 8, 13, 21.....除第一个数外，每前两个数的和等于第三个数\r\n\r\n```python\r\nfib_list = []\r\ndef fib(n):\r\n    i, a, b = 0, 0, 1\r\n    while i < n:\r\n        fib_list.append(b)\r\n        a, b = b, a+b\r\n        i = i + 1\r\nf = fib(6)\r\nprint(fib_list)\r\n#结果为\r\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\r\n```\r\n\r\n这样就得到了一个==简单斐波拉契数列==了。当然我们还可以用yield来进行改装，把它变成一个生成器对象，yield: 在函数执行时会给函数返回generator对象，可以通过该对象的obj.**next**()方法或next(obj)来启动函数\r\n\r\n```python\r\n>>> def generator_example():\r\n...     print(\'before yield\')\r\n...     yield \'first yield\'   \r\n \r\n...     print(\'after first yield\')\r\n...     message = yield \'second yield\'         #1  调用obj.send(\'message\')可把值赋给yield表达式，同时返回yield右边的内容\r\n...     print(\'第二个yield收到send函数的消息：{}\'.format(message))\r\n...     yield\r\n...     return \'over\'\r\n>>> g = generator_example()         #2 运行带yield的函数，返回一个generator obj\r\n>>> g\r\n#<generator object generator_example at 0x0000006E725E3308>\r\n>>> res = g.__next__()         #3 调用obj.__next__()方法启动generator\r\n#before yield\r\n>>> print(res)         \r\n#first yield\r\n>>> res2 = next(g)         #4 next(obj) 等同于obj.__next__()\r\n#after first yield\r\n>>> print(res2)\r\n#second yield\r\n>>> res3 = g.send(\'form send: after second yield\')\r\n#第二个yield收到send函数的消息：form send: after second yield\r\n>>> print(res3)\r\n#None\r\n>>> try:\r\n...     next(g)\r\n...     print(\'上一个next(g)因为没有yield，所以触发错误，这儿不会执行\')\r\n... except StopIteration as e:\r\n...     print(e.value)\r\nover\r\n```\r\n\r\n上面没有提到obj.send()方法，#3处第一次通过obj.**next**()方法启动generator后，函数返回第一个yield右边的值，并停在了哪儿，然后第二次通过next(obj)让函数继续运行到第二个yield，返回second yield然后停住，然后第三次通过obj.send(value)的方法把value传给给了暂停地方的yield表达式的 message，并启动函数继续运行直到遇到下一个yield。......最后当触发最后次yield但是后面没有yield能暂停就报错了，使用try：抓住错误，并接受函数返回值over\r\n\r\n```python\r\nyield来实现斐波拉契数列\r\ndef fib(n):\r\n    i, a, b = 0, 0, 1\r\n    while i < n:\r\n        yield b         #在这儿用yield就好了\r\n        a, b = b, a+b\r\n        i = i + 1\r\n    return \'--done--\'    \r\n\r\nf = fib(6)\r\nwhile True:\r\n    try:\r\n        res = next(f)\r\n        print(res)\r\n    except    StopIteration as e:\r\n        print(e.value)\r\n        break\r\n\r\n#运行结果为\r\n1\r\n1\r\n2\r\n3\r\n5\r\n--done--\r\n```\r\n\r\n四、迭代器\r\n\r\n==生成器都是迭代器==\r\n\r\n还有可以作用于for循环的数据类型有：一类是集合数据类型：如 list、tuple、duct、str等\r\n另一类是generator包括生成器，和带yield的generator function，这些可以直接作用于for循环的对象统称为可迭代对象（Iterable）可使用isinstance()来判断是否为Iterable\r\n\r\n```python\r\n>>> from collection import Iterable\r\n>>> isinstance([], Iterable)\r\nTrue\r\n```\r\n\r\n而生成器不但可以作用于for循环，还能被next()函数不断调用返回下一个值，直到抛出StopIteration错误无法继续\r\n可以被next()函数调用并不断返回下一个值的对象就称为迭代器Iterator\r\nlist、idct、str虽然可以用for循环，可迭代，但是没有nex()方法就不是Iterator迭代器\r\n\r\n而==使用iter()函数就可以把它们变成迭代器==了\r\n\r\n```python\r\n>>> gen_list = iter([1, 3, 5, 7])\r\n>>> gen_list\r\n<list_iterator object at 0x00000052371B6C50>\r\n```\r\n\r\nrange() 或for line in f:这样的内部也都是封装了迭代器\r\n\r\n人生还有意义。那一定是还在找存在的理由","timestamp":1590329650947},{"name":"137-CV2.md","path":"13-语言学习project/12-python3/7-opencv/137-CV2.md","content":"# python导入cv2\r\n\r\n直接使用pip install cv2导入发现\r\nCollecting cv2\r\nCould not find a version that satisfies the requirement cv2 (from versions: )\r\nNo matching distribution found for cv2\r\n最后发现 直接导入集合包即可\r\n\r\n```\r\npip install opencv-python\r\n```\r\n\r\n\r\n","timestamp":1590329650947},{"name":"138-Python OpenCV使用摄像头捕获视频.md","path":"13-语言学习project/12-python3/7-opencv/138-Python OpenCV使用摄像头捕获视频.md","content":"## Python OpenCV使用摄像头捕获视频\r\n\r\n我们知道，OpenCV是一款强大的跨平台的计算机视觉库，使用它能完成我们对于==图像和视频处理==的很多功能，今天，我们使用OpenCV来==捕获计算机摄像头==的视频。\r\n\r\n我们知道，视频是将一系列==静态影像==以电信号的方式加以捕捉、记录、处理、储存、传送与重现的各种技术。OpenCV恰好提供了对于视频的**捕捉、记录、处理、存储、传送**等功能。这一系列动作通过cv2.VideoCapture类来实现。它的原理基本上就是通过获取视频中的一系列祯来实现对于视频的各种操作。\r\n\r\n要进行视频处理捕获视频是前提\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# coding:utf-8\r\nimport numpy as np\r\nimport cv2\r\n\r\ncapture = cv2.VideoCapture(0) # 0 系统摄像头 1 计算机外置摄像头，比如usb连接的摄像头\r\n# 使用一个循环表示持续获取摄像头数据\r\nwhile True:\r\n    ret, frame = capture.read() #ret 是否获取到了图像数据,验证获取到的视频是否到达结尾部分;frame一帧的图像数据\r\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n    cv2.imshow(\'frame\', gray)\r\n    if cv2.waitKey(1) & 0xFF == ord(\'q\'):\r\n        break\r\n\r\ncapture.release()\r\ncv2.destroyAllWindows()\r\n```\r\n\r\n前面的导入模块内容不用解释了\r\n\r\n**capture = cv2.VideoCapture(0)**\r\n\r\n这一句表示调用计算机内置摄像头来获取视频，如果传入参数为1时，表示调用计算机外置摄像头，比如usb连接的摄像头等。VideoCapture对象也可以传入视频文件地址。\r\n\r\n**ret, frame = capture.read()**\r\n\r\n这里使用一个循环表示持续获取摄像头数据，VideoCapture对象的read()方法返回两个值。\r\n\r\n**第一个值**一般为ret，它是一个布尔值，表示是否获取到了图像数据，如果获取成功返回True，获取失败返回False，这一句后可以判断ret是否为True，如果为True则向下执行，False则执行相应的操作，这样可以使得我们的应用程序更加健壮。它还有一个功能就是验证获取到的视频是否到达结尾部分。\r\n\r\n**第二个值**表示获取到的一帧的图像数据。下一步我们将这个图像数据直接转化为灰度图像进行了处理。\r\n\r\n后面的代码就不用解释，关于OpenCV的处理键盘事件方法可以参照我的另一篇博文（使用Python OpenCV处理图像之详解使用OpenCV处理键盘鼠标事件）。\r\n\r\n由于我的电脑摄像头被我拆掉了，这里就不演示捕获的具体内容了，感兴趣的朋友们自己测试下上述代码吧。\r\n\r\n好了，今天的内容就到这里了，后续我们会推出关于视频处理的一些应用。欢迎大家持续关注，感兴趣的朋友们要多练哦。\r\n\r\n![img](D:\\Typora_pic\\5fdf8db1cb1349546b97adee7dce315dd0094a30.jpeg)\r\n\r\n**转载请注明出处，百家号：Python高手养成**","timestamp":1590329650947},{"name":"139-lineEdit.md","path":"13-语言学习project/12-python3/8-pyqt5/139-lineEdit.md","content":"# [PyQt5 控件字体样式等设置](https://www.cnblogs.com/shiqi17/p/12175763.html)\r\n\r\n一、API接口设置\r\n\r\n\\- 比如我这段代码中的一些设置，设置文字、居中、禁止复制、LineEdit输入为password等等\r\n\r\n![img](D:\\Typora_pic\\1226829-20200110141859729-754415696.png)\r\n\r\n```python\r\nimport sys\r\n\r\nfrom PyQt5.QtCore import Qt\r\nfrom PyQt5.QtWidgets import QFrame\r\nfrom PyQt5.QtWidgets import QLabel\r\nfrom PyQt5.QtWidgets import QWidget\r\nfrom PyQt5.QtWidgets import QLineEdit\r\nfrom PyQt5.QtWidgets import QTextEdit\r\nfrom PyQt5.QtWidgets import QSizePolicy\r\nfrom PyQt5.QtWidgets import QMainWindow\r\nfrom PyQt5.QtWidgets import QPushButton\r\nfrom PyQt5.QtWidgets import QGridLayout\r\nfrom PyQt5.QtWidgets import QApplication\r\n\r\n\r\n\r\n\r\nfrom View import interface\r\n\r\nclass MainWindow(QMainWindow):\r\n\r\n    def __init__(self):\r\n        super(MainWindow,self).__init__(None)\r\n        self.setWindowTitle(\"对金属腐蚀性试验仪\")\r\n        self.initUI()\r\n\r\n    def initUI(self):\r\n        layout = QGridLayout()\r\n        layout.setSpacing(10)\r\n        self.loginLabel = QLabel(\"用户名：\")\r\n        self.loginLabel.setAlignment(Qt.AlignRight)\r\n        self.loginLabel.setStyleSheet(\"color:rgb(20,20,20,255);font-size:16px;font-weight:bold:text\")\r\n        self.loginTxt = QLineEdit()\r\n        self.loginTxt.setText(\"admin\")\r\n        self.loginTxt.setPlaceholderText(\"User Name\")\r\n        self.loginTxt.setClearButtonEnabled(True)\r\n        self.pwdLabel = QLabel(\"密码：\")\r\n        self.pwdLabel.setAlignment(Qt.AlignRight)\r\n        self.pwdTxt = QLineEdit()\r\n        self.pwdTxt.setContextMenuPolicy(Qt.NoContextMenu) #禁止复制粘贴\r\n        self.pwdTxt.setPlaceholderText(\"Password\")\r\n        self.pwdTxt.setText(\"admin\")\r\n        self.pwdTxt.setEchoMode(QLineEdit.Password)\r\n        self.pwdTxt.setClearButtonEnabled(True)\r\n        self.registeredBtn = QPushButton(\"注册\")\r\n        self.loginBtn = QPushButton(\"登陆\")\r\n\r\n        self.headLabel = QLabel(\"用户登陆\")\r\n        self.headLabel.resize(300,30)\r\n        self.headLabel.setAlignment(Qt.AlignCenter)\r\n        self.headLabel.setStyleSheet(\"color:rgb(10,10,10,255);font-size:25px;font-weight:bold;font-family:Roman times;\")\r\n\r\n        self.headLabel.setSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding)\r\n        layout.addWidget(self.headLabel,0,0,1,2)\r\n        policy = self.headLabel.sizePolicy()\r\n        print(policy.verticalPolicy())\r\n        policy.setVerticalPolicy(1)\r\n        print(policy.verticalPolicy())\r\n        # policy.setVerticalPolicy(1)\r\n        layout.addWidget(self.loginLabel,1,0)\r\n        layout.addWidget(self.loginTxt,1,1)\r\n        layout.addWidget(self.pwdLabel,2,0)\r\n        layout.addWidget(self.pwdTxt,2,1)\r\n        layout.addWidget(self.registeredBtn,3,0)\r\n        layout.addWidget(self.loginBtn,3,1)\r\n\r\n        frame = QFrame(self)\r\n        frame.setLayout(layout)\r\n        self.setCentralWidget(frame)\r\n        self.resize(300,150)\r\n\r\nif __name__ == \'__main__\':\r\n    app = QApplication(sys.argv)\r\n    mainWindow = MainWindow()\r\n    mainWindow.show()\r\n    mainWindow.activateWindow()\r\n    mainWindow.raise_()\r\n    app.exec_()\r\n    del mainWindow\r\n    del app\r\n```\r\n\r\n1.1.0 QLineEdit一些属性\r\n\r\ninputMask设置掩码\r\ntext 设置文本\r\nmaxLength文本框输入的最大字符数\r\nframe 设置边框\r\nechoMode 设置文本框显示格式\r\nNormal正常显示所输入的字符，此为默认选项\r\nNoEcho不显示任何输入的字符，常用于密码类型的输入，且长度保密\r\nPassword显示与平台相关的密码掩饰字符，而不是实际输入的字符\r\nPasswordEchoOnEdit在编辑时显示字符，负责显示密码类型的输入\r\ncursorPosition光标位置\r\nalignment文本对齐方式\r\nAlignLeft左对齐\r\nAlignRight右对齐\r\nAlignCenter水平居中对齐\r\nAlignJustify水平方向调整间距两端对齐\r\nAlignTop垂直上对齐\r\nAlignBottom垂直方下对齐\r\nAlignVCenter垂直方向居中对齐\r\ndragEnabled设置文本框是否接受拖动\r\nreadOnly设置文本为只读\r\nplaceholderText设置文本框提示文字\r\ncursorMoveStyle光标移动风格\r\nLogicalMoveStyle逻辑风格\r\nVisualMoveStyle视觉风格\r\nclearButtonEnabled快速删除按钮\r\n\r\n[参考文章,QLineEdit属性、信号、方法等](https://zhuanlan.zhihu.com/p/57146150)\r\n\r\n1.1 常用的一些设置\r\n\r\n![img](D:\\Typora_pic\\1226829-20200110141257304-770220875.png)\r\n\r\n- setAlignment(self, Union, Qt_Alignment=None,Qt_AlignmentFlag=None): 设置字体对齐方式\r\n\r\n|          参数           |           作用           |\r\n| :---------------------: | :----------------------: |\r\n|    AlignAbsolute=16     |                          |\r\n|    AlignBaseline=256    |                          |\r\n|     AlignBottom=64      |         底端对齐         |\r\n|     AlignCenter=132     |         完全居中         |\r\n|     AlignHCenter=4      |         水平居中         |\r\n| AlignHorizontal_Mask=31 |                          |\r\n|     AlignJustify=8      |       可用空间对齐       |\r\n|     AlignLeading=1      | 领头对齐(理解为左对齐吧) |\r\n|       AlignLeft=1       |          左对齐          |\r\n|      AlignRight=2       |          右对齐          |\r\n|       AlignTop=32       |          上对齐          |\r\n|     AlignTrailing=2     |      尾对齐(右对齐       |\r\n|    AlignVCenter=128     |         垂直居中         |\r\n\r\n- setClearButtonEnabled(self, bool): 是否有清除文本按钮(如我第一段程序文本框后的 小黑X)\r\n- setCompleter(self, QCompleter):设置自动补全[QLineEdit自动补全](https://www.cnblogs.com/shiqi17/p/12176497.html)\r\n\r\n![img](D:\\Typora_pic\\1226829-20200110152811310-684119616.png)\r\n\r\n- setCursorMoveStyle(self, Qt_CursorMoveStyle):\r\n- setCursorPosition(self, p_int):\r\n- setDragEnabled(self, bool):\r\n- setEchoMode(self, QLineEdit_EchoMode):\r\n- setFrame(self, bool):\r\n- setInputMask(self, p_str):\r\n- setMaxLength(self, p_int):\r\n- setModified(self, bool):\r\n- setPlaceholderText(self, p_str):\r\n- setReadOnly(self, bool):\r\n- setSelection(self, p_int, p_int_1):\r\n- setText(self, p_str):\r\n- setTextMargins(self, *__args):\r\n- setValidator(self, QValidator):\r\n\r\n人生还有意义。那一定是还在找存在的理由","timestamp":1590329650947},{"name":"140-QlineEdit自动补全.md","path":"13-语言学习project/12-python3/8-pyqt5/140-QlineEdit自动补全.md","content":"# [PyQt5 文本输入框自动补全 QLineEdit](https://www.cnblogs.com/shiqi17/p/12176497.html)\r\n\r\n一、QCompleter类\r\n\r\n\\- 自动补全会用到的一个类\r\n\r\n![img](D:\\Typora_pic\\1226829-20200110154004362-832241533.png)\r\n\r\n主要代码\r\n\r\n```python\r\n    def init_lineedit(self):\r\n        self.completer = QCompleter(items_list)# 增加自动补全\r\n        # 设置匹配模式:  开头（默认）MatchStartsWith; 内容MatchContains; 结尾匹配MatchEndsWith \r\n        self.completer.setFilterMode(Qt.MatchContains)\r\n        # 设置补全模式  PopupCompletion（默认）  InlineCompletion  UnfilteredPopupCompletion\r\n        self.completer.setCompletionMode(QCompleter.PopupCompletion) \r\n        self.lineedit.setCompleter(self.completer)# 给lineedit设置补全器\r\n\r\n    def init_combobox(self):\r\n        # 增加选项元素\r\n        for i in range(len(items_list)):\r\n            self.combobox.addItem(items_list[i])\r\n        self.combobox.setCurrentIndex(-1)\r\n\r\n        # 增加自动补全\r\n        self.completer = QCompleter(items_list)\r\n        self.completer.setFilterMode(Qt.MatchContains)\r\n        self.completer.setCompletionMode(QCompleter.PopupCompletion)\r\n        self.combobox.setCompleter(self.completer)\r\n```\r\n\r\n完整代码：\r\n\r\n```python\r\nimport sys\r\nfrom PyQt5.QtWidgets import *\r\nfrom PyQt5.QtGui import *\r\nfrom PyQt5.QtCore import *\r\n################################################\r\nitems_list=[\"C\",\"C++\",\"Java\",\"Python\",\"JavaScript\",\"C#\",\"Swift\",\"go\",\"Ruby\",\"Lua\",\"PHP\"]\r\n################################################\r\nclass Widget(QWidget):\r\n    def __init__(self, *args, **kwargs):\r\n        super(Widget, self).__init__(*args, **kwargs)\r\n        layout = QHBoxLayout(self)\r\n        self.lineedit = QLineEdit(self, minimumWidth=200)\r\n        self.combobox = QComboBox(self, minimumWidth=200)\r\n        self.combobox.setEditable(True)\r\n\r\n        layout.addWidget(QLabel(\"QLineEdit\", self))\r\n        layout.addWidget(self.lineedit)\r\n        layout.addItem(QSpacerItem(20, 20, QSizePolicy.Expanding, QSizePolicy.Minimum))\r\n\r\n        layout.addWidget(QLabel(\"QComboBox\", self))\r\n        layout.addWidget(self.combobox)\r\n\r\n        #初始化combobox\r\n        self.init_lineedit()\r\n        self.init_combobox()\r\n\r\n        #增加选中事件\r\n        self.combobox.activated.connect(self.on_combobox_Activate)\r\n\r\n    def init_lineedit(self):\r\n        # 增加自动补全\r\n        self.completer = QCompleter(items_list)\r\n        # 设置匹配模式  有三种： Qt.MatchStartsWith 开头匹配（默认）  Qt.MatchContains 内容匹配  Qt.MatchEndsWith 结尾匹配\r\n        self.completer.setFilterMode(Qt.MatchContains)\r\n        # 设置补全模式  有三种： QCompleter.PopupCompletion（默认）  QCompleter.InlineCompletion   QCompleter.UnfilteredPopupCompletion\r\n        self.completer.setCompletionMode(QCompleter.PopupCompletion)\r\n        # 给lineedit设置补全器\r\n        self.lineedit.setCompleter(self.completer)\r\n\r\n    def init_combobox(self):\r\n        # 增加选项元素\r\n        for i in range(len(items_list)):\r\n            self.combobox.addItem(items_list[i])\r\n        self.combobox.setCurrentIndex(-1)\r\n\r\n        # 增加自动补全\r\n        self.completer = QCompleter(items_list)\r\n        self.completer.setFilterMode(Qt.MatchContains)\r\n        self.completer.setCompletionMode(QCompleter.PopupCompletion)\r\n        self.combobox.setCompleter(self.completer)\r\n\r\n    def on_combobox_Activate(self, index):\r\n        print(self.combobox.count())\r\n        print(self.combobox.currentIndex())\r\n        print(self.combobox.currentText())\r\n        print(self.combobox.currentData())\r\n        print(self.combobox.itemData(self.combobox.currentIndex()))\r\n        print(self.combobox.itemText(self.combobox.currentIndex()))\r\n        print(self.combobox.itemText(index))\r\n\r\nif __name__ == \"__main__\":\r\n    app = QApplication(sys.argv)\r\n    w = Widget()\r\n    w.show()\r\n    sys.exit(app.exec_())\r\n```\r\n\r\n二、QStandardItemModel类\r\n\r\n\\- 最终效果 ![](D:\\Typora_pic\\1226829-20200110154655009-335491790.png)\r\n\r\n![img](D:\\Typora_pic\\1226829-20200110154607304-1412737991.png)\r\n\r\n```\r\nimport sys\r\n\r\n# from PyQt5.Qt import QCompleter\r\nfrom PyQt5.Qt import QStandardItemModel\r\nfrom PyQt5.QtCore import Qt\r\nfrom PyQt5.QtCore import pyqtSlot\r\nfrom PyQt5.QtCore import pyqtSignal\r\nfrom PyQt5.QtWidgets import QFrame\r\nfrom PyQt5.QtWidgets import QLabel\r\nfrom PyQt5.QtWidgets import QWidget\r\nfrom PyQt5.QtWidgets import QLineEdit\r\nfrom PyQt5.QtWidgets import QTextEdit\r\nfrom PyQt5.QtWidgets import QCompleter\r\nfrom PyQt5.QtWidgets import QSizePolicy\r\nfrom PyQt5.QtWidgets import QMainWindow\r\nfrom PyQt5.QtWidgets import QPushButton\r\nfrom PyQt5.QtWidgets import QGridLayout\r\nfrom PyQt5.QtWidgets import QApplication\r\n\r\n\r\n\r\n\r\nfrom View import interface\r\n\r\nclass MainWindow(QMainWindow):\r\n\r\n    def __init__(self):\r\n        super(MainWindow,self).__init__(None)\r\n        self.setWindowTitle(\"对金属腐蚀性试验仪\")\r\n        self.initUI()\r\n\r\n    def initUI(self):\r\n        layout = QGridLayout()\r\n        layout.setSpacing(10)\r\n        self.loginLabel = QLabel(\"邮箱：\")\r\n        self.loginLabel.setAlignment(Qt.AlignRight)\r\n        self.loginLabel.setStyleSheet(\"color:rgb(20,20,20,255);font-size:16px;font-weight:bold:text\")\r\n\r\n        self.loginTxt = QLineEdit()\r\n        self.loginTxt.setText(\"admin\")\r\n        self.loginTxt.setPlaceholderText(\"User Name\")\r\n        self.loginTxt.setClearButtonEnabled(True)\r\n        self.loginTxt.textChanged.connect(self.on_loginTxt_textChanged) #绑定槽函数\r\n        self.m_model = QStandardItemModel(0, 1, self)\r\n        m_completer = QCompleter(self.m_model, self)\r\n        self.loginTxt.setCompleter(m_completer)\r\n        m_completer.activated[str].connect(self.onTxtChoosed)\r\n\r\n\r\n        self.pwdLabel = QLabel(\"密码：\")\r\n        self.pwdLabel.setAlignment(Qt.AlignRight)\r\n        self.pwdTxt = QLineEdit()\r\n        self.pwdTxt.setContextMenuPolicy(Qt.NoContextMenu) #禁止复制粘贴\r\n        self.pwdTxt.setPlaceholderText(\"Password\")\r\n        self.pwdTxt.setText(\"admin\")\r\n        self.pwdTxt.setEchoMode(QLineEdit.Password)\r\n        self.pwdTxt.setClearButtonEnabled(True)\r\n        self.registeredBtn = QPushButton(\"注册\")\r\n        self.loginBtn = QPushButton(\"登陆\")\r\n\r\n        self.headLabel = QLabel(\"用户登陆\")\r\n        self.headLabel.resize(300,30)\r\n        self.headLabel.setAlignment(Qt.AlignCenter)\r\n        self.headLabel.setStyleSheet(\"color:rgb(10,10,10,255);font-size:25px;font-weight:bold;font-family:Roman times;\")\r\n\r\n        self.headLabel.setSizePolicy(QSizePolicy.Expanding,QSizePolicy.Expanding)\r\n        layout.addWidget(self.headLabel,0,0,1,2)\r\n        policy = self.headLabel.sizePolicy()\r\n        print(policy.verticalPolicy())\r\n        policy.setVerticalPolicy(1)\r\n        print(policy.verticalPolicy())\r\n        # policy.setVerticalPolicy(1)\r\n        layout.addWidget(self.loginLabel,1,0)\r\n        layout.addWidget(self.loginTxt,1,1)\r\n        layout.addWidget(self.pwdLabel,2,0)\r\n        layout.addWidget(self.pwdTxt,2,1)\r\n        layout.addWidget(self.registeredBtn,3,0)\r\n        layout.addWidget(self.loginBtn,3,1)\r\n\r\n        frame = QFrame(self)\r\n        frame.setLayout(layout)\r\n        self.setCentralWidget(frame)\r\n        self.resize(300,150)\r\n\r\n    def onTxtChoosed(self, txt):\r\n        self.loginTxt.setText(txt)\r\n\r\n    @pyqtSlot(str)\r\n    def on_loginTxt_textChanged(self, text):\r\n        if \'@\' in self.loginTxt.text():\r\n            return\r\n\r\n        emaillist = [\"@163.com\", \"@qq.com\", \"@gmail.com\", \"@live.com\", \"@126.com\", \"@139.com\"]\r\n        self.m_model.removeRows(0, self.m_model.rowCount())\r\n        for i in range(0, len(emaillist)):\r\n            self.m_model.insertRow(0)\r\n            self.m_model.setData(self.m_model.index(0, 0), text + emaillist[i])\r\n\r\nif __name__ == \'__main__\':\r\n    app = QApplication(sys.argv)\r\n    mainWindow = MainWindow()\r\n    mainWindow.show()\r\n    mainWindow.activateWindow()\r\n    mainWindow.raise_()\r\n    app.exec_()\r\n    del mainWindow\r\n    del app\r\n```\r\n\r\nQStandardItemModel类为存储自定义数据提供了一个通用模型。\r\n\r\nQStandardItemModel可以用作标准Qt数据类型的存储库。它是模型/视图类之一，是Qt的模型/视图框架的一部分。\r\n\r\nQStandardItemModel提供了一个经典的基于项目的方法来处理模型。 QStandardItemModel中的项目由QStandardItem提供。\r\n\r\nQStandardItemModel实现了QAbstractItemModel接口，这意味着该模型可用于在支持该接口的任何视图（如QListView，QTableView和QTreeView以及您自己的自定义视图）中提供数据。为了提高性能和灵活性，您可能希望子类QAbstractItemModel为不同类型的数据存储库提供支持。例如，QDirModel为底层文件系统提供了一个模型接口。\r\n\r\n当你想要一个列表或树时，你通常会创建一个空的QStandardItemModel并使用appendRow()向模型添加项目，使用item()来访问项目。如果您的模型表示一个表格，您通常会将表格的维度传递给QStandardItemModel构造函数，并使用setItem()将项目放入表格中。您还可以使用setRowCount()和setColumnCount()来更改模型的尺寸。要插入项目，请使用insertRow()或insertColumn()，并删除项目，请使用removeRow()或removeColumn()。\r\n\r\n您可以使用setHorizontalHeaderLabels()和setVerticalHeaderLabels()来设置模型的标题标签。\r\n\r\n您可以使用findItems()在模型中搜索项目，并通过调用sort()对模型进行排序。\r\n\r\n调用clear()从模型中移除所有项目。\r\n\r\n2.2 代码理解\r\n\r\n```\r\n        self.loginTxt = QLineEdit()\r\n        self.loginTxt.setText(\"admin\")\r\n        self.loginTxt.setPlaceholderText(\"User Name\")\r\n        self.loginTxt.setClearButtonEnabled(True)\r\n0        self.loginTxt.textChanged.connect(self.on_loginTxt_textChanged) #绑定槽函数\r\n1        self.m_model = QStandardItemModel(0, 1, self)\r\n2        m_completer = QCompleter(self.m_model, self)\r\n3        self.loginTxt.setCompleter(m_completer)\r\n4        m_completer.activated[str].connect(self.onTxtChoosed)\r\n\r\n\r\n    def onTxtChoosed(self, txt):\r\n        self.loginTxt.setText(txt)\r\n\r\n    @pyqtSlot(str)\r\n    def on_loginTxt_textChanged(self, text):\r\n        if \'@\' in self.loginTxt.text():\r\n            return\r\n\r\n        emaillist = [\"@163.com\", \"@qq.com\", \"@gmail.com\", \"@live.com\", \"@126.com\", \"@139.com\"]\r\n        self.m_model.removeRows(0, self.m_model.rowCount())\r\n        for i in range(0, len(emaillist)):\r\n            self.m_model.insertRow(0)\r\n            self.m_model.setData(self.m_model.index(0, 0), text + emaillist[i])\r\n```\r\n\r\n0-将文本改变信号连接到on_loginTxt_textChanged 函数处理\r\n\r\n1. 构建一个0行一列的新项目模型。self.m_model = QStandardItemModel(0, 1, self)\r\n2. 用给定的父对象，构造一个补全(完成)对象，该对象提供来自指定模型的完成对象，这里就是self.m_model. m_completer = QCompleter(self.m_model, self)\r\n3. 将我们想要自动补全、完成的文本输入框对象设置关联上面创建的 补全(完成对象)\r\n4. QCompleter.activated；如果文本框的当前项目发生更改，则会发出两个信号currentIndexChanged()和activated()。无论以编程方式或通过用户交互完成更改，currentIndexChanged()总是被发射，而只有当更改是由用户交互引起时才activated() 。highlighted()信号在用户突出显示组合框弹出列表中的项目时发出。所有三个信号都有两个版本，一个带有str参数，另一个带有int参数。如果用户选择或突出显示一个图像，则只会发出int信号。每当可编辑组合框的文本发生改变时，editTextChanged()信号就会发出。所以讲activated信号连接到用户选择文本处理函数上\r\n\r\n[参考连接](https://zhuanlan.zhihu.com/p/34165301)\r\n\r\n人生还有意义。那一定是还在找存在的理由","timestamp":1590329650947},{"name":"141-qtreeWidget删除操作.md","path":"13-语言学习project/12-python3/8-pyqt5/141-qtreeWidget删除操作.md","content":"# QTreeWidget的使用方法及设置列表项不可选和编辑\r\n原创WANGZHEN` 最后发布于2018-02-01 13:50:53 阅读数 1919  收藏\r\n展开\r\n 使用到QTreeWidget做总结，以便下次使用。\r\n\r\n```c#\r\nQTreeWidget CalibrationWidget = new QTreeWidget;\r\nCalibrationWidget->setColumnCount(2); //将treewidget设置为两列\r\nCalibrationWidget->setColumnWidth(0, 155); //设置指定列宽\r\nCalibrationWidget->setItemsExpandable(true); //设置默认为展开\r\nQStringList m_header;\r\nm_header<<QString(\"名称\")<<QString(\"值\"); \r\nCalibrationWidget->setHeaderLabels(m_header); //设置标题头\r\nQStringList dynamic;\r\ndynamic<<QString(\"动态测试\");\r\ndynamicItem = new QTreeWidgetItem(CalibrationWidget, dynamic); //添加列表项\r\n```\r\n\r\n\r\n\r\n```C#\r\n//1、删除所有子列表项\r\nQList<QTreeWidgetItem *> QTreeWidgetItem::takeChildren() //删除所有子列表项\r\n// Removes the list of children and returns it, otherwise returns an empty list.\r\n2、删除指定子列表项\r\nvoid QTreeWidgetItem::removeChild(QTreeWidgetItem * child) //删除指定子列表项 \r\n//Removes the given item indicated by child. The removed item will not be deleted.\r\n3、删除指定索引的子列表项\r\nQTreeWidgetItem * QTreeWidgetItem::takeChild(int index) //删除指定索引的子列表项\r\n// Removes the item at index and returns it, otherwise return 0.\r\n4、添加子列表项\r\nvoid QTreeWidgetItem::addChild(QTreeWidgetItem * child) //添加子列表项 \r\n//Appends the child item to the list of children.\r\n5、添加多条子列表项\r\nvoid QTreeWidgetItem::addChildren(const QList<QTreeWidgetItem *> & children) //添加多条子列表项 \r\n//Appends the given list of children to the item.\r\n6、设置treewidget字体样式及treewidget头字体样式\r\nQTreeWidget->setFont(QFont(\"微软雅黑\", 12, QFont::Normal, false));\r\nQTreeWidget->headerItem()->setFont(0, QFont(\"微软雅黑\", 12, QFont::Normal, false));//设置treewidget头字体格式\r\n```\r\n\r\n","timestamp":1590329650947},{"name":"142-QtreeWidget设置行高.md","path":"13-语言学习project/12-python3/8-pyqt5/142-QtreeWidget设置行高.md","content":"#  QtreeWidget\r\nqt官网有帮助文档,可以借助翻译软件或者插件查看，我最喜欢的方法是先用__dir__方法把类的方法列表打印出来，如下图是QTreeWidget的小部分方法截图。\r\n![img](D:\\Typora_pic\\614a2a34349b033b048ffb3d1bce36d3d439bdb6.jpg)\r\n\r\nQTreeWidget的父类如图：\r\n![img](D:\\Typora_pic\\1db3ff1f4134970a8fcc17c89bcad1c8a6865d7e.jpg)\r\n\r\n注：来自于qt官方网站帮助文档\r\nQTreeWidget的父类是QTreeView，往上还有，从官方网站只能得到在QTreeWidget中定义或者重新定义的方法，而看不到其父类的方法，所以通过__dir__方法可以获取所有父类的方法。\r\n然后用idle可以查看方法参数，返回类型，如下图\r\n![img](D:\\Typora_pic\\356a1bd8bc3eb135848cb15ca81ea8d3fc1f446a.jpg)\r\n![img](D:\\Typora_pic\\3261a38b87d6277fbed835df26381f30eb24fceb.jpg)\r\n\r\n如果这里还找不到你想要的，可以去官网试试看，如下图（currentItem方法）：\r\n![img](D:\\Typora_pic\\f7c7db33c895d14359cbe2c47df082025baf077c.jpg)\r\n\r\n注：这是用翻译插件翻译的\r\n当然也可以直接把方法名翻译一下有意想不到的效果\r\n![img](D:\\Typora_pic\\e46fdbf9d72a60597cffe7fd2634349b013bbace.jpg)\r\n\r\npyqt的方法名一般是首单词全小写，第二个单词开始每个的首字母大写。类名一般都是Q开头，后面所有单词首字母大写。所以翻译的时候很容易分词\r\n后面楼层主要说一下在使用过程中遇到的一些问题和解决的方法，基本用法就不多说了，看书自己研究。\r\n\r\n##  本贴主要说的是QTreeWidget控件（以下简称Tree）。\r\n1. Tree提供了文本换行，居然没有提供行高调整，不能设置行高，不能自适应行高，这点真的是要吐槽\r\n2. Tree的单元格可以编辑，居然只显示一行，我这多行数据\r\n3. Tree提供了columnResized方法（继承自父类QTreeView），官网解释是（机器翻译）：无论何时column标题中更改大小，都会调用此函数。oldSize并newSize给出以前的大小和新的大小（以像素为单位），然鹅，我调整列宽并不会触发该函数，那么我列宽改变了之后又该怎么调整以适应单元格内容显示呢？\r\n   ![img](D:\\Typora_pic\\f7c7db33c895d1435c1de7c47df082025baf074a.jpg)\r\n   ![img](D:\\Typora_pic\\039d5066d01609244f43a1fcda0735fae7cd3457.jpg)\r\n\r\n1.QTreeWidget提供了文本换行，居然没有提供==行高调整，不能设置行高，不能自适应行高==，这点真的是要吐槽\r\n既然不能设置行高，我们可以变相来处理，百度也有一些其他的方案，最后感觉不好用。后来我发现QTreeWidget可以根据字体调整高度显示，这就找到了突破点。具体做法是：\r\n==①.把第一列留空==\r\n==②.计算文本长度==，因为考虑到中文和英文字符宽度不同，我初始的时候将中文设定为2个字符，英文占1个字符，最后发现大约32个汉字的宽度与60个英文字母宽度差不多，所以最后我将英文按32/30个字符考虑的。把这个函数明明为lenb\r\n![img](D:\\Typora_pic\\0fc1cf11728b4710b30f312bcdcec3fdfd032391.jpg)\r\n![img](D:\\Typora_pic\\ff8d2c738bd4b31cd1f4595c89d6277f9c2ff8ea.jpg)\r\n\r\nget_width来自于一个第三方模块——urwid，我只要这一段代码，所以就没有加载该模块，只把代码拿来用了。\r\n③.根据文本长度和列宽计算文本行数\r\n<img src=\"D:\\Typora_pic\\945fba0e7bec54e7f56cd6f9b7389b504ec26a32.jpg\" alt=\"img\" style=\"zoom:150%;\" />\r\n\r\n这里可能就比较麻烦，因为每个字号的文字宽度不同，间距不同，所以可能需要测试比较多的数据才能计算出每种字号情况下任意列宽一行最多字符长度，目前我将字号定为11号字，只测试了该种情况下的对应关系。\r\nfloor函数为向下取整，来自math模块。（才想起来int函数好像也可以![img](D:\\Typora_pic\\i_f04.png)）\r\nceil也来自math模块，为向上取整。\r\n也就是，一行所能容下的字符数尽量少算，所以用floor，文本所占行数尽量多算，用ceil。\r\n④.下面就是计算首列的字号应该设置为多少，才能使得其他列能显示全部的文本了。\r\n行高涉及到文本行数，字号，行间距，因为我这行间距和字号都是固定的，所以可以暂不考虑，只需考虑行数对其影响，为此定义一个方法updateheight用来更新高度（首列字号），实际就是建立字号（首列）—文本行数对应关系，这都需要自己测试才能出来结果。\r\n按显示文本为11号字，行数记为n的话，那么首列字号需设置为：(17*n+5)/2+n*3\r\n![img](D:\\Typora_pic\\ba4440a7d933c895fdfd579cdf1373f083020032.jpg)\r\n\r\n这里的fontsize就是其他列的文字大小，我这计算公式是按11计算的，这里预留后期需要扩展到其他字号，暂时用不到该参数。\r\n下面QTreeWidgetItem类下需要增加的函数\r\n<img src=\"D:\\Typora_pic\\1c8c8813632762d09a276a58aeec08fa503dc699.jpg\" alt=\"img\" style=\"zoom:150%;\" />\r\n\r\nsetLineCountWithWidth函数（意思是根据列宽设置行数）是用来在打开文件、调整列宽等操作后（因为没有添加编辑框，所以不能直接从编辑框读取行数）计算行数用的。\r\n而当打开文件后编辑时由于编辑框的存在，每次完成文本编辑后均可以根据文本高度计算出行数，这个就比较准确，此时直接用setlinecount来设置行数。\r\n注：我的列表中只有名称列需要换行，其他列的文本就比较少，所以就不考虑换行了","timestamp":1590329650947},{"name":"143-qwebchannel.md","path":"13-语言学习project/12-python3/8-pyqt5/143-qwebchannel.md","content":"PyQt5 QWebChannel实现python与Javascript双向通信\r\n\r\nPyqt项目需要嵌入百度地图API，需要PyQt5与Javascript进行数据交互；网上的资料少切新旧不一，出于人人为我，我为人人的目的写下记录，希望后来人少走弯路。（替代方案：==WebSocket实现通信，该技术比较新==，后面再玩）。\r\n\r\n测试环境\r\n==Python3.6、PyQt5.11==\r\n\r\n功能描述\r\n\r\n## js => Pyqt5:\r\n\r\n运行程序，加载web页面后，点击上面的“点我”按钮，WEB则会调用 Web2PyQt5Value() 函数向python发送信息,类Myshared中的Web2PyQt5Value() 方法用于处理web发送来的信息，弹出消息对话框。\r\n\r\n## PyQt5 => js：\r\n\r\n程序运行5秒后，触发定时器函数 calljs(),通过page().runJavaScript(jscode)运行js代码——调用JS函数PyQt52WebValue()，弹出Alert警告框。\r\n\r\n函数具体用法:https://www.riverbankcomputing.com/static/Docs/PyQt5/search.html\r\n\r\n---\r\n\r\n需三个文件： main.py、\r\n\r\n```python\r\nfrom PyQt5.QtWidgets import QWidget, QApplication, QMessageBox,QMainWindow\r\nfrom PyQt5.QtWebEngineWidgets import QWebEngineView\r\nfrom PyQt5.QtWebChannel import QWebChannel\r\nfrom PyQt5.QtCore import pyqtSlot, Qt, QUrl, QFileInfo\r\nfrom PyQt5.QtCore import pyqtProperty, pyqtSignal\r\n \r\nclass Myshared(QWidget):\r\n \r\n    def __init__(self):\r\n        super().__init__()\r\n \r\n    def PyQt52WebValue(self):\r\n        return \"666\"\r\n \r\n    def Web2PyQt5Value(self, str):\r\n        QMessageBox.information(self, \"网页来的信息\", str)\r\n \r\n    value = pyqtProperty(str, fget=PyQt52WebValue, fset=Web2PyQt5Value)\r\n \r\nclass MainWindow(QMainWindow):\r\n    def __init__(self):\r\n        super(MainWindow, self).__init__()\r\n        self.setWindowTitle(\'Javascript call PyQt5\')\r\n        self.setGeometry(5, 30, 1355, 730)\r\n        self.browser = QWebEngineView()\r\n        # 加载外部的web界面\r\n        url = QUrl(QFileInfo(\"./web_file1.html\").absoluteFilePath())\r\n        self.browser.load(url)\r\n        self.setCentralWidget(self.browser)\r\n \r\n    def calljs(self):\r\n        jscode = \"PyQt52WebValue(\'你好web\');\"\r\n        self.browser.page().runJavaScript(jscode)\r\n \r\nimport sys\r\nfrom threading import Timer\r\nif __name__ == \'__main__\':\r\n    app = QApplication(sys.argv)\r\n    win = MainWindow()\r\n    channel = QWebChannel()\r\n    shared = Myshared()\r\n    channel.registerObject(\"con\", shared)\r\n    win.browser.page().setWebChannel(channel)\r\n    t = Timer(5, win.calljs)\r\n    t.start()\r\n \r\n    win.show()\r\n    sys.exit(app.exec_())\r\n```\r\nweb_file1.html\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>web channel</title>\r\n \r\n    <script src=\"qwebchannel.js\"></script>\r\n \r\n    <script language=\"JavaScript\">\r\n        function Web2PyQt5Value() {\r\n            if ( window.con) {\r\n                    window.con.value = \"你好 Pyqt5\";\r\n                }\r\n            }\r\n            function PyQt52WebValue(value){\r\n                alert(value);\r\n            }\r\n \r\n            document.addEventListener(\"DOMContentLoaded\", function () {\r\n                new QWebChannel( qt.webChannelTransport, function(channel) {\r\n                    window.con = channel.objects.con;\r\n                });\r\n            });\r\n \r\n    </script>\r\n \r\n</head>\r\n<body>\r\n    <button οnclick=\"Web2PyQt5Value()\">点我</button>\r\n</body>\r\n</html>\r\n```\r\n\r\n```\r\nqwebchannel.js\r\n```\r\n\r\n获取地址：https://doc-snapshots.qt.io/qt5-5.9/qtwebengine-webenginewidgets-markdowneditor-resources-qwebchannel-js.html\r\n\r\n\r\n\r\n### PyQt里js与python交互，js无法获取python返回值问题的解决办法\r\nPyQt中通过QWebEngineView和QWebChannel可以实现程序内嵌浏览器效果\r\n一般来说，核心代码如下：\r\n\r\n```python\r\n@pyqtSlot(str,result=str)\r\n    def print(self,aaa):\r\n        return aaa\r\n```\r\n```javascript\r\nwindow.onload = function () {\r\n   new QWebChannel(qt.webChannelTransport, function (channel) {\r\n        window.pyjs = channel.objects.pyjs;\r\n        alert(pyjs.myHello())//1. 这个不行\r\n        pyjs.myHello(alert);// 2. 这个可以\r\n        pyjs.print(\"sdafdsagf\",alert)// 3. 这个可以\r\n    });\r\n}\r\n```\r\n\r\n那么问题来了，为什么js中代码1不行，代码2和3就可以\r\n经过测试，我发现js调用Python函数时，传递给python的参数默认为构造函数，如果想传递自定义参数，随便传，只是在参数列表的最后，一定要加上回调函数，自定义参数需要在python函数的形参列表中声明，回调函数则是默认的，不需要声明。","timestamp":1590329650947},{"name":"144-开始开发.md","path":"13-语言学习project/12-python3/8-pyqt5/144-开始开发.md","content":"# Pyqt5 开发流程\r\n\r\n先看我的==源代码层的目录结构==：\r\n(其实不多，有效代码的文件就三个，以下讲解)\r\n\r\n（以上是本人习惯的命名，我会逐个讲解意思，您按自己的风格命名即可，包括后面的代码命名风格^-^）\r\n\r\n1. pycache__文件夹: 可以忽略，只是执行main文件时候的临时文件\r\n   images文件夹：是我放置图片资源以及生成Images.py资源模块的目录，里面内容如下：\r\n\r\n2. images.qrc文件可以用Qt工具QtCreator编辑，因为我以前安装过Qt环境，所以我直接就编辑了。\r\n   （给不是很熟悉Qt的朋友讲一下，QtCreator是Qt安装后的一个IDE开发工具，.qrc文件也是Qt用于管理资源文件的一个特定格式文件，其实它本质还是一个xml文件，把.png等资源文件管理起来，在后期编译的时候，通过配置编译到exe里面）\r\n\r\n接着==，我写了一个cmd脚本==，使用PyQt5工具，调用images.qrc生成Images. py并移动到上一级目录：\r\n*.png 通过images.qrc管理;\r\n当要与python发生联系时, 使用pyrcc5生成Images.py模块；\r\n为了工程管理，将Images.py移动到上一级\r\n\r\n以下是start.cmd脚本，实现以上流程：\r\n```cmd\r\n@echo off\r\ncd /d %~dp0\r\n\r\nset DIR=%~dp0\r\necho %DIR%\r\n\r\npyrcc5 -o .\\Images.py .\\images.qrc\r\n\r\nmove /Y %DIR%*.py %DIR%..\\\r\n```\r\n所以，每当我的images.qrc有更新时，我便执行start.cmd，以更新Images. py\r\n\r\n1. uis文件夹：是我管理.ui的文件夹，将.ui通过pyuic5 生成. py，原理跟资源管理类似。\r\n   .ui需要使用QtDesigner进行设计，即这就是我们的界面文件了，这儿有两个ui界面\r\n\r\n2. ui2py.bat：调用pyuic5，将一个.ui生成对应的 . py\r\n   start.cmd：批处理*.ui生成对应.py并将*.py移动到上一级，实际是start.cmd调用了ui2py.bat多次\r\n   （这儿我的命名习惯是\r\n   Login.ui --> Login. py\r\n   MainWindow.ui --> MainWindow. py）\r\n\r\n所以当我的.ui有更新时，我就执行下start.cmd以更新对应的所有由ui生成的py模块。\r\n\r\nui2py.bat脚本如下，关于批处理，可以任意发挥了：\r\n```bat\r\n@echo off\r\n@cd /d \"%~dp0\"\r\npyuic5 %1 > %~n1.py\r\n```\r\n==main. py==\r\n==LoginGUI. py==\r\n==MainWindowGUI. py==\r\n在这三个文件才是真正要写的代码。\r\nmain. py顾名思义，这是我们程序的入口，既然要结合python，我们的入口这样写：\r\n实现简单的登录成功、跳转逻辑，联动了两个界面。\r\n\r\n```python\r\nfrom sys import argv\t\t\t\t\t\t\t\t\r\nfrom PyQt5.QtWidgets import QApplication, QDialog\r\n\r\nfrom LoginGUI import CLoginGUI\t\t\t\t#界面Login\r\nfrom MainWindowGUI import CMainWindowGUI    #界面MainWindow\r\n\r\ndef main():\r\n\r\n    app = QApplication(argv)\r\n   \r\n    loginGui = CLoginGUI()\r\n    suc = loginGui.exec_()\r\n\r\n    if suc == QDialog.Accepted:\r\n        mainwindow = CMainWindowGUI()\r\n        mainwindow.show()\r\n\r\n        app.exec_() \r\n \r\nif __name__ == \'__main__\':\r\n    main()\r\n    # print(__name__)\r\n```\r\n接下来仔细讲解下LoginGUI. py如何关联ui：\r\n```python\r\nfrom PyQt5.QtWidgets import QDialog\r\nfrom PyQt5.Qt import QIcon\r\n\r\nimport Images\r\nimport Login\r\n\r\nclass CLoginGUI(QDialog, Login.Ui_Form):\r\n    def __init__(self, parent=None):\r\n        QDialog.__init__(self, parent)\r\n        self.setupUi(self)\r\n        \r\n        # 加入Qt资源\r\n        self.setWindowTitle(\"IIS用户登录\")\r\n        self.setWindowIcon(QIcon(\'://Login.png\'))\r\n\r\n\t\t# Qt信号与槽机制\r\n        self.pushButton_Login.clicked.connect(self.OnLoginBtnClicked)\r\n\r\n    def OnLoginBtnClicked(self):\r\n        self.accept()\r\n        self.close()\r\n```\r\n首先是import PyQt5相关的模块\r\n其次是引入Images资源模块\r\n引入Login界面模块，关联Login.ui\r\n（其实类似于，继承了QWidget或QDialog等的.cpp文件里的类，关联.ui文件）\r\n\r\n(当双击main. py或者在vs code下执行main.py时，会首先弹出如下登录界面，代表环境OK，Python脚本起该界面的所到之处OK)\r\n\r\n以上，我们就关联好了界面模块，资源模块，与我们要操作的界面类，其继承了QDialog，并且使用了信号与槽机制，实现了简单的交互。\r\n\r\n点击登录按钮，触发槽函数，登录成功后，跳转到MainWindow界面，以下是MainWindowGUI. py（多余的操作去掉了，为了方面理解，简洁），相关的关联逻辑与方式同LoginGUI .py：\r\n```python\r\nfrom PyQt5.QtWidgets import QWidget, QDialog\r\nfrom PyQt5.Qt import QIcon\r\n\r\nimport MainWindow\r\n\r\nclass CMainWindowGUI(QWidget, MainWindow.Ui_Form):\r\n    def __init__(self, parent=None):\r\n        QWidget.__init__(self, parent)\r\n        self.setupUi(self)\r\n    \r\n        self.setWindowTitle(\"涉密载体管理一体化综合信息系统\");\r\n        self.setWindowIcon(QIcon(\'://Main.png\'))\r\n```\r\n诚然，更多的界面和更复杂的开发，也是在这个基础上的延伸了。\r\n\r\n## 五、PyInstaller打包\r\n这儿是我坑遇到最多的地方，还是老生常谈：环境问题、兼容问题。可谓是不跳不知道，一跳必熬夜。事实上开发时刻轻飘飘，打包发布弄死人。\r\n我写了一个Install.cmd调用 PyInstaller -w main.py，生成了exe\r\n\r\n生成了build和dist文件夹，注意，有一个main.spec文件，这个就是剖析PyInstaller打包原理的入口了。build只是PyInstaller在打包时的中间文件，生成的exe或者exe+依赖库在dist下面。\r\n找到exe双击启动即可，如果不行，那就开始分析之路吧。\r\n如果您根据我上面的提示一步步安下来，打包还是会很顺利的，但如果您引入了许多包，失败的话，要一个个排查了，或者看PyInstaller生成的日志，在build下面warn-main.txt，定位问题。\r\n\r\n---\r\n这儿给一份定位问题的索引:\r\n\r\n是否包模块没有找到，试试 -p 包模块路径 手动加入呢？\r\n是否python脚本本身bug，先调试启动试试呢？\r\n可以在打包时，试试-c，将控制台打开，或者将生成的exe拖入控制台执行，看看具体报的什么错；\r\n能否定位到某个模块的问题，降个版本试试呢，或者先屏蔽掉吧？\r\n都不行，看看.spec文件能否获得一些线索。\r\n平台合理吗，64bit python下打包的放在win32的系统下可不行哦。\r\n\r\n## 六、其他问题\r\n这儿有一个要注意的地方，怎样获取自己的一些配置文件路径呢，很简单，知道exe路径，不就可以知道配置文件相对路径了吗？是的，那么怎么获取exe路径呢？特别是打包后。\r\n\r\n最开始，我是这么调的\r\nsys.path[0]\r\n1\r\n在调试启动，或双击main.py启动时，没问题，它会获取main.py的路径，仔细了解了sys模块的path的相关介绍，确实就是[0]，但在打包为exe后，它的路径就找到Windows下AppData的…之类路径里去了，像是python的默认文件指定目录，导致我一直初始化失败。\r\n```python\r\nimport sys\r\nimport os\r\n\r\nprint(sys.path[0])\r\nprint(sys.argv[0])\r\nprint(os.path.dirname(os.path.realpath(sys.executable)))\r\nprint(os.path.dirname(os.path.realpath(sys.argv[0])))\r\n```\r\n后来试了其它方法，便解决了，==os.path.dirname(os.path.realpath(sys.argv[0]))== 这个最靠谱，其他的大家有兴趣可以打包为exe后，打印出路径看效果。\r\n\r\n","timestamp":1590329650947},{"name":"145-窗体总在最前端.md","path":"13-语言学习project/12-python3/8-pyqt5/145-窗体总在最前端.md","content":"PyQt5学习教程20：窗体总在最前端\r\n snmplink 最后发布于2018-03-04 23:31:18 阅读数 2802  收藏 2\r\n展开\r\n本文介绍使得窗体总在最前端的PyQt的实现方法。\r\n\r\n我们可以给窗体加入QtCore.Qt.WindowStaysOnTopHint属性的方法，使得窗体总在最前端，具体程序如下：\r\n\r\n```python\r\n    self.resize(790, 542)\r\n    self.setFont(font)\r\n    self.setWindowFlags(QtCore.Qt.WindowMinimizeButtonHint |   # 使能最小化按钮\r\n                        QtCore.Qt.WindowCloseButtonHint |      # 使能关闭按钮\r\n                        QtCore.Qt.WindowStaysOnTopHint)        # 窗体总在最前端\r\n    self.setFixedSize(self.width(), self.height())             # 固定窗体大小\r\n```\r\n该程序首先设定窗体的大小和字体，然后给窗体设置了使能最小化和关闭按钮，也就是没有使能最大化按钮，和窗体总在最前端属性，接下来固定了窗体的大小。\r\n\r\n在项目中加入上述代码后，就可以发现窗体一直保持在最前端。","timestamp":1590329650947},{"name":"146-WingIDE使用.md","path":"13-语言学习project/12-python3/9-wing IDE/146-WingIDE使用.md","content":"[Python]WingIDE的使用经验总结\r\n\r\n嗨学编程 2019-03-21 15:17:46  1095  收藏\r\n展开\r\n0：WingIDE的使用\r\n好的工具可以让你做事时，事半功倍！这一点在写代码的过程中尤为明显，使用Pyhton写程序有一年多了！各类编辑器IDE也使用了不少，如Pycharm,sublime,Qtcreator等等，最近开始使用WingIDE，发现使用起来非常顺手，而且支持目前所有主流操作系统！这篇博文用来记录总结，在安装和使用WingIDE过程中的一些有用的经验，技巧！\r\n\r\n- 在windows平台下的安装\r\n\r\n```\r\n1：首先安装python开发环境\r\n2：添加python路径到系统path\r\n3：下载安装WingIDE (破解)\r\n```\r\n\r\n- Debain平台下的安装\r\n\r\n```\r\n由于在Linux平台下，python一般是默认安装的，所以直接到官方下载Deb包，然后安装即可\r\nsudo dpkg -i xxx.deb\r\n```\r\n\r\n### `2:WingIDE主题的选择`\r\n\r\n- 选择如上图主题风格的方法，看下面的动态图的操作\r\n- 默认的字体对本人来说有点小，通过Edit->Preferences->User Interface->Fonts进行调整\r\n  ![图片描述](https://image-static.segmentfault.com/424/569/4245690624-573af9996c5c1_articlex)\r\n\r\n## `3:常用快捷键`\r\n\r\n- F1 = 上下框的开合\r\n- F2 = 左右框的开合\r\n- Tab = 自动补全功能\r\n- 习惯使用enter or space键补全的朋友可以通过下面方法设置\r\n- 设置补全键：Edit->Keybord Personality->Config auto..->Editors->Auto-completion\r\n- 显示行号的选项：Edit -> Show(Hide) Line Numbers\r\n\r\n下面图看不清时，请单击图片，放大观看\r\n\r\n| F1 F2操作效果 | ![图片描述](D:\\Typora_pic\\1763311561-573b023350abf_articlex.gif) |\r\n| ------------| ------------------------------------------------------------ |\r\n| 单文件分成多编辑窗口 | ![图片描述](D:\\Typora_pic\\317838250-573b0243c4f6b_articlex.gif) |\r\n\r\n官网下载链接：http://wingware.com/downloads\r\n\r\n\r\n\r\n想要学习Python？Python学习交流群：984632579满足你的需求，资料都已经上传群文件，可以自行下载！\r\n\r\n1:WingIDE的安装\r\n在windows平台下的安装\r\n\r\n1：首先安装python开发环境\r\n\r\n2：添加python路径到系统path\r\n\r\n3：下载安装WingIDE (破解)\r\n\r\nDebain平台下的安装\r\n\r\n由于在Linux平台下，python一般是默认安装的，所以直接到官方下载Deb包，然后安装即可sudodpkg-ixxx.deb\r\n\r\n2:WingIDE主题的选择\r\n选择如上图主题风格的方法，看下面的动态图的操作\r\n\r\n默认的字体对本人来说有点小，通过Edit->Preferences->User Interface->Fonts进行调整\r\n\r\n\r\n\r\n3:常用快捷键\r\n\r\n```\r\nF1 = 上下框的开合\r\nF2 = 左右框的开合\r\nTab = 自动补全功能\r\n```\r\n\r\n==习惯使用enter or space键补全的朋友可以通过下面方法设置==\r\n\r\n设置补全键：Edit->Keybord Personality->Config auto..->Editors->Auto-completion\r\n\r\n显示行号的选项：Edit -> Show(Hide) Line Numbers\r\n------------------------------------------------\r\n3.设置WingIDE运行环境为系统安装的Python\r\n\r\nWingIDE运行时会运行IDE自带的Python，不是系统的Python，所以需要进行配置。\r\n\r\nProject-->Project properties，在Python Path中选择Custom，然后点击Insert，在弹出的对话框中选择Python安装路径，点击OK\r\n\r\n![img](D:\\Typora_pic\\20160108111656682.png)![img](D:\\Typora_pic\\20160108111828859.png)\r\n\r\n\r\n\r\n为了验证是否配置成功 ，我们先在命令行执行\r\n\r\npip install xlrd\r\n\r\n然后我们在WingIDE新建一个Python文件，如果能正常的import这个库说明配置成功，能正常import的都在提示里，不能正常import的不在提示里并且运行时会报错\r\n\r\n![img](D:\\Typora_pic\\20160108112406242.png)","timestamp":1590329650947},{"name":"170-Untitled.md","path":"13-语言学习project/13-Vue/170-Untitled.md","content":"![image-20200512212304432](D:\\Typora_pic\\image-20200512212304432.png)\r\n\r\n## v-bind:   绑定vue的变量\r\n\r\n![image-20200512212656084](D:\\Typora_pic\\image-20200512212656084.png)\r\n\r\n## v-once:  只初始化一次\r\n\r\n![image-20200512212831732](D:\\Typora_pic\\image-20200512212831732.png)\r\n\r\n## 转义和不转义\r\n\r\n![image-20200512213029635](D:\\Typora_pic\\image-20200512213029635.png)\r\n\r\n![image-20200512213212532](D:\\Typora_pic\\image-20200512213212532.png)\r\n\r\n## v-on:    监听事件\r\n\r\n![image-20200512213514785](D:\\Typora_pic\\image-20200512213514785.png)\r\n\r\n![image-20200512213904456](D:\\Typora_pic\\image-20200512213904456.png)\r\n\r\n![image-20200512214149883](D:\\Typora_pic\\image-20200512214149883.png)\r\n\r\n## 事件冒泡\r\n\r\n![image-20200512214157658](D:\\Typora_pic\\image-20200512214157658.png)\r\n\r\n![image-20200512214308498](D:\\Typora_pic\\image-20200512214308498.png)\r\n\r\n```html\r\n// 阻止冒泡\r\n<a href=\"http://www.baidu.com\" v-on:mousemove.stop=\"\"></a>\r\n// 阻止默认行为\r\n<a href=\"http://www.baidu.com\" v-on:click.prevent=\"\"></a>\r\n\r\n// 既阻止冒泡也阻止默认行为\r\n<a href=\"http://www.baidu.com\" v-on:mousemove.stop.prevent=\"\"></a>\r\n```\r\n\r\n## 按键休止符\r\n\r\n![image-20200512214744779](D:\\Typora_pic\\image-20200512214744779.png)\r\n\r\n```\r\nv-on:keyup.enter\r\nv-on:keyup.space.\r\nv-on:keyup.space.enter\r\nv-on:keyup.space.13    #13代表回车键\r\n```\r\n\r\n## html模板\r\n\r\n![image-20200512215247459](D:\\Typora_pic\\image-20200512215247459.png)\r\n\r\n## 数据双向绑定\r\n\r\n![image-20200512215613081](D:\\Typora_pic\\image-20200512215613081.png)\r\n\r\n双向绑定\r\n\r\n![image-20200512215644289](D:\\Typora_pic\\image-20200512215644289.png)\r\n\r\n## 监听数据:\r\n\r\n![image-20200512220139477](D:\\Typora_pic\\image-20200512220139477.png)\r\n\r\n![image-20200512220422386](D:\\Typora_pic\\image-20200512220422386.png)\r\n\r\n## 简写\r\n\r\n```\r\nv-on:click=\"increase\"   @click=\"increase\"\r\nv-bind:title\t\t\t:title\r\n```\r\n\r\n# Vue修改页面样式\r\n\r\n<img src=\"D:\\Typora_pic\\image-20200512221317873.png\" alt=\"image-20200512221317873\" />\r\n\r\n![image-20200512221700990](D:\\Typora_pic\\image-20200512221700990.png)\r\n\r\n修改类class\r\n\r\n![image-20200512221839513](D:\\Typora_pic\\image-20200512221839513.png)\r\n\r\n修改样式\r\n\r\n![image-20200512222047877](D:\\Typora_pic\\image-20200512222047877.png)\r\n\r\n# 条件渲染 v-if\r\n\r\n![image-20200512222419815](D:\\Typora_pic\\image-20200512222419815.png)\r\n\r\n![image-20200512222718974](D:\\Typora_pic\\image-20200512222718974.png)\r\n\r\n## 列表\r\n\r\n![image-20200512222957343](D:\\Typora_pic\\image-20200512222957343.png)\r\n\r\n![image-20200512223039939](D:\\Typora_pic\\image-20200512223039939.png)\r\n\r\n## 对象\r\n\r\n![image-20200512223156856](D:\\Typora_pic\\image-20200512223156856.png)\r\n\r\n![image-20200512223230567](D:\\Typora_pic\\image-20200512223230567.png)\r\n\r\ntempelete 模板容器,不会显示\r\n\r\n![image-20200512223258658](D:\\Typora_pic\\image-20200512223258658.png)\r\n\r\n![image-20200512223649605](D:\\Typora_pic\\image-20200512223649605.png)\r\n\r\n![image-20200512223753544](D:\\Typora_pic\\image-20200512223753544.png)\r\n\r\n![image-20200512223835589](D:\\Typora_pic\\image-20200512223835589.png)\r\n\r\n![image-20200512224009909](D:\\Typora_pic\\image-20200512224009909.png)\r\n\r\n# cli使用\r\n\r\n## 组件\r\n\r\n全局组件\r\n\r\n![image-20200512225556963](D:\\Typora_pic\\image-20200512225556963.png)\r\n\r\n![image-20200512225628313](D:\\Typora_pic\\image-20200512225628313.png)\r\n\r\n局部组件\r\n\r\n![image-20200512225753471](D:\\Typora_pic\\image-20200512225753471.png)\r\n\r\n![image-20200512225858895](D:\\Typora_pic\\image-20200512225858895.png)\r\n\r\n![image-20200512231719583](D:\\Typora_pic\\image-20200512231719583.png)\r\n\r\n![image-20200512231738162](D:\\Typora_pic\\image-20200512231738162.png)\r\n\r\n![image-20200512231743995](D:\\Typora_pic\\image-20200512231743995.png)\r\n\r\n![image-20200512231858705](D:\\Typora_pic\\image-20200512231858705.png)\r\n\r\n## 组件之间传值\r\n\r\n![image-20200512232646241](D:\\Typora_pic\\image-20200512232646241.png)![image-20200512232915227](D:\\Typora_pic\\image-20200512232915227.png)","timestamp":1590329650947},{"name":"62-npm更换成淘宝镜像源以及cnpm.md","path":"13-语言学习project/62-npm更换成淘宝镜像源以及cnpm.md","content":"# [npm更换成淘宝镜像源以及cnpm](https://www.cnblogs.com/onew/p/11330439.html)\r\n\r\n#### 1.需求由来\r\n\r\n由于node安装插件是从国外服务器下载，受网络影响大，速度慢且可能出现异常。所以如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队（[阿里巴巴](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%2F9087864%3Ffromtitle%3D%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%26fromid%3D33)旗下业务[阿里云](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E9%98%BF%E9%87%8C%E4%BA%91)）干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。\r\n\r\n也就是说我们可以使用阿里布置在国内的服务器来进行node安装。\r\n\r\n#### 2.使用方法\r\n\r\n1.使用阿里定制的 cnpm 命令行工具代替默认的 npm，输入下面代码进行安装：\r\n\r\n```\r\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\r\n```\r\n\r\n2.检测cnpm版本，如果安装成功可以看到cnpm的基本信息。\r\n\r\n```\r\ncnpm -v\r\n```\r\n\r\n3.以后安装插件只需要使用`cnpm intall`即可\r\n\r\n------\r\n\r\n> 假如我已经习惯了`npm install`的安装方式，我不想去下载阿里的cnpm命令工具将命令变成cnpm怎么办？很容易我们想到，我直接将node的仓库地址改成淘宝镜像的仓库地址不就好了吗？\r\n\r\n#### 3.单次使用\r\n\r\n```\r\nnpm install --registry=https://registry.npm.taobao.org\r\n```\r\n\r\n#### 4.永久使用\r\n\r\n设置成全局的下载镜像站点，这样每次install的时候就不用加--registry，默认会从淘宝镜像下载，设置方法如下：\r\n\r\n```\r\n1.打开.npmrc文件（nodejs\\node_modules\\npm\\npmrc，没有的话可以使用git命令行建一个( touch .npmrc)，用cmd命令建会报错）\r\n2.增加 registry =https://registry.npm.taobao.org  即可。\r\n```\r\n\r\n也可以按如下方式直接在命令行设置\r\n\r\n```\r\nnpm config set registry https://registry.npm.taobao.org\r\n```\r\n\r\n检测是否成功","timestamp":1590329650947},{"name":"63-PyQt5 打造编辑器.md","path":"13-语言学习project/63-PyQt5 打造编辑器.md","content":"[![返回主页](F:\\Typora_book\\typora_pic\\logo-1576291678027.gif)](https://www.cnblogs.com/aloe-n/)\r\n\r\n# [PyQt5 打造编辑器](https://www.cnblogs.com/aloe-n/p/9583949.html)\r\n\r\n## 效果如下\r\n\r\n- 多标签\r\n- 智能提示\r\n- 快捷键\r\n  ![img](F:\\Typora_book\\typora_pic\\1176578-20180904135007320-465221616.png)\r\n\r\n## 思路\r\n\r\n编辑器(右侧部分)采用 monaco editor ，monaco editor是微软开源的编辑器，使用TypeScript编写，是大名鼎鼎的VSCode编辑器的内核。所以其使用习惯和VSCode完全相同。 [monaco editor](https://microsoft.github.io/monaco-editor/)\r\n\r\nmonaco editor 是需要运行在浏览器中的（supports IE 11, Edge, Chrome, Firefox, Safari and Opera.), 那么怎么能将它嵌入Qt中呢? Qwebengineview 控件可以帮我们实现.\r\n\r\n## 1. 定义编辑器类\r\n\r\nEditor类继承自QWebEngineView,所以才能使用load方法加载本地HTML文件\r\n\r\n```python\r\nimport os\r\nfrom PyQt5 import QtWidgets\r\nfrom PyQt5.QtCore import QUrl\r\nfrom PyQt5.QtWebEngineWidgets import QWebEngineView\r\n\r\n\r\nclass Editor(QWebEngineView):\r\n    def __init__(self, par):\r\n        super().__init__(par)\r\n        self.editor_flag = []\r\n\r\n        # 这里是本地html路径,需根据实际情况进行修改.\r\n        self.editor_index = (os.path.split(os.path.realpath(__file__))[0]) + \"/../utils/index.html\"\r\n        self.load(QUrl.fromLocalFile(self.editor_index))\r\n\r\n    def get_value(self, callback):\r\n        \"\"\"设置编辑器内容\"\"\"\r\n        self.page().runJavaScript(\"monaco.editor.getModels()[0].getValue()\", callback)\r\n\r\n    def set_value(self, data):\r\n        \"\"\"获取编辑器内容\"\"\"\r\n        import base64\r\n        data = base64.b64encode(data.encode())\r\n        data = data.decode()\r\n        self.page().runJavaScript(\"monaco.editor.getModels()[0].setValue(Base.decode(\'{}\'))\".format(data))\r\n\r\n    def change_language(self, lan):\r\n        \"\"\"切换智能提示语言\"\"\"\r\n        self.page().runJavaScript(\"monaco.editor.setModelLanguage(monaco.editor.getModels()[0],\'{}\')\".format(lan))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import sys\r\n    app = QtWidgets.QApplication(sys.argv)\r\n    w = Editor(None)\r\n    w.setWindowTitle(\'Editor\')\r\n    w.show()\r\n    sys.exit(app.exec_())\r\n```\r\n\r\nindex.html 其实就是monaco editor 的入口,内容如下:\r\n\r\n**引入的monaco editor文件需要自行下载 [下载地址](https://microsoft.github.io/monaco-editor/)**\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\">\r\n    <style type=\"text/css\">\r\n        html, body {\r\n            width: 100%;\r\n            height: 100%;\r\n            margin: 0;\r\n            padding: 0;\r\n            overflow: hidden;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n\r\n<div id=\"container\" style=\"width:100%;height:100%\"></div>\r\n\r\n<!-- 引入base64方法,设置编辑器内容时使用-->\r\n<script src=\"./base64.js\"></script>   \r\n<!-- 根据实际路径进行修改 -->\r\n<script src=\"./package/dev/vs/loader.js\"></script>\r\n<script>\r\n    // <!-- 根据实际路径进行修改 -->\r\n    require.config({paths: {\'vs\': \'./package/dev/vs\'}});\r\n    require([\'vs/editor/editor.main\'], function () {\r\n        monaco.languages.typescript.javascriptDefaults.setDiagnosticsOptions({\r\n        noSemanticValidation: true,\r\n        noSyntaxValidation: true\r\n    });\r\n        editor = monaco.editor.create(document.getElementById(\'container\'), {\r\n            value: \"\",\r\n            language: \'javascript\',  //默认语言\r\n            mouseWheelZoom:true,     // 鼠标滚轮缩放\r\n            wordWrap:\"on\",           // 自动换行\r\n            scrollBeyondLastLine:false,\r\n            minimap:{\r\n                enabled:false          // 显示右侧小地图\r\n            }\r\n        });\r\n        window.onresize = function () {\r\n            editor.layout();\r\n        };\r\n    });\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n启动后效果如下:\r\n\r\n![img](F:\\Typora_book\\typora_pic\\1176578-20181025214610227-930301139.png)\r\n\r\n## 2. 在主界面中添加编辑器标签(多标签的实现)\r\n\r\n- 增加标签\r\n- 关闭标签\r\n\r\nQTabwidget刚好可以满足多标签的需求,下面有几个问题要解决:\r\n\r\n1. 每个标签右上角显示关闭按钮\r\n   默认情况下,标签是不显示关闭按钮的,可以通过设置`self.tabWidget.setTabsClosable(True)`方法显示出关闭按钮.\r\n\r\n2. 关闭按钮点击事件\r\n\r\n   ```\r\n   self.tabWidget.tabCloseRequested.connect(self.closeTab)\r\n   \r\n   def closeTab(self):\r\n   # 获取当前处于激活状态的标签\r\n   i = self.tabWidget.currentIndex()\r\n   self.tabWidget.removeTab(i)\r\n   ```\r\n\r\n3. 增加页面\r\n\r\n   ```\r\n   new_tab = Editor(self)\r\n   self.tabWidget.addTab(new_tab, tab_name)\r\n   self.tabWidget.setCurrentWidget(new_tab)\r\n   ```\r\n\r\n[好文要顶](javascript:void(0);) [关注我](javascript:void(0);) [收藏该文](javascript:void(0);) [![img](F:\\Typora_book\\typora_pic\\icon_weibo_24.png)](javascript:void(0);) [![img](F:\\Typora_book\\typora_pic\\wechat.png)](javascript:void(0);)\r\n\r\n[Aloe_n](https://home.cnblogs.com/u/aloe-n/)\r\n[关注 - 0](https://home.cnblogs.com/u/aloe-n/followees/)\r\n[粉丝 - 4](https://home.cnblogs.com/u/aloe-n/followers/)\r\n\r\n[+加关注](javascript:void(0);)\r\n\r\n1\r\n\r\n0\r\n\r\n[« ](https://www.cnblogs.com/aloe-n/p/9583909.html)上一篇： [python RSA 相关方法](https://www.cnblogs.com/aloe-n/p/9583909.html) \r\n[» ](https://www.cnblogs.com/aloe-n/p/9774744.html)下一篇： [windows平台下mysql 8.0 免安装版配置步骤](https://www.cnblogs.com/aloe-n/p/9774744.html)\r\n\r\nposted @ 2018-09-04 13:50 [Aloe_n](https://www.cnblogs.com/aloe-n/) 阅读(1104) 评论(3) [编辑 ](https://i.cnblogs.com/EditPosts.aspx?postid=9583949)[收藏](javascript:void(0))\r\n\r\n\r\n\r\n\r\n\r\n评论列表\r\n\r\n \r\n\r\n[#1楼](https://www.cnblogs.com/aloe-n/p/9583949.html#4176799) 2019-02-09 22:52 [fenger2508](https://home.cnblogs.com/u/1599928/)\r\n\r\n大神，你好，向你请教一个问题，“启动后效果如下:” 要怎么做才能出现那个效果呢，我是新手，还请耐心解答一下，谢谢。qq: 1831722663\r\n\r\n[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)\r\n\r\n \r\n\r\n[#2楼](https://www.cnblogs.com/aloe-n/p/9583949.html#4329988) 2019-08-18 19:27 [無駄、無馱](https://www.cnblogs.com/ffqk/)\r\n\r\n大神在么,这个<script src=\"./base64.js\"></script> 引入的base64.js是什么文件,我的弄好了,但是编辑器无法输入中文,只能输入英文\r\n\r\n[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)\r\n\r\n \r\n\r\n[#3楼](https://www.cnblogs.com/aloe-n/p/9583949.html#4330330) [楼主] 2019-08-19 10:18 [Aloe_n](https://www.cnblogs.com/aloe-n/)\r\n\r\n[@](https://www.cnblogs.com/aloe-n/p/9583949.html#4329988) 無駄、無馱\r\n应该是编辑器IME的问题,试试搜狗输入法可以不.\r\n\r\n[支持(0) ](javascript:void(0);)[反对(0)](javascript:void(0);)\r\n\r\n\r\n\r\n[刷新评论](javascript:void(0);)[刷新页面](https://www.cnblogs.com/aloe-n/p/9583949.html#)[返回顶部](https://www.cnblogs.com/aloe-n/p/9583949.html#top)\r\n\r\n注册用户登录后才能发表评论，请 [登录](javascript:void(0);) 或 [注册](javascript:void(0);)， [访问](https://www.cnblogs.com/) 网站首页。\r\n\r\n[【推荐】超50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库](http://www.ucancode.com/index.htm)\r\n[【推荐】腾讯云热门云产品限时秒杀，爆款1核2G云服务器99元/年！](https://cloud.tencent.com/act/seckill?fromSource=gwzcw.3168381.3168381.3168381&utm_medium=cpc&utm_id=gwzcw.3168381.3168381.3168381)\r\n[【推荐】阿里云双11返场来袭，热门产品低至一折等你来抢！](http://click.aliyun.com/m/1000081987/)\r\n[【推荐】物理看板和电子看板该如何选择？](https://bbs.huaweicloud.com/forum/thread-24443-1-1.html)\r\n[【活动】京东云服务器_云主机低于1折，低价高性能产品备战双11](https://www.jdcloud.com/cn/activity/year-end?utm_source=DMT_cnblogs&utm_medium=CH&utm_campaign=q4vm&utm_term=Virtual-Machines)\r\n[【活动】ECUG For Future 技术者的年度盛会（杭州，1月4-5日）](http://hdxu.cn/JH9N4)\r\n\r\n<iframe id=\"google_ads_iframe_/1090369/C1_0\" title=\"3rd party ad content\" name=\"google_ads_iframe_/1090369/C1_0\" width=\"300\" height=\"250\" scrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" srcdoc=\"\" data-google-container-id=\"1\" data-load-complete=\"true\" style=\"margin: 0px; padding: 0px; border: 0px; vertical-align: bottom;\"></iframe>\r\n<iframe id=\"google_ads_iframe_/1090369/C2_0\" title=\"3rd party ad content\" name=\"google_ads_iframe_/1090369/C2_0\" width=\"468\" height=\"60\" scrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" srcdoc=\"\" data-google-container-id=\"2\" data-load-complete=\"true\" style=\"margin: 0px; padding: 0px; border: 0px; vertical-align: bottom;\"></iframe>\r\n**最新 IT 新闻**: \r\n· [突发！村田关闭中国2家工厂！](https://news.cnblogs.com/n/651918/) \r\n· [世界多个人脸识别系统被“欺骗”，美国 AI 公司称用 3D 面具即可破解](https://news.cnblogs.com/n/651917/) \r\n· [华为荣获国内首家5G核心网电信设备进网许可证](https://news.cnblogs.com/n/651916/) \r\n· [了不起的 AirPods](https://news.cnblogs.com/n/651915/) \r\n· [新发现：热传递的第四种方式](https://news.cnblogs.com/n/651914/) \r\n» [更多新闻...](https://news.cnblogs.com/)\r\n\r\n**历史上的今天：** \r\n2018-09-04 [python RSA 相关方法](https://www.cnblogs.com/aloe-n/p/9583909.html) \r\n\r\nCopyright © 2019 Aloe_n \r\nPowered by .NET Core 3.1.0 on Linux","timestamp":1590329650947},{"name":"64-用Python写个Metro风格的桌面程序.md","path":"13-语言学习project/64-用Python写个Metro风格的桌面程序.md","content":"## 用Python写个Metro风格的桌面程序\r\n\r\n![img](F:\\Typora_book\\typora_pic\\f1b877ad7ef30c4d6679ae6930706c13.jpeg)\r\n\r\nDigiHacker\r\n\r\n发布时间：18-10-0512:10\r\n\r\nPython有很多GUI库，比如自带的tkinter, Qt, wxPython等, 还有基于OpenGL的Kivy。但是学习曲线都很高，要学习layout, 组件库，事件驱动等。现在有了electron的话，我们可以用Python写个后台服务，但还是要学习electron的API。搜了搜发现了eel这个库，可以直接用Python和一点html知识就可以创建桌面程序。\r\n\r\n首先当然要`pip install eel,` 然后写个简单的python程序，初始化和启动eel\r\n\r\n\r\n\r\n```python\r\nimport eel\r\neel.init()\r\n```\r\n\r\n\r\n\r\n<img src=\"d:\\typora_pic\\u=3857751769,1900717845&amp;fm=173&amp;app=25&amp;f=JPEG.jpg\" alt=\"img\" style=\"zoom:200%;\" />\r\n\r\ninit方法会读取web目录下的文件，ssl.expose会暴露下面的方法给前端，javascript就可以通过eel.hello()调用它了. 最后启动eel\r\n\r\n第二步我们创建一个web目录，新建一个index.html\r\n\r\n![img](F:\\Typora_book\\typora_pic\\u=82041708,2054882243&fm=173&app=25&f=JPEG.jpg)\r\n\r\n在head里，我们要引用下metroui必需的css和js文件，eel也需要引用一个eel.js。因为后台python和前端是两个进程，要获取数据的话，我们就需要async和await两个关键字去从后台取数据，同时方法名后加一对额外的括号。如果不需要数据的话，则直接eel.hello()就好。\r\n\r\n在copyval方法里我们调用python hello方法，获取值后用jQuery赋值给textarea。\r\n\r\n![img](F:\\Typora_book\\typora_pic\\u=13642212,572288084&fm=173&app=25&f=JPEG.jpg)\r\n\r\nnav里用的是metroui自带的菜单和图标，并没有什么神秘的地方。\r\n\r\n最后的效果如下，象不象最新版的Office?\r\n\r\n![img](F:\\Typora_book\\typora_pic\\u=3133174934,1126146377&fm=173&app=25&f=JPEG.jpg)","timestamp":1590329650947},{"name":"65-踩坑.md","path":"13-语言学习project/65-踩坑.md","content":"# 踩坑---使用Draft.js进行开发富文本编辑器\r\n\r\n[![img](F:\\Typora_book\\typora_pic\\e0e4937e-c4ab-4cf1-94a6-3c0f9d34d928.webp)](https://www.jianshu.com/u/66f46f479864)\r\n\r\n[榭安](https://www.jianshu.com/u/66f46f479864)关注\r\n\r\n0.3362018.12.20 00:52:07字数 530阅读 684\r\n\r\n又来了\r\n\r\n# **[draft-js官方文档](https://github.com/facebook/draft-js)**\r\n\r\n# **[Github 上 awesome-draft-js](https://github.com/nikgraf/awesome-draft-js)**\r\n\r\nhttps://www.draft-js-plugins.com/plugin/image\r\n\r\n\r\n\r\n```undefined\r\n先整理一下链接   如下\r\n```\r\n\r\n# 首推这篇文章，demo内容覆盖很全，感觉是个大佬[基于Draft.js自定义富文本编辑器](https://www.jianshu.com/p/6a01f1f71fd2)\r\n\r\n[draft.js：不要使用redux来管理editorState](https://blog.csdn.net/sinat_24070543/article/details/80387119)\r\n\r\n[draft.js：让光标显示在最后面](https://blog.csdn.net/sinat_24070543/article/details/80384433)\r\n\r\n[draft.js：内容清空之后，光标的位置会错乱](https://blog.csdn.net/sinat_24070543/article/details/80387181)\r\n\r\n[draft.js：如何改变 draft.js 编辑框的高度](https://blog.csdn.net/sinat_24070543/article/details/80384624)\r\n\r\n[draft.js：getPlainText 对换行符的修改 (填坑篇)](https://blog.csdn.net/sinat_24070543/article/details/80373155)\r\n\r\n[draft.js：onChange改装，判断文字内容是否修改](https://blog.csdn.net/sinat_24070543/article/details/80372906)\r\n\r\n[draft.js--富文本编辑器框架的实践（一）](https://blog.csdn.net/oak160/article/details/78130971)\r\n\r\n[draft.js--富文本编辑器框架的实践（二）](https://blog.csdn.net/oak160/article/details/78134444)\r\n\r\n[原 1.Draftjs 学习笔记](https://blog.csdn.net/ohmyauthentic/article/details/53519299)\r\n[原 2.Draftjs 学习笔记-Rich Styling](https://blog.csdn.net/ohmyauthentic/article/details/53519713)\r\n[原 3.Draftjs 学习笔记-Entities](https://blog.csdn.net/ohmyauthentic/article/details/53521947)\r\n[原 4.Draftjs 学习笔记-Decorators](https://blog.csdn.net/ohmyauthentic/article/details/53522086)\r\n[原 5.Draftjs 学习笔记-自定义控件（多媒体）](https://blog.csdn.net/ohmyauthentic/article/details/53787010)\r\n[原 6.Draftjs 学习笔记-聊聊自定义样式](https://blog.csdn.net/ohmyauthentic/article/details/66973250)\r\n[原 7.Draftjs 学习笔记-StateToHtml](https://blog.csdn.net/ohmyauthentic/article/details/69468973)\r\n\r\n[Draftjs中文翻译1 - 概观](https://blog.csdn.net/J_Y_X_8/article/details/79483911)\r\n[Draftjs中文翻译2 - API Basics API基础](https://blog.csdn.net/J_Y_X_8/article/details/79484091)\r\n[Draftjs中文翻译3 - Rich Styling丰富的造型](https://blog.csdn.net/J_Y_X_8/article/details/79484277)\r\n[Draftjs中文翻译4- 实体](https://blog.csdn.net/J_Y_X_8/article/details/79513680)\r\n[Draftjs中文翻译5 - v0.10 API迁移](https://blog.csdn.net/J_Y_X_8/article/details/79513717)\r\n\r\n[Draft.js文档](https://draftjs.org/docs/getting-started.html)\r\n[使用 Draft.js 来构建一个现代化的编辑器](https://juejin.im/entry/597be4d76fb9a03c32238e80)\r\n[draft.js在知乎的实践](https://zhuanlan.zhihu.com/p/24951621)\r\n[基于Draft.js自定义富文本编辑器](https://www.jianshu.com/p/6a01f1f71fd2)\r\n\r\n[基于Draftjs实现的Electron富文本聊天输入框](https://www.jianshu.com/p/0d22b3bf96a5)\r\n[基于Draftjs实现的Electron富文本聊天输入框(一) —— 群@功能](https://www.jianshu.com/p/c2bb4ed42172)\r\n[基于Draftjs实现的Electron富文本聊天输入框(二) —— 图文输入](https://www.jianshu.com/p/4acdde47d0d5)\r\n[基于Draftjs实现的Electron富文本聊天输入框(三) —— Emoji](https://www.jianshu.com/p/92eb4049780b)\r\n[基于Draftjs实现的Electron富文本聊天输入框(四) —— 自定义快捷键](https://www.jianshu.com/p/68e82cf7e1ad)\r\n[基于Draftjs实现的Electron富文本聊天输入框(五) —— 问题总结与解决](https://www.jianshu.com/p/9546c7176b7a)\r\n\r\n### 在Draft.js中插入图片时，会产生空行，百度不到答案，还是需要Stack Overflow啊\r\n\r\n# [How to properly add image (atomic) without 2 empty lines in Draft.js](https://stackoverflow.com/questions/41039315/how-to-properly-add-image-atomic-without-2-empty-lines-in-draft-js)\r\n\r\n完美解决问题！\r\n还有下一个问题：光标位置错乱 待解决！！！","timestamp":1590329650947}]