if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m1']=[{"name":"30-pyqt5中qwidget布局的问题.md","path":"1-code疑难搜索/30-pyqt5中qwidget布局的问题.md","content":"# 浅谈pyqt5在QMainWindow中布局的问题\r\n\r\n 更新时间：2019-06-25 03:02:41  作者：佚名  [![img](F:\\Typora_book\\typora_pic\\text-message.png) 我要评论(0)](http://www.52codes.net/develop/shell/57846.html#comments)\r\n\r\n引言：\r\n在pyqt5中使用了父类为QMainWindow的话，在里面使用布局类，QGridLayout， QHBoxLayout ，QVBoxLayout 时，发现不好用。\r\n解决：\r\n如果是在以QWidget为父\r\n\r\n\r\n\r\n**引言：**\r\n\r\n在pyqt5中使用了父类为QMainWindow的话，在里面使用布局类，QGridLayout， QHBoxLayout ，QVBoxLayout 时，发现不好用。\r\n\r\n# QWidget为父类的自定义类很好用\r\n\r\n但是在QMainWindow中使用的时候要多写几句话。具体如下所示：\r\n\r\n```python\r\nwidget = QWidget()\r\nwidget.setLayout(gridLayout)\r\nself.setCentralWidget(widget)\r\n```\r\n\r\n```\r\ngridLayout = QGridLayout(self)\r\n```\r\n\r\n加上这几句话后，就和在QWidget中一样使用了。\r\n\r\n以上这篇浅谈pyqt5在QMainWindow中布局的问题就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。","timestamp":1590329650947},{"name":"31-python3+PyQt5 实现Rich文本的行编辑.md","path":"1-code疑难搜索/31-python3+PyQt5 实现Rich文本的行编辑.md","content":"# python3+PyQt5 实现Rich文本的行编辑\r\n\r\n#!/usr/bin/env python3\r\n\r\nimport platform\r\nimport sys\r\nimport html\r\nfrom PyQt5.QtCore import QSize, Qt,pyqtSignal\r\nfrom PyQt5.QtGui import QColor, QFont,QFontMetrics, QIcon, QKeySequence, QPixmap,QTextCharFormat\r\nfrom PyQt5.QtWidgets import QAction,QApplication,QMenu,QTextEdit\r\n\r\n\r\n\r\nclass RichTextLineEdit(QTextEdit):\r\n    returnPressed=pyqtSignal()\r\n    (Bold, Italic, Underline, StrikeOut, Monospaced, Sans, Serif,\r\n     NoSuperOrSubscript, Subscript, Superscript) = range(10)\r\n\r\n\r\n    def __init__(self, parent=None):\r\n        super(RichTextLineEdit, self).__init__(parent)\r\n    \r\n        self.monofamily = \"courier\"\r\n        self.sansfamily = \"helvetica\"\r\n        self.seriffamily = \"times\"\r\n        self.setLineWrapMode(QTextEdit.NoWrap)\r\n        self.setTabChangesFocus(True)\r\n        self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\r\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\r\n        fm = QFontMetrics(self.font())\r\n        h = int(fm.height() * (1.4 if platform.system() == \"Windows\"\r\n                                   else 1.2))\r\n        self.setMinimumHeight(h)\r\n        self.setMaximumHeight(int(h * 1.2))\r\n        self.setToolTip(\"Press <b>Ctrl+M</b> for the text effects \"\r\n                \"menu and <b>Ctrl+K</b> for the color menu\")\r\n\r\n\r\n    def toggleItalic(self):\r\n        self.setFontItalic(not self.fontItalic())\r\n\r\n\r\n    def toggleUnderline(self):\r\n        self.setFontUnderline(not self.fontUnderline())\r\n\r\n\r\n    def toggleBold(self):\r\n        self.setFontWeight(QFont.Normal\r\n                if self.fontWeight() > QFont.Normal else QFont.Bold)\r\n\r\n\r\n    def sizeHint(self):\r\n        return QSize(self.document().idealWidth() + 5,\r\n                     self.maximumHeight())\r\n\r\n\r\n    def minimumSizeHint(self):\r\n        fm = QFontMetrics(self.font())\r\n        return QSize(fm.width(\"WWWW\"), self.minimumHeight())\r\n\r\n\r\n    def contextMenuEvent(self, event):\r\n        self.textEffectMenu()\r\n\r\n\r\n    def keyPressEvent(self, event):\r\n        if event.modifiers() & Qt.ControlModifier:\r\n            handled = False\r\n            if event.key() == Qt.Key_B:\r\n                self.toggleBold()\r\n                handled = True\r\n            elif event.key() == Qt.Key_I:\r\n                self.toggleItalic()\r\n                handled = True\r\n            elif event.key() == Qt.Key_K:\r\n                self.colorMenu()\r\n                handled = True\r\n            elif event.key() == Qt.Key_M:\r\n                self.textEffectMenu()\r\n                handled = True\r\n            elif event.key() == Qt.Key_U:\r\n                self.toggleUnderline()\r\n                handled = True\r\n            if handled:\r\n                event.accept()\r\n                return\r\n        if event.key() in (Qt.Key_Enter, Qt.Key_Return):\r\n            self.returnPressed.emit()\r\n            event.accept()\r\n        else:\r\n            QTextEdit.keyPressEvent(self, event)\r\n\r\n\r\n    def colorMenu(self):\r\n        pixmap = QPixmap(22, 22)\r\n        menu = QMenu(\"Colour\")\r\n        for text, color in (\r\n                (\"&Black\", Qt.black),\r\n                (\"B&lue\", Qt.blue),\r\n                (\"Dark Bl&ue\", Qt.darkBlue),\r\n                (\"&Cyan\", Qt.cyan),\r\n                (\"Dar&k Cyan\", Qt.darkCyan),\r\n                (\"&Green\", Qt.green),\r\n                (\"Dark Gr&een\", Qt.darkGreen),\r\n                (\"M&agenta\", Qt.magenta),\r\n                (\"Dark Mage&nta\", Qt.darkMagenta),\r\n                (\"&Red\", Qt.red),\r\n                (\"&Dark Red\", Qt.darkRed)):\r\n            color = QColor(color)\r\n            pixmap.fill(color)\r\n            action = menu.addAction(QIcon(pixmap), text, self.setColor)\r\n            action.setData(color)\r\n        self.ensureCursorVisible()\r\n        menu.exec_(self.viewport().mapToGlobal(\r\n                   self.cursorRect().center()))\r\n\r\n\r\n    def setColor(self):\r\n        action = self.sender()\r\n        if action is not None and isinstance(action, QAction):\r\n            color = QColor(action.data())\r\n            if color.isValid():\r\n                self.setTextColor(color)\r\n\r\n\r\n    def textEffectMenu(self):\r\n        format = self.currentCharFormat()\r\n        menu = QMenu(\"Text Effect\")\r\n        for text, shortcut, data, checked in (\r\n                (\"&Bold\", \"Ctrl+B\", RichTextLineEdit.Bold,\r\n                 self.fontWeight() > QFont.Normal),\r\n                (\"&Italic\", \"Ctrl+I\", RichTextLineEdit.Italic,\r\n                 self.fontItalic()),\r\n                (\"Strike &out\", None, RichTextLineEdit.StrikeOut,\r\n                 format.fontStrikeOut()),\r\n                (\"&Underline\", \"Ctrl+U\", RichTextLineEdit.Underline,\r\n                 self.fontUnderline()),\r\n                (\"&Monospaced\", None, RichTextLineEdit.Monospaced,\r\n                 format.fontFamily() == self.monofamily),\r\n                (\"&Serifed\", None, RichTextLineEdit.Serif,\r\n                 format.fontFamily() == self.seriffamily),\r\n                (\"S&ans Serif\", None, RichTextLineEdit.Sans,\r\n                 format.fontFamily() == self.sansfamily),\r\n                (\"&No super or subscript\", None,\r\n                 RichTextLineEdit.NoSuperOrSubscript,\r\n                 format.verticalAlignment() ==\r\n                 QTextCharFormat.AlignNormal),\r\n                (\"Su&perscript\", None, RichTextLineEdit.Superscript,\r\n                 format.verticalAlignment() ==\r\n                 QTextCharFormat.AlignSuperScript),\r\n                (\"Subs&cript\", None, RichTextLineEdit.Subscript,\r\n                 format.verticalAlignment() ==\r\n                 QTextCharFormat.AlignSubScript)):\r\n            action = menu.addAction(text, self.setTextEffect)\r\n            if shortcut is not None:\r\n                action.setShortcut(QKeySequence(shortcut))\r\n            action.setData(data)\r\n            action.setCheckable(True)\r\n            action.setChecked(checked)\r\n        self.ensureCursorVisible()\r\n        menu.exec_(self.viewport().mapToGlobal(\r\n                   self.cursorRect().center()))\r\n\r\n\r\n    def setTextEffect(self):\r\n        action = self.sender()\r\n        if action is not None and isinstance(action, QAction):\r\n            what = action.data()\r\n            if what == RichTextLineEdit.Bold:\r\n                self.toggleBold()\r\n                return\r\n            if what == RichTextLineEdit.Italic:\r\n                self.toggleItalic()\r\n                return\r\n            if what == RichTextLineEdit.Underline:\r\n                self.toggleUnderline()\r\n                return\r\n            format = self.currentCharFormat()\r\n            if what == RichTextLineEdit.Monospaced:\r\n                format.setFontFamily(self.monofamily)\r\n            elif what == RichTextLineEdit.Serif:\r\n                format.setFontFamily(self.seriffamily)\r\n            elif what == RichTextLineEdit.Sans:\r\n                format.setFontFamily(self.sansfamily)\r\n            if what == RichTextLineEdit.StrikeOut:\r\n                format.setFontStrikeOut(not format.fontStrikeOut())\r\n            if what == RichTextLineEdit.NoSuperOrSubscript:\r\n                format.setVerticalAlignment(\r\n                        QTextCharFormat.AlignNormal)\r\n            elif what == RichTextLineEdit.Superscript:\r\n                format.setVerticalAlignment(\r\n                        QTextCharFormat.AlignSuperScript)\r\n            elif what == RichTextLineEdit.Subscript:\r\n                format.setVerticalAlignment(\r\n                        QTextCharFormat.AlignSubScript)\r\n            self.mergeCurrentCharFormat(format)\r\n\r\n\r\n    def toSimpleHtml(self):\r\n        htmltext = \"\"\r\n        black = QColor(Qt.black)\r\n        block = self.document().begin()\r\n        while block.isValid():\r\n            iterator = block.begin()\r\n            while iterator != block.end():\r\n                fragment = iterator.fragment()\r\n                if fragment.isValid():\r\n                    format = fragment.charFormat()\r\n                    family = format.fontFamily()\r\n                    color = format.foreground().color()                  \r\n                    text=html.escape(fragment.text())\r\n                    if (format.verticalAlignment() ==\r\n                        QTextCharFormat.AlignSubScript):\r\n                        text = \"<sub>{0}</sub>\".format(text)\r\n                    elif (format.verticalAlignment() ==\r\n                          QTextCharFormat.AlignSuperScript):\r\n                        text = \"<sup>{0}</sup>\".format(text)\r\n                    if format.fontUnderline():\r\n                        text = \"<u>{0}</u>\".format(text)\r\n                    if format.fontItalic():\r\n                        text = \"<i>{0}</i>\".format(text)\r\n                    if format.fontWeight() > QFont.Normal:\r\n                        text = \"<b>{0}</b>\".format(text)\r\n                    if format.fontStrikeOut():\r\n                        text = \"<s>{0}</s>\".format(text)\r\n                    if color != black or family:\r\n                        attribs = \"\"\r\n                        if color != black:\r\n                            attribs += \' color=\"{0}\"\'.format(color.name())\r\n                        if family:\r\n                            attribs += \' face=\"{0}\"\'.format(family)\r\n                        text = \"<font{0}>{1}</font>\".format(attribs,text)\r\n                    htmltext += text\r\n                iterator += 1\r\n            block = block.next()\r\n        return htmltext\r\n\r\nif __name__ == \"__main__\":\r\n    def printout(lineedit):\r\n        print(str(lineedit.toHtml()))\r\n        print(str(lineedit.toPlainText()))\r\n        print(str(lineedit.toSimpleHtml()))                \r\n    app = QApplication(sys.argv)\r\n    lineedit = RichTextLineEdit()\r\n    lineedit.returnPressed.connect(lambda:printout(lineedit))\r\n    lineedit.show()\r\n    lineedit.setWindowTitle(\"RichTextEdit\")\r\n    app.exec_()\r\n------------------------------------------------\r\n版权声明：本文为CSDN博主「basisworker」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/xiaoyangyang20/article/details/68924261","timestamp":1590329650947},{"name":"32-QTreeWidgetItem 点击可编辑修改.md","path":"1-code疑难搜索/32-QTreeWidgetItem 点击可编辑修改.md","content":"# QTreeWidgetItem 点击可编辑修改\r\n\r\n[ymc0329](https://me.csdn.net/ymc0329) 发布于2012-02-25 14:06:45 收藏\r\n\r\n展开\r\n\r\n```cpp\r\nQTreeWidgetItem* item = new QTreeWidgetItem(tree);// need to add editable flag, items are not editable by defaultitem->setFlags(item->flags() ¦ Qt::ItemIsEditable);tree->editItem(item, 0);\r\n```\r\n\r\n\r\n\r\n不可修改\r\n\r\nitem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsUserCheckable | Qt::ItemIsEnabled);\r\n\r\n\r\n\r\n\r\n\r\n| Constant                  | Value | Description                                       |\r\n| :------------------------ | :---- | :------------------------------------------------ |\r\n| `Qt::NoItemFlags`         | `0`   | It does not have any properties set.              |\r\n| `Qt::ItemIsSelectable`    | `1`   | It can be selected.                               |\r\n| `Qt::ItemIsEditable`      | `2`   | It can be edited.                                 |\r\n| `Qt::ItemIsDragEnabled`   | `4`   | It can be dragged.                                |\r\n| `Qt::ItemIsDropEnabled`   | `8`   | It can be used as a drop target.                  |\r\n| `Qt::ItemIsUserCheckable` | `16`  | It can be checked or unchecked by the user.       |\r\n| `Qt::ItemIsEnabled`       | `32`  | The user can interact with the item.              |\r\n| `Qt::ItemIsTristate`      | `64`  | The item is checkable with three separate states. |\r\n\r\n注意：逻辑关系","timestamp":1590329650947},{"name":"33-基于Python3和pyqt5实现控件数据动态显示.md","path":"1-code疑难搜索/33-基于Python3和pyqt5实现控件数据动态显示.md","content":"# 基于Python3和pyqt5实现控件数据动态显示\r\n\r\n[lbllich](https://me.csdn.net/lbllich) 发布于2019-03-02 15:25:33 收藏\r\n\r\n展开\r\n\r\n最近笔者在做一个pyqt5的界面，由于在日常生活中，一些实际运用的场合都需要对数据进行实时的刷新，例如对某个数值的监控，水温，室温的监控等等，都需要实时的刷新控件显示的数据。\r\n对于实现这样的一种功能，pyqt5在面板生成的同时就固定住了UI中的数据，例如我们产生一个QLineEdit控件，然后布局在面板上，但是控件中的数据是固定的，如果这个数据是实时更新的，想要改变空间中的数据时，就要去刷新面板，pyqt5提供了一个QApplication.processEvents()的命令来刷新整个面板，但是要完成数据的动态显示，则要不断的去调用这个函数来刷新面板，同样，以使用多线程去刷新面板上的数据，但是通过搜索各种大佬的博客等，发现了pyqt5多线程刷新的各种问题，即大佬主要使用多线程来对控件显示的数据进行实时的刷新。 本文旨在演示一种使用定时器来刷新控件实现数据的方法，具体代码如下：\r\n\r\n```\r\nimport sys\r\nimport random\r\nimport numpy as np\r\nfrom time import sleep\r\nimport datetime\r\nfrom PyQt5 import QtWidgets\r\nfrom PyQt5.QtCore import *\r\nfrom PyQt5.QtGui import *\r\nfrom PyQt5.QtWidgets import *\r\n123456789\r\n```\r\n\r\n# 定义数据生成线程，该线程主要目的是不断生成随机数，用来模拟不断采集数据\r\n\r\n```\r\nclass WorkThread(QThread):\r\n    # 初始化线程\r\n    def __int__(self):\r\n        super(WorkThread, self).__init__()\r\n    #线程运行函数\r\n    def run(self):\r\n        while True:\r\n            global T_value\r\n            global P_value\r\n            T_value = random.randint(200,225)\r\n            P_value = random.randint(150,200)\r\n            print(T_value, P_value)\r\n            sleep(3)\r\n12345678910111213\r\n```\r\n\r\n# 定义显示面板\r\n\r\n```\r\nclass plotwindows(QtWidgets.QWidget):\r\n    def __init__(self):\r\n        super(plotwindows,self).__init__()\r\n        layout = QFormLayout()\r\n        self.edita3 = QLineEdit()\r\n        self.edita4 = QLineEdit()\r\n        self.edita5 = QLineEdit()\r\n        layout.addRow(\"A数值\", self.edita3)\r\n        layout.addRow(\"B数值\", self.edita4)\r\n        layout.addRow(\"C数值\", self.edita5)\r\n        self.setLayout(layout)\r\n        self.Mytimer()\r\n123456789101112\r\n```\r\n\r\n# 定义定时器，使用定时器每隔一段时间来出发update函数，从而刷新数据\r\n\r\n```\r\ndef Mytimer(self):\r\n    timer = QTimer(self)\r\n    timer.timeout.connect(self.update)\r\n    timer.start(100)\r\n1234\r\n```\r\n\r\n# 刷新函数\r\n\r\n```\r\ndef update(self):\r\n   self.edita3.setText(str(T_value))\r\n    self.edita4.setText(str(P_value))\r\n    global SUM_value\r\n    SUM_value = T_value + P_value\r\n    self.edita5.setText(str(SUM_value))\r\n\r\ndef mainwindows():\r\n    app =QtWidgets.QApplication(sys.argv)\r\n    new = plotwindows()\r\n    new.show()\r\n    sys.exit(app.exec_())\r\n\r\nif __name__ == \"__main__\":\r\n    workThread = WorkThread()\r\n    workThread.start()\r\n    mainwindows()\r\n1234567891011121314151617\r\n```\r\n\r\n![在这里插入图片描述](F:\\Typora_book\\typora_pic\\20190302152019695.png)\r\n![在这里插入图片描述](F:\\Typora_book\\typora_pic\\20190302152038180.png)\r\n可以看到，子线程不断的生成数据，同时定时器以一种不断调用刷新函数的方法来实现对控件显示数据的刷新，这样就不用再建立新线程的情况下实现刷新控件显示的功能。\r\n如有不足，请多指教。。。","timestamp":1590329650947}]